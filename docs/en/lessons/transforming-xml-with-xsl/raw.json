{"metadata":{"title":"Transforming Data for Reuse and Re-publication with XML and XSL","layout":"lesson","date":"2016-07-07T00:00:00.000Z","authors":["M. H. Beals"],"reviewers":["Jonathan Blaney","Tessa C Hauswedell"],"editors":["Adam Crymble"],"difficulty":1,"review-ticket":"https://github.com/programminghistorian/ph-submissions/issues/11","activity":"transforming","topics":["data-manipulation"],"abstract":"This tutorial will provide you with the ability to convert or transform historical data from an XML database (whether a single file or several linked documents) into a variety of different presentations—condensed tables, exhaustive lists or paragraphed narratives—and file formats.","redirect_from":"/lessons/transforming-xml-with-xsl","avatar_alt":"A peacock with a woman's head","doi":"10.46430/phen0059"},"html_body":"<div class=\"alert alert-warning\">\nA problem with the instructions in this lesson has been reported. Readers are advised that they will not be able to complete the lesson in its current form due to changes in technology beyond the control of the author. We are investigating solutions and appreciate your patience.     18 August 2020.\n</div>\n\n\n<p>{% include toc.html %}</p>\n<h2 id=\"introduction\">Introduction</h2>\n<p>The day before your colleague is due to give a seminar on <em>Slave Rebellions in the New World</em>, he phones you to say he is ill and needs you to cover his sessions. You decide to compile a selection of primary sources to work through in class. You find some websites and readers with good sources, but scanning or cutting-and-pasting them into a new document is time consuming; the formatting and citations are inconsistent and you begin to wonder if the ones you have chosen work well together. One site allows you to download an <a href=\"https://en.wikipedia.org/wiki/XML\">XML</a> version of all its sources, but there are so many records, and so much <a href=\"https://en.wikipedia.org/wiki/Metadata\">metadata</a>, that you cannot find the material you want quickly.</p>\n<p>Or perhaps...</p>\n<p>You find an old copy of <em>Inscriptions of Roman Tripolitania</em> (1952) and wish that you could run a statistical analysis on the appearance of certain phrases in certain locations. Fortunately, King&#39;s College London has produced an extensive <a href=\"https://irt.kcl.ac.uk/irt2009/\">e-version of the text</a> with images, translations and location information. You can search through the material manually using the full-text search on the site, but curating the information you want, in the format you need to run an analysis, will take time.</p>\n<p>Then again...</p>\n<p>You are starting a new project analysing book auction catalogues from the early seventeenth century. You start recording the publication details and auction listings into a series of Word documents and Excel spreadsheets. A month into the project, you are invited to present your research to the Pro-Vice Chancellor. Your head of department suggests that you create a &#39;snazzy&#39; set of slides and handouts to help her understand your project.  You have some preliminary conclusions about the material, but the data is scattered in several places and formatting it properly will take more time than you have.</p>\n<p>In all three of these situations, a basic understanding of XML, and its sister-language <a href=\"https://en.wikipedia.org/wiki/XSL\">XSL</a>, could have saved you time and aggravation.  This tutorial will provide you with the ability to convert or transform historical data from an <a href=\"https://en.wikipedia.org/wiki/XML\">XML</a> database (whether a single file or several linked documents) into a variety of different presentations---condensed tables, exhaustive lists or paragraphed narratives---and file formats. Whether filtering a large database or adding formatting such as headings and pagination, <a href=\"https://en.wikipedia.org/wiki/XSL\">XSL</a> offers historians the ability to reshape databases to support their changing research or publication needs.</p>\n<h2 id=\"what-is-xml\">What is XML?</h2>\n<p><strong>eXtensible Markup Language</strong> (<strong>XML</strong>) is a highly flexible method for encoding or structuring your data.  Unlike <a href=\"https://en.wikipedia.org/wiki/HTML\"><strong>Hypertext Markup Language</strong> (<strong>HTML</strong>)</a>, which has a set vocabulary, XML is extensible; it can be expanded to include whatever sections, sub-section, and sub-sub-sections you need in order to store your data in the way you wish.</p>\n<p>A database can be made up of one or more XML files and each file has the same basic structure. Each section, or layer, of the file is surrounded by a set of <a href=\"https://en.wikipedia.org/wiki/XSLT_elements\">elements</a>. An element is, essentially, a category or name for the type of data you are providing. Like <a href=\"https://en.wikipedia.org/wiki/Matryoshka_doll\">Russian Nesting Dolls</a>, each level of elements exists entirely within another one. The <strong>top-level element</strong> encloses the entire database. Each element within the top-level element is a <strong>child</strong> of that element. Likewise, the element surrounding a child element is called the <strong>parent</strong> element.</p>\n<pre><code>&lt;top&gt;\n    &lt;parent&gt;\n        &lt;child&gt;&lt;/child&gt;\n    &lt;/parent&gt;\n&lt;/top&gt;\n</code></pre>\n<p>Every element can, depending on the rules of your database, have a value (textual or numerical) as well as any number of child elements.</p>\n<pre><code>&lt;top&gt;\n    &lt;parent&gt;\n        &lt;child_1&gt;value&lt;/child_1&gt;\n        &lt;child_2&gt;value&lt;/child_2&gt;\n        &lt;child_3&gt;value&lt;/child_3&gt;\n    &lt;/parent&gt;\n&lt;/top&gt;\n</code></pre>\n<p>They can also have <a href=\"https://en.wikipedia.org/wiki/Attribute_(computing)\">attributes</a>, which can be thought of as metadata for the element. Attributes can, for example, help you distinguish between different types of values without having to create a new type of element.</p>\n<pre><code>&lt;top&gt;\n    &lt;name&gt;\n        &lt;last&gt;Crockett&lt;/last&gt;\n        &lt;first type=&quot;formal&quot;&gt;David&lt;/first&gt;\n        &lt;first type=&quot;informal&quot;&gt;Davy&lt;/first&gt;\n    &lt;/parent&gt;\n&lt;/top&gt;\n</code></pre>\n<p>Once you are given an XML database, or have stored your own data within one, you can use XSL to sort, filter and display this information in (almost) any way you wish. You can even break open OpenXML files, such as Word (.docx) or Excel (.xslx) files, and see or remove any additional information that Microsoft has inserted into your documents, such as tags identifying geographical locations.</p>\n<p>A more detail discussion of XML, its structure, and its use in the humanities, is available from the <a href=\"https://web.archive.org/web/20191028132600/https://www.tei-c.org/release/doc/tei-p5-doc/en/html/SG.html\">Text Encoding Initative</a>.</p>\n<h2 id=\"what-is-xsl\">What is XSL?</h2>\n<p><strong>eXtensible Stylesheet Language</strong> (<strong>XSL</strong>) is the natural complement to XML. At its most basic level, it provides layout and formatting instructions in much the same way as <a href=\"https://en.wikipedia.org/wiki/Cascading_Style_Sheets\"><strong>Cascading Stylesheets</strong> (<strong>CSS</strong>)</a> do for HTML files. This allows you to transform your plain-text data into richly formatted text, as well as dictate its layout on a screen or in print, without altering your original data files. At a more advanced level, it also allows you to sort or filter your records based on particular critera, or create and display compound or derived values based on your original dataset.</p>\n<p>By keeping your data (XML) and formatting instructions (XSL) separate, you are able to refine and alter your layout without the risk of compromising the structure of your data. You are also able to create a number of different <em>styles</em>, each serving a different purpose, and apply them as necessary to a single data set. In practice, this means only having to update your data in one place, even if you export it to many different documents.</p>\n<p>The following tutorial will therefore explain</p>\n<ul>\n<li><strong>Editors</strong>: The tools needed to create XSL transformation files</li>\n<li><strong>Transformers</strong>: The tools needed to apply your XSL transformation instructions to your XML database</li>\n<li><strong>Choosing and Preparing XML Data</strong>: How to connect your database to your XSL transformation instructions</li>\n</ul>\n<p>as well as walk you through the creation of some of the most common transformations intructions, including</p>\n<ul>\n<li><strong>Printing Values</strong>: How to print or display your data</li>\n<li><strong>For-Each Loops</strong>: How to display particular data for each record</li>\n<li><strong>Sorting Results</strong>: How to display your data in a particular order</li>\n<li><strong>Filtering Results</strong>: How to select which records you display</li>\n</ul>\n<h2 id=\"necessary-and-helpful-software-packages\">Necessary and Helpful Software Packages</h2>\n<h3 id=\"editors\">Editors</h3>\n<p>One of the advantages of storing data in a plain-text format is the ease of obtaining appropriate software for viewing and manipulating it. For the purposes of this tutorial, you can use any <a href=\"https://en.wikipedia.org/wiki/Plain_text\">plain-text</a> editor, such as <strong>Notepad</strong> (Windows) or <strong>TextEdit</strong> (Mac OS), but should not use a <a href=\"https://en.wikipedia.org/wiki/WYSIWYG\">WYSIWYG (what you see is what you get)</a> <a href=\"https://en.wikipedia.org/wiki/Word_processor\">word processor</a> such as Microsoft Word, as these often insert non-<a href=\"https://en.wikipedia.org/wiki/ASCII\">ascii</a> characters, such as curly quotation marks, that will prevent your XSL from processing correctly. This tutorial will assume you are using Notepad or TextEdit.</p>\n<p>Although these will provide everything you need, you may prefer to download a more advanced editor, such as\n<a href=\"https://notepad-plus-plus.org/download/\"><strong>Notepad++</strong></a> or <a href=\"https://atom.io/\"><strong>Atom</strong></a>. These free editors maintain the plain-text format of your data while providing you with different colour schemes (such as green-on-black or brown-on-beige) as well the ability to collapse (hide) sections or easily comment-out (temporarily disable) sections of your code.</p>\n<p>When you become more comfortable with XML and XSL, and are ready to tackle more complicated transformations, you may want to consider using a dedicated XML editor, such as <a href=\"https://www.oxygenxml.com/\"><strong>OxygenXML</strong></a>.</p>\n<h3 id=\"transformers\">Transformers</h3>\n<p>Once you have obtained your preferred text editor, you will need to obtain an <strong>XSL transformer</strong>. There are two ways to use XSL stylesheets to transform your XML data: on the command line or through an embedded transformer within another programme. Although there are many stand-alone programmes for XSL transformation, you can also undertake simple transformations using an internet browser.</p>\n<p>Although Chrome and Safari&#39;s security features make in-browser transformations difficult, some other internet browsers, such as (<a href=\"http://windows.microsoft.com/en-gb/internet-explorer/download-ie\">Internet Explorer</a> and <a href=\"https://www.mozilla.org/en-GB/firefox/new/\">Firefox</a>), include an <strong>XSL 1.0</strong> transformer, which will provide all of the functionality that you will need for this tutorial. If you don&#39;t already have one of these browsers on your computer, download and install whichever you feel most comfortable using and then proceed to the next section.</p>\n<h2 id=\"choosing-and-preparing-xml-data\">Choosing and Preparing XML Data</h2>\n<p>In order to begin transforming XML, you will need to obtain a well-formed dataset. Many online historical databases are built upon XML and provide their data freely. This tutorial will make use of the <a href=\"http://www.scissorsandpaste.net\"><strong>Scissors and Paste Database</strong></a>.</p>\n<p>The <em>Scissors and Paste Database</em> is a collaborative and growing collection of articles from British and imperial newspapers in the 18th and 19th centuries. Its original purpose was to allow for careful comparisons of reprints (copies) that appeared in multiple newspapers as well as to detect similarly themed articles across different English-language publications. Like many XML databases, <em>Scissors and Paste</em> contains both data (the article&#39;s text), formatting information (such as italics and justification), and metadata. This metadata includes documentation about the particular article, such as its pagination and printing date, information about the newspaper in which it was published, and the themes, individuals or locations mentioned in the text.</p>\n<p>As of 2015, the database contained over 350 individual articles, each with attached metadata. Although some researchers may need all of this information, most will only be interested in a subsection of the data---a particular year, theme or publication. By using XSL, these researchers can quickly filter out the information they do not need or re-arrange the material in the way that is most helpful for their project. For example, the module tutor in our introduction or a researcher who wants a simple table of the dates, publications and page numbers of humorous articles within the database. Both can be quickly created using XSL.</p>\n<p>To begin work with the Scissors and Paste Database, visit its <a href=\"http://www.github.com/mhbeals/scissorsandpaste\">Github repository</a>. On the right-hand side of the screen, you will see the option to <strong>Download Zip</strong>.  Save this to your computer desktop or primary documents folder.</p>\n<p>{% include figure.html filename=&quot;transforming-xml-with-xsl-1.png&quot; caption=&quot;Figure 1: Downloading Your Data&quot; %}</p>\n<p>Alternatively, you can also download the scissors and paste file <a href=\"/assets/scissorsandpaste-master.zip\">here</a>.</p>\n<p>Open the ZIP file and you will find a folder entitled <strong>scissorsandpaste-master</strong>.  Extract this folder by either using the extract button of your unzipping programme or by dragging and dropping the folder onto your desktop.</p>\n<p>This data package has three main components</p>\n<ul>\n<li><strong>TEISAP.XML</strong>: The central XML database</li>\n<li><strong>Transformers</strong>: A collection of XSL stylesheets</li>\n<li><strong>Outputs</strong>: Outputs derived from the database using the XSL stylesheets</li>\n</ul>\n<p>The package also includes</p>\n<ul>\n<li>A <strong>Template</strong>, for anyone wishing to contribute to the database</li>\n<li>A <strong>README</strong> file, providing information about the database</li>\n<li>A <strong>Cite</strong> file, explaining the preferred way to cite the database</li>\n<li>A <strong>License</strong> file, explaining the terms of use</li>\n</ul>\n<p>Once you have completed the tutorial, you can explore the different XSL stylesheets (transformers) included here, and their associated outputs, to discover additional possibilities for your own datasets.</p>\n<p>The main TEISAP.XML database has been encoded to <a href=\"https://tei-c.org\"><strong>Text-Encoding Initiative</strong> (<strong>TEI</strong>)</a> standards and includes a significant amount of metadata. For the purposes of this tutorial, however, we will be using a simplified version of the database that focuses on some of the core historical data.</p>\n<p>Open the outputs folder and continue into the XML folder. Here you will find a folder entitled <strong>Simplified</strong>. Copy the <strong>SimplifiedSAP.xml</strong> file to your desktop.</p>\n<p>Using your chosen web browser, open <em>SimplifiedSAP.xml</em> and examine the file. You can do this using the standard &#39;Open&#39; function of your browser&#39;s tool bar, or by dragging-and-dropping the file from your desktop into the browser window.</p>\n<p>{% include figure.html filename=&quot;transforming-xml-with-xsl-2.png&quot; caption=&quot;Figure 2: Viewing the XML&quot; %}</p>\n<p>The first line of the XML database is <code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code>, which indicates the version of XML used (1.0) and the encoding method of the text (UTF-8).  The second line is <code>&lt;root&gt;</code>, which has a matching line, <code>&lt;/root&gt;</code>, at the end of the file.</p>\n<p><code>&lt;root&gt;</code> is the top-level element of this database and surrounds all the records within it. Each individual record, containing the information for one historical newspaper article, is opened by the element <code>&lt;record&gt;</code> and closed with the element <code>&lt;/record&gt;</code>.</p>\n<p>Within these records are a number of different child elements. The Text-Encoding Initiative allows for hundreds of different sub-elements to fit a very wide range of data. Moreover, the beauty of XML is that you can name your elements anything you like (<em><a href=\"http://www.w3schools.com/xml/xml_elements.asp\">with a few small exceptions</a></em>). In the Scissors and Paste Database, each record has the following elements:</p>\n<ul>\n<li><strong>id</strong>: The ID number of the record</li>\n<li><strong>title</strong>: The title of the newspaper</li>\n<li><strong>city</strong>: The city of the newspaper</li>\n<li><strong>province</strong>: The province or administrative region of the newspaper</li>\n<li><strong>country</strong>: The country of the newspaper</li>\n<li><strong>date</strong>: The full <a href=\"https://en.wikipedia.org/wiki/ISO_8601\">ISO date</a> of the article</li>\n<li><strong>year</strong>: The year of publication</li>\n<li><strong>month</strong>: The month of publication</li>\n<li><strong>day</strong>: The day of publication</li>\n<li><strong>keywords</strong>: The section containing keywords describing the article</li>\n<li><strong>keyword</strong>: An individual keyword describing the article</li>\n<li><strong>headline</strong>: The headline of the article. This may be blank.</li>\n<li><strong>text</strong>: The section containing the text of the article</li>\n<li><strong>p</strong>: An individual paragraph within the text.</li>\n</ul>\n<p>These are the different types of data that you will be able to use in creating your outputs.</p>\n<p>In order to undertake a browser-based transformation, you will need to put in a stylesheet reference within your xml file.</p>\n<p>Using your prefered text editor, open <em>SimplifiedSAP.xml</em> and examine the contents.</p>\n<p>Create a new line underneath <code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code>.  On this new line, type</p>\n<pre><code>&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;mystyle.xsl&quot;?&gt;\n</code></pre>\n<p>and save your XML file.</p>\n<p>{% include figure.html filename=&quot;transforming-xml-with-xsl-3.png&quot; caption=&quot;Figure 3: Adding a Stylesheet Reference to your XML&quot; %}</p>\n<p>This line points to the XSL file you are about to create and will therefore set it as the default XSL stylesheet for this database. It does not matter what you name the .xsl file, so long as you remember it for the next step.</p>\n<h2 id=\"creating-and-testing-your-xsl-file\">Creating and Testing Your XSL File</h2>\n<p>It is now time to create your XSL file. In your text editor, create a new file and save it as <strong>mystyle.xsl</strong> (or whatever you named your .xsl in the previous step), ensuring that it is in the same folder as your XML file (for example, your Desktop or Simplified.)</p>\n<p>The first two lines of you XSL file should be the following:</p>\n<pre><code>&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;\n&lt;xsl:output method=&quot;text&quot;/&gt;\n</code></pre>\n<p>The first line documents that you are using XSL version 1.0 and the standards (or <a href=\"https://en.wikipedia.org/wiki/Namespace\">namespace</a>) established by the <a href=\"http://www.w3.org/\">World Wide Web Consortium</a>, whose web address you have listed. The second line tells your transformer what sort of output you would like to create. In this case, you are indicating that you will be creating a plain-text file. You could also have written &quot;xml&quot; or &quot;html&quot;.</p>\n<p>Every time you open an element <code>&lt;element&gt;</code> you will need to close it <code>&lt;/element&gt;</code>, otherwise you will receive an error. Close your stylesheet by adding the following as the final line of your file:</p>\n<pre><code>&lt;/xsl:stylesheet&gt;\n</code></pre>\n<p>The next part of your XSL stylesheet will be the main template, or formatting instructions, for your output.  On a new line, directly underneath <code>&lt;xsl:output method=&quot;text&quot;/&gt;</code> type</p>\n<pre><code>&lt;xsl:template match=&quot;/&quot;&gt;\n&lt;/xsl:template&gt;\n</code></pre>\n<p>It is between these two elements that you will put all your layout instructions.</p>\n<p>You have written <strong>&quot;/&quot;</strong> in your <em>match</em> attribute to indicate that you will be referring to everything within the XML file. You could have also used <strong>&quot;root&quot;</strong>, which would have indicated that you were only using data within the root element. However, using &quot;root&quot; may cause unexpected <a href=\"https://en.wikipedia.org/wiki/Syntax_error\">errors</a> later on, so it is best practice to use &quot;/&quot; for your main template.</p>\n<p>Your file should now look like this:</p>\n<pre><code>&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;\n&lt;xsl:output method=&quot;text&quot;/&gt;\n&lt;xsl:template match=&quot;/&quot;&gt;\n&lt;/xsl:template&gt;\n&lt;/xsl:stylesheet&gt;\n</code></pre>\n<p>Save your file.  For the remainder of the tutorial, remember to save your file after each change you make.</p>\n<p>N.B. If you are using TextEdit, you will not be able to save the file as an XSL directly. Instead, save as a PlainText (.txt) file and close the document. Then, locate the file within Finder and rename it, changing the extension from .txt to .xsl. Now, reopen the file within TextEdit to continue.</p>\n<p>In between your template elements, type <code>&lt;xsl:value-of select=&quot;root&quot;/&gt;</code> You do not need to do so on a new line, but doing so will make your stylesheet more readable. You&#39;ll notice that I didn&#39;t include a <code>&lt;/root&gt;</code>. This is because <code>&lt;xsl:value-of select=&quot;root&quot;/&gt;</code> is self-closing; the <code>/</code> at the end of the element closes it immediately.</p>\n<p>After you save your file, open your preferred web browser (IE or Firefox) and use it to open your XML file.  The simplest way to do this is to drag the xml file (the file with the <em>Scissors and Paste</em> data) into your browser window, but you can also open it using your browser&#39;s standard <em>Open File</em> function.</p>\n<p>You should now see the text from your data file with line breaks but <em>without</em> its structuring elements, as pictured below.</p>\n<p>{% include figure.html filename=&quot;transforming-xml-with-xsl-4.png&quot; caption=&quot;Figure 4: Initial Text Output&quot; %}</p>\n<p>If you see the XML data without any formatting, or an error message, go back and double-check your stylesheet reference within you XML file as well as your XSL stylesheet. Even a small typographical error will prevent the transformer from rendering the output.</p>\n<p>{% include figure.html filename=&quot;transforming-xml-with-xsl-5.png&quot; caption=&quot;Figure 5: Unstructured &#39;Error&#39; Output&quot; %}</p>\n<p>Once you have successfully rendered the data as a plain-text output, organise your desktop so that you can move quickly between your text editor and your browser.  I suggest docking (snapping) your browser window to one side of the screen and your editor to the other.</p>\n<p>{% include figure.html filename=&quot;transforming-xml-with-xsl-6.png&quot; caption=&quot;Figure 6: Organising Your Workspace&quot; %}</p>\n<h2 id=\"populating-your-outputs\">Populating Your Outputs</h2>\n<p>Your single line of code <code>&lt;xsl:value-of select=&quot;root&quot;/&gt;</code> printed the entire database in plain-text format.  If you look at the components of this line, you can see why:</p>\n<ul>\n<li><p><strong>xsl:value-of</strong>: An instruction for printing the value of an element; that is, the text between the opening and closing tag of an element within the XML file.</p>\n</li>\n<li><p><strong>select=&quot;root&quot;</strong>: An instruction that explains which element it should print the value of. Unless you instruct it otherwise, pointing to a parent (outside) element will also tell the transformer to print the values of any child (inside) elements as well. Thus, pointing to <em>root</em>  also prints <em>id</em>, <em>title</em> and so on.</p>\n</li>\n</ul>\n<h2 id=\"printing-values\">Printing Values</h2>\n<p>In order to print the value of a particular data element, you simply need to replace the &quot;root&quot; with another element name. In your XSL stylesheet, replace <em>root</em> with <em>title</em>. Save your file and refresh your browser (usually <em>ctrl+F5</em> or <em>cmd+r</em>) to see your changes.</p>\n<p>It didn&#39;t work? That is because we only gave the transformer part of the instructions it needed.</p>\n<h3 id=\"parents-and-children\">Parents and Children</h3>\n<p>Title is not the top-level element, so we must explain to the transformer how to get to the element we mean. This more specific direction is known as the <a href=\"https://en.wikipedia.org/wiki/XPath\"><em>XPATH</em></a>, and works in a similar way to the file paths on your computer. Replace <em>title</em> with <em>root/record/title</em>.</p>\n<pre><code>&lt;xsl:value-of select=&quot;root/record/title&quot;/&gt;\n</code></pre>\n<p>Save and refresh your browser.</p>\n<p>The browser should now display &quot;Caledonian Mercury&quot;, the first title in our database. Where are the rest? Although, we have over 300 <em>title</em> values in the database, we did not specify which we wanted the transformer to print, so it assumed we meant the first one, and only the first one.</p>\n<h3 id=\"for-each-loops\">For-Each Loops</h3>\n<p>To a human being, it may seem natural that we wanted <em>all</em> the title values, but the transformer does not know this by default. Instead, we must create a <strong>For-Loop</strong>.</p>\n<p>A For-Loop tells the transformer that <em>for</em> a certain condition, it should <em>loop</em> through the entire database and follow the instructions each time the data meets that criteria.</p>\n<p>Create a new line after <code>&lt;xsl:template match=&quot;/&quot;&gt;</code> and insert <code>&lt;xsl:for-each select=&quot;root/record&quot;&gt;</code>.  This tells the transformer that for each <em>record</em> within the <em>root</em> element, it should take some action.</p>\n<p>Remove <em>root/record</em> from your <code>&lt;xsl:value-of&gt;</code> element.  It should now simply say <em>title</em>, because we are now already within a <em>root/record</em> element. After your <code>&lt;xsl:value-of&gt;</code>, add a new line that closes the <code>&lt;xsl:for-each&gt;</code> element, <code>&lt;/xsl:for-each&gt;</code></p>\n<p>Your file should now look like this:</p>\n<pre><code>&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;\n&lt;xsl:output method=&quot;text&quot;/&gt;\n\n&lt;xsl:template match=&quot;/&quot;&gt;\n\n&lt;xsl:for-each select=&quot;root/record&quot;&gt;\n&lt;xsl:value-of select=&quot;title&quot;/&gt;\n&lt;/xsl:for-each&gt;\n\n&lt;/xsl:template&gt;\n\n&lt;/xsl:stylesheet&gt;\n</code></pre>\n<p>Here you can see that your <em>template</em> has three lines of code.</p>\n<ol>\n<li>An opening element for your <em>for-loop</em></li>\n<li>An instruction to print the value of title</li>\n<li>A closing element for your <em>for-loop</em></li>\n</ol>\n<p>Save your file and refresh your browser. You should now have a very messy line of text, listing the value of every title element in the database. You can organise this data by instructing the transformer to add a new line after each entry.</p>\n<p>At the end of your <em>value-of</em> line, type <code>&lt;xsl:text&gt;&amp;#xA;&lt;/xsl:text&gt;</code> to add a line break. <code>&amp;#xA;</code> is the <a href=\"https://en.wikipedia.org/wiki/Universal_Coded_Character_Set\">ISO 10646 hex code</a> for a new line and the <code>&lt;xsl:text&gt;</code> element tells the transformer to print the value as plain text.</p>\n<p>Depending on the type of outputs you are using, some special characters, particularly multiple spaces or line breaks, may not render correctly if entered on their own. Using <code>&lt;text&gt;</code> elements ensures that your text renders exactly the way you intend it to.</p>\n<p>Save and refresh your browser to see your changes.  Using this information, you should now be able to print the value of any element for each record in the database.</p>\n<h4 id=\"exercise-a\">Exercise A:</h4>\n<p>Note: Possible solutions for the following exercises are located at the end of the tutorial.</p>\n<p>Print an inventory of the records in database, displaying the <em>id</em>, <em>title</em> and <em>date</em> of each record. A solution to this and the following exercises is available at the end of the tutorial.</p>\n<h4 id=\"exercise-b\">Exercise B:</h4>\n<p>Print the text of all the articles in the database, displaying the ID number in brackets at the start of each article.</p>\n<h3 id=\"attributes\">Attributes</h3>\n<p>Not all data is stored as the value of an element. Some data is stored as the value of an attribute of that element.  For example the <code>&lt;date&gt;</code> element has an attribute called <code>when</code> with the value of the date of the article.</p>\n<pre><code>&lt;date when=&quot;1815-01-12&quot;/&gt;\n</code></pre>\n<p>To print the value of <code>when</code> you will need to reference the attribute using <code>@when</code></p>\n<pre><code>&lt;xsl:value-of select=&quot;date/@when&quot;/&gt;\n</code></pre>\n<h4 id=\"exercise-c\">Exercise C</h4>\n<p>Create an inventory of records in the database, listing the title of the newspaper followed by the date of publication.</p>\n<h2 id=\"sorting-results\">Sorting Results</h2>\n<p>This database was compiled as data was collected, rather than by date or title.  To re-sort it, you can add a <code>&lt;xsl:sort&gt;</code> instruction to the top of any for-loop, immediately following the <code>&lt;xsl:for-each&gt;</code> element.  This instruction has several optional attributes that will dictate how your data is sorted</p>\n<ul>\n<li><strong>select</strong>: the name of the element to sort the data by</li>\n<li><strong>order</strong>: informs the transformer if the data should be sorted in an <em>ascending</em> or <em>descending</em> order</li>\n<li><strong>data-type</strong>: informs the transformer if the data is <em>text</em> or a <em>number</em></li>\n</ul>\n<p>It must be attributed in this order. For example, to sort the <em>id</em> in reverse order, use</p>\n<pre><code>&lt;xsl:sort select=&quot;id&quot; order=&quot;descending&quot; data-type=&quot;number&quot;/&gt;\n</code></pre>\n<p>You can sort by an element even if you do not print that element in your output.</p>\n<h4 id=\"exercise-d\">Exercise D</h4>\n<p>Print the text of all the articles in the database, sorting from earliest to latest. For the purposes of the <code>sort</code> function, treat dates as <em>text</em>.</p>\n<h2 id=\"filtering-results\">Filtering Results</h2>\n<p>So far, you have printed all the records contained in the database.  If you only want a selection of records, you will need to filter the results using an <strong>if statement</strong>.  An <code>&lt;xsl:if&gt;</code> element has one attribute, which is a test condition. If the condition is true, the transformer will follow the instructions within the <code>&lt;xsl:if&gt;</code> element. If not, it will ignore these statements and move onto the next part of the template.</p>\n<p>For example, to print the <em>id</em> numbers of all the records from 1815, you would type</p>\n<pre><code>&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;\n&lt;xsl:output method=&quot;text&quot;/&gt;\n\n&lt;xsl:template match=&quot;/&quot;&gt;\n  &lt;xsl:for-each select=&quot;root/record&quot;&gt;\n    &lt;xsl:if test=&quot;date/year=&#39;1815&#39;&quot;&gt;\n      &lt;xsl:value-of select=&quot;id&quot;/&gt;\n      &lt;xsl:text&gt;&amp;#xA;&lt;/xsl:text&gt;\n    &lt;/xsl:if&gt;\n  &lt;/xsl:for-each&gt;\n&lt;/xsl:template&gt;\n\n&lt;/xsl:stylesheet&gt;\n</code></pre>\n<p>If you want to exclude 1815, use <code>date/year != &#39;1815&#39;</code> instead. != means <em>not equal to</em>.</p>\n<h4 id=\"exercise-e\">Exercise E</h4>\n<p>Using all you have learned so far, create a list of records from 1789, starting with the most recent, listing the id, title, and date of each record. Separate the data elements with commas and place each record on it own line.</p>\n<p>When you are satisfied with your results, save the file, using your browser&#39;s <em>Save As</em> function, as  <code>sap_itd.csv</code>. You now have a comma-separated data file that can be opened and manipulated in any spreadsheet programme, such as Excel or CALC.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>You now know the basics of XSL stylesheet creation.  With this information you can create a range of outputs including plain-text, comma-separated, tab-separated and markdown files.  You can also create webpages by changing your <code>&lt;xsl:output&gt;</code> method to <em>html</em> and  wrapping your <code>&lt;xsl:value-of&gt;</code> commands in the appropriate HTML tags.</p>\n<p>There are many more transformation commands that you can use to further customise your outputs.  Some of these require the use of a 2.0 transformer, but the above should cover most of your day-to-day transformation needs.</p>\n<p>Once you are comfortable using the commands listed here, explore the <em>transformers</em> folder of the Scissors and Paste Database to see further examples of how to transform XML structured data.</p>\n<h3 id=\"exercise-solutions\">Exercise Solutions</h3>\n<h4 id=\"introduction-primary-source-reader\">Introduction (Primary Source Reader)</h4>\n<pre><code>&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;\n&lt;xsl:output method=&quot;html&quot;/&gt;\n&lt;xsl:template match=&quot;/&quot;&gt;\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;xsl:for-each select=&quot;root/record&quot;&gt;\n                &lt;xsl:if test=&quot;keywords/keyword = &#39;slave insurrections&#39;&quot;&gt;\n                    &lt;h2&gt;\n                        &lt;i&gt;&lt;xsl:value-of select=&quot;title&quot;/&gt;&lt;/i&gt;, &lt;xsl:value-of\n                            select=&quot;substring(date/@when, 9, 2)&quot;/&gt;\n                        &lt;xsl:text&gt;&amp;#32;&lt;/xsl:text&gt;\n                        &lt;xsl:if test=&quot;substring(date/@when, 6, 2) = &#39;01&#39;&quot;&gt;January&lt;/xsl:if&gt;\n                        &lt;xsl:if test=&quot;substring(date/@when, 6, 2) = &#39;02&#39;&quot;&gt;February&lt;/xsl:if&gt;\n                        &lt;xsl:if test=&quot;substring(date/@when, 6, 2) = &#39;03&#39;&quot;&gt;March&lt;/xsl:if&gt;\n                        &lt;xsl:if test=&quot;substring(date/@when, 6, 2) = &#39;04&#39;&quot;&gt;April&lt;/xsl:if&gt;\n                        &lt;xsl:if test=&quot;substring(date/@when, 6, 2) = &#39;05&#39;&quot;&gt;May&lt;/xsl:if&gt;\n                        &lt;xsl:if test=&quot;substring(date/@when, 6, 2) = &#39;06&#39;&quot;&gt;June&lt;/xsl:if&gt;\n                        &lt;xsl:if test=&quot;substring(date/@when, 6, 2) = &#39;07&#39;&quot;&gt;July&lt;/xsl:if&gt;\n                        &lt;xsl:if test=&quot;substring(date/@when, 6, 2) = &#39;08&#39;&quot;&gt;August&lt;/xsl:if&gt;\n                        &lt;xsl:if test=&quot;substring(date/@when, 6, 2) = &#39;09&#39;&quot;&gt;September&lt;/xsl:if&gt;\n                        &lt;xsl:if test=&quot;substring(date/@when, 6, 2) = &#39;10&#39;&quot;&gt;October&lt;/xsl:if&gt;\n                        &lt;xsl:if test=&quot;substring(date/@when, 6, 2) = &#39;11&#39;&quot;&gt;November&lt;/xsl:if&gt;\n                        &lt;xsl:if test=&quot;substring(date/@when, 6, 2) = &#39;12&#39;&quot;&gt;December&lt;/xsl:if&gt;\n                        &lt;xsl:text&gt;&amp;#32;&lt;/xsl:text&gt;\n                        &lt;xsl:value-of select=&quot;substring(date/@when, 1, 4)&quot;/&gt;\n                        &lt;xsl:text&gt;&amp;#xA;&amp;#xA;&lt;/xsl:text&gt;&lt;/h2&gt;\n                    &lt;xsl:for-each select=&quot;text/p&quot;&gt;\n                        &lt;p&gt;\n                            &lt;xsl:value-of select=&quot;.&quot;/&gt;\n                        &lt;/p&gt;\n                    &lt;/xsl:for-each&gt;\n                &lt;/xsl:if&gt;\n            &lt;/xsl:for-each&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n&lt;/xsl:template&gt;\n&lt;/xsl:stylesheet&gt;\n</code></pre>\n<h4 id=\"exercise-a-1\">Exercise A</h4>\n<pre><code>&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;\n    &lt;xsl:output method=&quot;text&quot;/&gt;\n    &lt;xsl:template match=&quot;/&quot;&gt;\n        &lt;xsl:for-each select=&quot;root/record&quot;&gt;\n            &lt;xsl:value-of select=&quot;id&quot; /&gt;, &lt;xsl:value-of select=&quot;title&quot; /&gt;, &lt;xsl:value-of select=&quot;date&quot; /&gt;&lt;xsl:text&gt;&amp;#xA;&lt;/xsl:text&gt;\n        &lt;/xsl:for-each&gt;\n    &lt;/xsl:template&gt;\n&lt;/xsl:stylesheet&gt;\n</code></pre>\n<h4 id=\"exercise-b-1\">Exercise B</h4>\n<pre><code>&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;\n    &lt;xsl:output method=&quot;text&quot;/&gt;\n    &lt;xsl:template match=&quot;/&quot;&gt;\n        &lt;xsl:for-each select=&quot;root/record&quot;&gt;\n            [&lt;xsl:value-of select=&quot;id&quot;/&gt;]\n            &lt;xsl:value-of select=&quot;text&quot;/&gt;\n        &lt;/xsl:for-each&gt;\n    &lt;/xsl:template&gt;\n&lt;/xsl:stylesheet&gt;\n</code></pre>\n<p>To remove the indentation of your text, you will need to take more direct control of your whitespace by using line-breaks before each ID number and paragraph, as seen below. In the second for-loop, we use <code>.</code> to refer to the <code>p</code> in <code>select=&quot;text/p&quot;</code>. Using <code>p</code> would be interpreted as <code>text/p/p</code>, which does not exist.</p>\n<pre><code>&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;\n    &lt;xsl:output method=&quot;text&quot;/&gt;\n    &lt;xsl:template match=&quot;/&quot;&gt;\n        &lt;xsl:for-each select=&quot;root/record&quot;&gt;&lt;xsl:text&gt;&amp;#xA;&lt;/xsl:text&gt;[&lt;xsl:value-of select=&quot;id&quot;/&gt;]&lt;xsl:text&gt;&amp;#xA;&lt;/xsl:text&gt;&lt;xsl:for-each select=&quot;text/p&quot;&gt;&lt;xsl:value-of select=&quot;.&quot;/&gt;&lt;xsl:text&gt;&amp;#xA;&lt;/xsl:text&gt;&lt;/xsl:for-each&gt;&lt;/xsl:for-each&gt;\n    &lt;/xsl:template&gt;\n&lt;/xsl:stylesheet&gt;\n</code></pre>\n<h4 id=\"exercise-c-1\">Exercise C</h4>\n<pre><code>&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;\n    &lt;xsl:output method=&quot;text&quot;/&gt;\n    &lt;xsl:template match=&quot;/&quot;&gt;\n        &lt;xsl:for-each select=&quot;root/record&quot;&gt;\n            &lt;xsl:text&gt;&amp;#xA;&lt;/xsl:text&gt;\n            &lt;xsl:value-of select=&quot;title&quot;/&gt;\n            &lt;xsl:text&gt;&amp;#32;&lt;/xsl:text&gt;\n            &lt;xsl:value-of select=&quot;date/@when&quot;/&gt;\n        &lt;/xsl:for-each&gt;\n    &lt;/xsl:template&gt;\n&lt;/xsl:stylesheet&gt;\n</code></pre>\n<p>You&#39;ll notice I used <code>&amp;#32;</code> in between my two values. This is the HEX code for a space. You could have also used a literal space, but this is may not render correctly in all cases. You could have also used a comma or any other divider.</p>\n<h4 id=\"exercise-d-1\">Exercise D</h4>\n<pre><code>&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;\n    &lt;xsl:output method=&quot;text&quot; /&gt;\n    &lt;xsl:template match=&quot;/&quot;&gt;\n        &lt;xsl:for-each select=&quot;root/record&quot;&gt;\n            &lt;xsl:sort select=&quot;date/@when&quot; order=&quot;ascending&quot; data-type=&quot;text&quot;/&gt;\n            &lt;xsl:for-each select=&quot;text/p&quot;&gt;\n                &lt;xsl:text&gt;&amp;#xA;&lt;/xsl:text&gt;&lt;xsl:value-of select=&quot;.&quot;/&gt;\n            &lt;/xsl:for-each&gt;\n            &lt;xsl:text&gt;&amp;#xA;&lt;/xsl:text&gt;\n        &lt;/xsl:for-each&gt;\n    &lt;/xsl:template&gt;\n&lt;/xsl:stylesheet&gt;\n</code></pre>\n<h4 id=\"exercise-e-1\">Exercise E</h4>\n<pre><code>&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;\n    &lt;xsl:output method=&quot;text&quot;/&gt;\n    &lt;xsl:template match=&quot;/&quot;&gt;\n        &lt;xsl:for-each select=&quot;root/record&quot;&gt;\n            &lt;xsl:sort select=&quot;date/@when&quot; order=&quot;descending&quot; data-type=&quot;text&quot;/&gt;\n            &lt;xsl:if test=&quot;date/year = &#39;1789&#39;&quot;&gt;\n                &lt;xsl:value-of select=&quot;id&quot;/&gt;, &lt;xsl:value-of select=&quot;title&quot;/&gt;, &lt;xsl:value-of select=&quot;date/@when&quot;/&gt;&lt;xsl:text&gt;&amp;#xA;&lt;/xsl:text&gt;\n            &lt;/xsl:if&gt;\n        &lt;/xsl:for-each&gt;\n    &lt;/xsl:template&gt;\n&lt;/xsl:stylesheet&gt;\n</code></pre>\n"}