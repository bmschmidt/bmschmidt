<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="description" content="" />
		<link rel="icon" href="/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		

		

		<link rel="stylesheet" href="/_app/assets/start-61d1577b.css">
		<link rel="modulepreload" href="/_app/start-c09d08cd.js">
		<link rel="modulepreload" href="/_app/chunks/vendor-9b9d6288.js">
		<link rel="modulepreload" href="/_app/pages/__layout.svelte-de46afb2.js">
		<link rel="modulepreload" href="/_app/pages/_lang_/__layout.svelte-e75718c6.js">
		<link rel="modulepreload" href="/_app/chunks/stores-191d1505.js">
		<link rel="modulepreload" href="/_app/pages/_lang_/_lessons_/_slug_/index.svelte-efe77d76.js">

		<script type="module">
			import { start } from "/_app/start-c09d08cd.js";
			start({
				target: document.querySelector("#svelte"),
				paths: {"base":"","assets":""},
				session: {},
				route: true,
				spa: false,
				trailing_slash: "never",
				hydrate: {
					status: 200,
					error: null,
					nodes: [
						import("/_app/pages/__layout.svelte-de46afb2.js"),
						import("/_app/pages/_lang_/__layout.svelte-e75718c6.js"),
						import("/_app/pages/_lang_/_lessons_/_slug_/index.svelte-efe77d76.js")
					],
					url: new URL("sveltekit://prerender/en/lessons/json-and-jq"),
					params: {lang:"en",lessons:"lessons",slug:"json-and-jq"}
				}
			});
		</script><script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('/service-worker.js');
			}
		</script>
	</head>
	<body>
		<div id="svelte">


The Programming Historian <a href="/en">English</a> <a href="/es">Spanish</a>
<br>
This is the en edition.

<h1>Reshaping JSON with jq</h1>

<!-- HTML_TAG_START --><p>{% include toc.html %}</p>
<h2 id="lesson-goals">Lesson goals</h2>
<p>JSON (JavaScript Object Notation) is a common data sharing format that can describe complex relationships.
Many libraries, archives, museums, and social media sites expose their data through JSON-based APIs.
(On accessing APIs, see <a href="/lessons/applied-archival-downloading-with-wget">downloading structured data with wget</a> and the <a href="/lessons/intro-to-the-zotero-api">series of lessons on working with APIs</a>.)</p>
<p>However, many tools for data analysis and visualization require input in flat tables (i.e. CSV), and because JSON is such a flexible data format, often with many nested levels of data, there is no one-size-fits-all graphical user interface for transforming JSON into other formats.</p>
<p>Working with data from an art museum API and from the Twitter API, this lesson teaches how to use the command-line utility <a href="https://stedolan.github.io/jq/">jq</a> to filter and parse complex JSON files into flat CSV files.
This lesson will begin with an overview of the basic operators of the jq query syntax.
Next, you will learn progressively more complex ways of connecting these operators together.
By the end of the lesson, you will understand how to combine basic operators to create queries that can reshape many types of JSON data.</p>
<h2 id="what-is-json">What is JSON?</h2>
<p><a href="http://www.json.org/">You may find a short and cogent primer on JSON here.</a>
In brief, a JSON <strong>object</strong> is a series of key/value pairs, where <strong>keys</strong> are the names for the <strong>values</strong> they are paired with.
For example, the tiny JSON object:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;Matthew&quot;,
  &quot;role&quot;: &quot;author&quot;
}
</code></pre>
<p>describes two data points: a name and a role.
Keys are separated from values with a colon (<code>:</code>), while key/value pairs are separated from each other by a comma (<code>,</code>).
These objects must be wrapped in curly braces. (<code>{}</code>)</p>
<p>Keys must be text strings (wrapped in double quotation marks: <code>&quot;&quot;</code>), while values may be quoted text; the unquoted words <code>true</code>, <code>false</code>, or <code>null</code>; an unquoted number; an <strong>array</strong> (multiple equivalent values within square brackets: <code>[]</code>); or another JSON object (wrapped in curly braces: <code>{}</code>)</p>
<p>Let&#39;s consider the JSON for <a href="https://www.rijksmuseum.nl/nl/collectie/SK-C-5">Rembrandt&#39;s <em>Nightwatch</em> in the Rijksmuseum</a>:</p>
<pre><code class="language-json">{
  &quot;links&quot;: {
    &quot;self&quot;: &quot;https://www.rijksmuseum.nl/api/nl/collection/SK-C-5&quot;,
    &quot;web&quot;: &quot;https://www.rijksmuseum.nl/nl/collectie/SK-C-5&quot;
  },
  &quot;id&quot;: &quot;nl-SK-C-5&quot;,
  &quot;objectNumber&quot;: &quot;SK-C-5&quot;,
  &quot;title&quot;: &quot;Schutters van wijk II onder leiding van kapitein Frans Banninck Cocq, bekend als de ‘Nachtwacht’&quot;,
  &quot;hasImage&quot;: true,
  &quot;principalOrFirstMaker&quot;: &quot;Rembrandt Harmensz. van Rijn&quot;,
  &quot;longTitle&quot;: &quot;Schutters van wijk II onder leiding van kapitein Frans Banninck Cocq, bekend als de ‘Nachtwacht’, Rembrandt Harmensz. van Rijn, 1642&quot;,
  &quot;showImage&quot;: true,
  &quot;permitDownload&quot;: true,
  &quot;webImage&quot;: {
    &quot;guid&quot;: &quot;3ae88fe0-021c-41ae-a4ce-cc70b7bc6295&quot;,
    &quot;offsetPercentageX&quot;: 50,
    &quot;offsetPercentageY&quot;: 100,
    &quot;width&quot;: 2500,
    &quot;height&quot;: 2034,
    &quot;url&quot;: &quot;http://lh6.ggpht.com/ZYWwML8mVFonXzbmg2rQBulNuCSr3rAaf5ppNcUc2Id8qXqudDL1NSYxaqjEXyDLSbeNFzOHRu0H7rbIws0Js4d7s_M=s0&quot;
  },
  &quot;headerImage&quot;: {
    &quot;guid&quot;: &quot;29a2a516-f1d2-4713-9cbd-7a4458026057&quot;,
    &quot;offsetPercentageX&quot;: 50,
    &quot;offsetPercentageY&quot;: 50,
    &quot;width&quot;: 1920,
    &quot;height&quot;: 460,
    &quot;url&quot;: &quot;http://lh3.ggpht.com/rvCc4t2BWHAgDlzyiPlp1sBhc8ju0aSsu2HxR8rN_ZVPBcujP94pukbmF3Blmhi-GW5cx1_YsYYCDMTPePocwM6d2vk=s0&quot;
  },
  &quot;productionPlaces&quot;: [
    &quot;Amsterdam&quot;
  ]
}
</code></pre>
<p>Takeaways:</p>
<ul>
<li>The entire text is wrapped in <code>{}</code>, identifying it as a JSON object.</li>
<li><code>id</code> is a key, separated by a colon from its value, <code>&quot;nl-SK-C-5&quot;</code></li>
<li>Some keys here have entire objects as their values. For example, <code>webImage</code> has an object with its own key:value pairs like <code>&quot;width&quot;: 2500</code> and <code>&quot;height&quot;: 2034</code>.</li>
<li>The key <code>productionPlaces</code> has an <em>array</em> as its value, denoted by the <code>[]</code> wrapping it.
In this object, the array only has one value, <code>&quot;Amsterdam&quot;</code>, however it could have multiple values, e.g. <code>[&quot;Amsterdam&quot;, &quot;Kloveniersdoelen&quot;]</code>.
Remember, values of an array have no keys - they are all considered to be semantically equivalent to each other.</li>
</ul>
<h2 id="lesson-setup">Lesson Setup</h2>
<p>For the bulk of this lesson, we will be working with a web-based version of jq at the site <a href="https://jqplay.org/">jq play</a>.
For this, you will only need your internet browser.
<a href="https://jqplay.org/">jq play</a> cannot handle very large JSON files, but it is a great sandbox for learning the query language for jq.
(At the end of this lesson, we will download and install the command-line version of jq, which you may use to speedily parse much larger JSON files.)</p>
<p>{% include figure.html filename=&quot;jqplay-screenshot.png&quot; caption=&quot;The jq play website, with input JSON, filter, and results.&quot; %}</p>
<p>We will type all queries into the &quot;Filter&quot; box in the upper-left corner of <a href="https://jqplay.org/">jq play</a>.
Some of the filter queries are long, so be sure to scroll all the way to the right when copying them.
The results will immediately display on the right-hand side, and update whenever you change the filter or the input JSON.
You do not need to press enter.
After each query in this lesson, I will include the first few lines of the expected results, so that you can check your work.
If you see an error displayed in the &quot;Results&quot; field of jq play, don&#39;t panic; just edit the query in the &quot;Filter&quot; field and jq play will re-run everything.</p>
<p>In some instances, we will interact with the checkboxes on the upper-right.
These set various jq <a href="https://stedolan.github.io/jq/manual/#Invokingjq">command-line options, or <em>flags</em></a>, that affect things like input handling, and the final formatting of the output.
<strong>Start the lesson with all of them unchecked.</strong></p>
<h2 id="core-jq-filters">Core jq filters</h2>
<p>jq operates by way of <em>filters</em>: a series of text commands that you can string together, and which dictate how jq should transform the JSON you give it.</p>
<p>To learn the basic jq filters, we&#39;ll work with a sample response from the Rijksmuseum API: <a href="/assets/jq_rkm.json">rkm.json</a>
Select all the text at that link, copy it, and paste it into the &quot;JSON&quot; box at <a href="https://jqplay.org/">jq play</a> on the left hand side.</p>
<h3 id="the-dot-">The dot: <code>.</code></h3>
<p>The basic jq operator is the dot: <code>.</code>
Used by itself, <code>.</code> leaves the input unmodified.
Add the name of a key to it, however, and the filter will return the value of that key.
Try the following filter:</p>
<pre><code class="language-txt">.count
</code></pre>
<p>This tells jq to return the value of the field <code>count</code>.
The result should read <code>359</code>.
If you want to access a value in an object that&#39;s already within another object, you can chain <code>.</code> filters together, e.g. <code>.links.self</code>.
<a href="#output-a-csv-csv">We will use this functionality later in the lesson.</a></p>
<p>Try the <code>.</code> operator again, this time accessing the field <code>artObjects</code>.</p>
<pre><code class="language-txt">.artObjects
</code></pre>
<p>The results:</p>
<pre><code class="language-json">[
  {
    &quot;links&quot;: {
      &quot;self&quot;: &quot;https://www.rijksmuseum.nl/api/nl/collection/SK-C-5&quot;,
      &quot;web&quot;: &quot;https://www.rijksmuseum.nl/nl/collectie/SK-C-5&quot;
    },
    &quot;id&quot;: &quot;nl-SK-C-5&quot;,
    &quot;objectNumber&quot;: &quot;SK-C-5&quot;,
    &quot;title&quot;: &quot;Schutters van wijk II onder leiding van kapitein Frans Banninck Cocq, bekend als de ‘Nachtwacht’&quot;,
    &quot;hasImage&quot;: true,
    &quot;principalOrFirstMaker&quot;: &quot;Rembrandt Harmensz. van Rijn&quot;,
    &quot;longTitle&quot;: &quot;Schutters van wijk II onder leiding van kapitein Frans Banninck Cocq, bekend als de ‘Nachtwacht’, Rembrandt Harmensz. van Rijn, 1642&quot;,
    &quot;showImage&quot;: true,
    &quot;permitDownload&quot;: true,
    &quot;webImage&quot;: {
      &quot;guid&quot;: &quot;3ae88fe0-021c-41ae-a4ce-cc70b7bc6295&quot;,
      &quot;offsetPercentageX&quot;: 50
      /*ETC...*/
    }
  }
]
</code></pre>
<p>Note that jq has returned the entire array.
Rather than being wrapped in <code>{}</code>, the result is a series of objects wrapped within an array (<code>[{},{},{}]</code>)
The significance of this will be discussed in the next section.</p>
<h3 id="the-array-operator-">The array operator: <code>[]</code></h3>
<p><code>.artObjects</code> returned one big array of JSON objects.
Before we can access the values inside those objects, we need to break them out of the array that they&#39;re in.
By adding <code>[]</code> onto the end of our filter, jq will break up this one array into 10 separate objects:</p>
<p>Try it:</p>
<pre><code class="language-txt">.artObjects[]
</code></pre>
<p>Notice that the <code>[]</code> wrapping our results are now gone.
To make clear what has happened, check the &quot;Compact Output&quot; checkbox in the upper right.
This removes the cosmetic line breaks in the results, returning one JSON object per line.
You should have a 10-line output now.</p>
<p>{% include figure.html filename=&quot;compact-output-multiple.png&quot; caption=&quot;jq&#39;s &#39;Compact Output&#39; option removes all cosmetic line breaks in a file, just leaving one JSON object per line.&quot; %}</p>
<p>Keeping &quot;Compact Output&quot; checked, remove the <code>[]</code> from the filter, so it just reads <code>.artObjects</code> again.
The results should now be just one line, as jq is now just returning one single JSON array:</p>
<p>{% include figure.html filename=&quot;compact-output-single.png&quot; caption=&quot;When jq returns just one JSON object, the &#39;Compact Output&#39; option will produce a one-line result.&quot; %}</p>
<p>If you want to access just the first (or the <em>n</em>-th) item in an array, put a digit in the <code>[]</code> operator:</p>
<pre><code class="language-txt">.artObjects[0]
</code></pre>
<p><strong>IMPORTANT: you access the first element of an array with <code>0</code>, not <code>1</code>.</strong>
This is because JavaScript, like quite a few other programming languages (<a href="http://stackoverflow.com/questions/3135325/why-do-vector-indices-in-r-start-with-1-instead-of-0">though not all!</a>), <a href="http://skillcrush.com/2013/01/17/why-programmers-start-counting-at-zero/">starts counting at 0</a>.</p>
<p>This filter returns just the first element of the <code>artObjects</code> array.
<code>.artObjects[1]</code> would return the second, and so on.</p>
<p>Uncheck the &quot;Compact Output&quot; box again before continuing with the lesson.</p>
<h3 id="the-pipe-">The pipe: <code>|</code></h3>
<p>The magic of jq is that you can connect, or <em>pipe</em>, several operators together to accomplish some very complex transformations of your data.
What&#39;s more, jq will repeat the filter for each JSON object provided by the previous step.
Therefore, while we started with just one big JSON object, <code>.artObjects[]</code> created 10 smaller JSON objects.
Any operator we put after the <code>|</code> will be repeated for each of these objects.</p>
<p>For example, try the following query:</p>
<pre><code class="language-txt">.artObjects[] | .id
</code></pre>
<p>This will return a list of every value at the key <code>id</code> within the <code>artObjects</code> array, separated by a line break.</p>
<h3 id="filter-select">Filter: <code>select()</code></h3>
<p>Normally jq repeats every filter operation for each line of input that it receives, passing each answer on to the following filter operation.
<code>select()</code> will only pass on a subset of the input onto the next step of the filter.</p>
<p>Let&#39;s filter the Rijksmuseum JSON to only return the ids of objects that have at least one value assigned to their <code>productionPlaces</code>:</p>
<pre><code class="language-txt">.artObjects[] | select(.productionPlaces | length &gt;= 1) | .id
</code></pre>
<p>This should return:</p>
<pre><code class="language-json">&quot;nl-SK-C-5&quot;
&quot;nl-SK-A-3924&quot;
</code></pre>
<p>Let&#39;s break down this query into its component pieces:</p>
<ol>
<li><code>.artObjects[] |</code> Breaks open the array of objects contained in the original Rijksmuseum JSON, just like we did in the previous step of this lesson. The <code>|</code> sends the results of this step along to the next command...</li>
<li><code>select(.productionPlaces | length &gt;= 1) |</code> The command <code>select(...)</code> will only pass along the JSON objects that match the rule defined inside the parentheses. Our rule has 3 parts:<ol>
<li><code>.productionPlaces</code> Access the array at the key named <code>productionPlaces</code></li>
<li><code>| length</code> The pipe (<code>|</code>) sends that array to the next command, <code>length</code>, which returns the number of elements in the array.</li>
<li><code>&gt;= 1</code> This last part of our rule checks whether the number returned by <code>length</code> is greater than or equal to 1. If it is <code>true</code>, then <code>select()</code> will pass the object along to the last part of our filter. If it is <code>false</code>, it will not pass it.</li>
</ol>
</li>
<li><code>.id</code> This final command accesses the value stored in the key <code>id</code> in the two objects that make it through the <code>select()</code> filter.</li>
</ol>
<p>jq can also filter based on regular expressions.
(To learn more about regular expressions, see the Programming Historian lesson <a href="/lessons/understanding-regular-expressions">&quot;Understanding Regular Expressions&quot;</a>.)
For example, let&#39;s select only those objects whose primary maker has the particle &quot;van&quot; in their name, and return the artist name and artwork id.
<code>test(&quot;van&quot;)</code> takes the value returned by the operator <code>.principalOrFirstMaker</code> and returns true if that value contains the string <code>van</code>:</p>
<pre><code class="language-txt">.artObjects[] | select(.principalOrFirstMaker | test(&quot;van&quot;)) | {id: .id, artist: .principalOrFirstMaker}
</code></pre>
<p>The results:</p>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;nl-SK-C-5&quot;,
  &quot;artist&quot;: &quot;Rembrandt Harmensz. van Rijn&quot;
}
{
  &quot;id&quot;: &quot;nl-SK-A-180&quot;,
  &quot;artist&quot;: &quot;Gerard van Honthorst&quot;
}
{
  &quot;id&quot;: &quot;nl-SK-A-2205&quot;,
  &quot;artist&quot;: &quot;Gerrit van Vucht&quot;
}
{
  &quot;id&quot;: &quot;nl-SK-A-1935&quot;,
  &quot;artist&quot;: &quot;Rembrandt Harmensz. van Rijn&quot;
}
{
  &quot;id&quot;: &quot;nl-SK-A-3246&quot;,
  &quot;artist&quot;: &quot;Adriaen van Ostade&quot;
}
</code></pre>
<p>To see other types of rules for <code>select()</code>, <a href="https://stedolan.github.io/jq/manual/#ConditionalsandComparisons">consult the full list of jq conditionals and comparisons.</a></p>
<h3 id="create-new-json--and-">Create new JSON: <code>[]</code> and <code>{}</code></h3>
<p>By wrapping <code>.</code> operators within either <code>[]</code> or <code>{}</code>, jq can synthesize new JSON arrays and objects.
This can be useful if you want to output a new JSON file.
As we will see below, this can also be a crucial intermediate step when reshaping complex JSON.</p>
<p>Create a new set of JSON objects with the following filter:</p>
<pre><code class="language-txt">.artObjects[] | {id: .id, title: .title}
</code></pre>
<p>When creating an object with <code>{}</code>, you specify the names of the keys with unquoted text, and then assign the values with regular jq filters.
The resulting set of JSON objects have just two keys: <code>id</code> and <code>title</code>:</p>
<pre><code class="language-json">{
  &quot;id&quot;: &quot;nl-SK-C-5&quot;,
  &quot;title&quot;: &quot;Schutters van wijk II onder leiding van kapitein Frans Banninck Cocq, bekend als de ‘Nachtwacht’&quot;
}
{
  &quot;id&quot;: &quot;nl-SK-A-1505&quot;,
  &quot;title&quot;: &quot;Een molen aan een poldervaart, bekend als ‘In de maand juli’&quot;
}
/*ETC...*/
</code></pre>
<p>We can also create arrays using <code>[]</code>:</p>
<pre><code class="language-txt">.artObjects[] | [.id, .title]
</code></pre>
<p>The results:</p>
<pre><code class="language-json">[
  &quot;nl-SK-C-5&quot;,
  &quot;Schutters van wijk II onder leiding van kapitein Frans Banninck Cocq, bekend als de ‘Nachtwacht’&quot;
]
[
  &quot;nl-SK-A-1505&quot;,
  &quot;Een molen aan een poldervaart, bekend als ‘In de maand juli’&quot;
]
/*ETC...*/
</code></pre>
<p>Unlike objects made using <code>{}</code>, arrays have no keys; they are just simple lists of values.
Creating simple arrays is crucial, however, for mapping our JSON into a CSV file.</p>
<h3 id="output-a-csv-csv">Output a CSV: <code>@csv</code></h3>
<p>To create a CSV table with jq we want to filter our input JSON into a series of arrays, with each array being a row of the CSV.</p>
<p>The previous filter gave us an array with the <code>id</code> and <code>title</code> keys of each painting.
Let&#39;s add the primary artist for each artwork as well:</p>
<pre><code class="language-txt">.artObjects[] | [.id, .title, .principalOrFirstMaker, .webImage.url]
</code></pre>
<p>The results:</p>
<pre><code class="language-json">[
  &quot;nl-SK-C-5&quot;,
  &quot;Schutters van wijk II onder leiding van kapitein Frans Banninck Cocq, bekend als de ‘Nachtwacht’&quot;,
  &quot;Rembrandt Harmensz. van Rijn&quot;,
  &quot;http://lh6.ggpht.com/ZYWwML8mVFonXzbmg2rQBulNuCSr3rAaf5ppNcUc2Id8qXqudDL1NSYxaqjEXyDLSbeNFzOHRu0H7rbIws0Js4d7s_M=s0&quot;
]
[
  &quot;nl-SK-A-1505&quot;,
  &quot;Een molen aan een poldervaart, bekend als ‘In de maand juli’&quot;,
  &quot;Paul Joseph Constantin Gabriël&quot;,
  &quot;http://lh4.ggpht.com/PkQr-nNqzn0OVXVd4-hdJ6PPdWZ6-DQ_74WfBT3MZIV4LNYA-q8LUrtReXNstuzl9k6gKWkaBwG-LcFZ7zWU9Ch92g=s0&quot;
]
/*ETC...*/
</code></pre>
<p>Note that, to access the url nested in the <code>webImage</code> object, we chained together <code>.webImage.url</code>.</p>
<p>To format this as CSV, add the operator <code>@csv</code> on the end with another pipe and check the &quot;Raw Output&quot; box in the upper right.
<code>@csv</code> properly joins the arrays with <code>,</code> and adds quotes where needed.
&quot;Raw Output&quot; tells jq that we want to produce a text file, rather than a new JSON file.</p>
<pre><code class="language-txt">.artObjects[] | [.id, .title, .principalOrFirstMaker, .webImage.url] | @csv
</code></pre>
<p>The results:</p>
<pre><code class="language-txt">&quot;nl-SK-C-5&quot;,&quot;Schutters van wijk II onder leiding van kapitein Frans Banninck Cocq, bekend als de ‘Nachtwacht’&quot;,&quot;Rembrandt Harmensz. van Rijn&quot;,&quot;http://lh6.ggpht.com/ZYWwML8mVFonXzbmg2rQBulNuCSr3rAaf5ppNcUc2Id8qXqudDL1NSYxaqjEXyDLSbeNFzOHRu0H7rbIws0Js4d7s_M=s0&quot;
&quot;nl-SK-A-1505&quot;,&quot;Een molen aan een poldervaart, bekend als ‘In de maand juli’&quot;,&quot;Paul Joseph Constantin Gabriël&quot;,&quot;http://lh4.ggpht.com/PkQr-nNqzn0OVXVd4-hdJ6PPdWZ6-DQ_74WfBT3MZIV4LNYA-q8LUrtReXNstuzl9k6gKWkaBwG-LcFZ7zWU9Ch92g=s0&quot;
...
</code></pre>
<p>This is a valid CSV file, which we could now import into an analysis program.</p>
<h2 id="advanced-operations">Advanced operations</h2>
<h3 id="json-vs-json-lines">JSON vs. JSON Lines</h3>
<p>You may encounter two different types of JSON files in the wild: files with one large JSON object, and so-called &quot;JSON lines&quot; files, which have multiple, separate JSON objects each on one single line, not wrapped by <code>[]</code>.</p>
<p>You will commonly find larger data dumps of JSON will come in a JSON lines format.
For example, the <a href="https://github.com/NYPL-publicdomain/data-and-utilities/tree/master/items">New York Public Library released their public domain collections in multiple JSON lines-formatted files</a>.
You&#39;ll note that the NYPL used the file extension <code>.ndjson</code>, but is is just one convention --- others use <code>.jsonl</code> or even just <code>.json</code>.
Because there is no standard for naming JSON vs. JSON lines files, the only way to check what type you are getting is to open the file in a text editor (or use <code>head</code> on the command line) to check if the file has one object per line, or is one big object (or a series of objects wrapped with <code>[]</code>) spread out over many lines.</p>
<p>jq will repeat your entire filter statement <em>per JSON object</em>.
This means that it will run your filter once on a file with a large JSON object, and run it <em>once per line</em> on a &quot;JSON lines&quot; file.</p>
<p>The Rijksmuseum example above is a single JSON object that contains many smaller sub-objects, each of which stands for an artwork in the collection.
We will now begin working with a set of Twitter JSON in the &quot;JSON lines&quot; format, transforming complex relationships into usable flat tables.</p>
<p>Data about tweets can be accessed via the <a href="https://dev.twitter.com/overview/api">Twitter API</a>, which returns JSON data.
One of the easiest ways to search and download Twitter data is using the excellent utility <a href="https://github.com/edsu/twarc">twarc</a>, which saves data as JSON lines.</p>
<p>For this lesson, we will use a small sample of 50 public tweets.
Clear the &quot;Filter&quot;, &quot;JSON&quot; and &quot;Result&quot; boxes on <a href="https://jqplay.org/">jq play</a>, and ensure all the checkboxes are unchecked.
<a href="/assets/jq_twitter.json">Then copy this sample Twitter data</a> into <a href="https://jqplay.org/">jq play</a>.</p>
<h3 id="one-to-many-relationships-tweet-hashtags">One-to-many relationships: Tweet hashtags</h3>
<p>Often you may wish to create a table that expresses a one-to-many relationship, such as a tweet and its hashtags.
A tweet will always have exactly one tweet ID, while it may have zero, one, or more hashtags.
There are a few ways to express this as a CSV table, but we will implement two common solutions here:</p>
<ol>
<li>One row per tweet, with multiple hashtags in the same cell</li>
<li>One row per hashtag/tweet combination (<a href="https://en.wikipedia.org/wiki/Wide_and_narrow_data">also known as &quot;long&quot; or &quot;narrow&quot; data</a>), with tweet IDs and hashtags repeated as necessary</li>
</ol>
<h4 id="one-row-per-tweet">One row per tweet</h4>
<p>Let&#39;s create a table with one column with a tweet ID, and a second column with all the hashtags in each tweet, separated by a semicolon: <code>;</code></p>
<p>This is a relatively complex query that will require a multi-step filter.
First, let&#39;s reduce the Twitter JSON to just ids and the objects describing the hashtags.
Paste this filter into <a href="https://jqplay.org/">jq play</a>:</p>
<pre><code class="language-txt">{id: .id, hashtags: .entities.hashtags}
</code></pre>
<p>The results:</p>
<pre><code class="language-json">{
  &quot;id&quot;: 501064141332029440,
  &quot;hashtags&quot;: [
    {
      &quot;indices&quot;: [
        41,
        50
      ],
      &quot;text&quot;: &quot;Ferguson&quot;
    }
  ]
}
{
  &quot;id&quot;: 501064171707170800,
  &quot;hashtags&quot;: [
    {
      &quot;indices&quot;: [
        139,
        140
      ],
      &quot;text&quot;: &quot;Ferguson&quot;
    }
  ]
}
/*ETC...*/
</code></pre>
<p>Note that we do not have to start this query by breaking apart an array like we did with the Rijskmuseum data.
This is because the Twitter data comes in the JSON lines format, with one separate JSON object per line in the file.
jq simply repeats the filter for each of these separate objects.
This has created a set of JSON objects (wrapped in <code>{}</code>) with an <code>id</code> key and a <code>hashtags</code> key.
The value of <code>hashtags</code> is the  array (wrapped in <code>[]</code>) from the original data, which may have 0 or more objects inside it.
Let&#39;s add a second query to preserve just the text of those hashtags:</p>
<pre><code class="language-txt">{id: .id, hashtags: .entities.hashtags} | {id: .id, hashtags: .hashtags[].text}
</code></pre>
<p>The results:</p>
<pre><code class="language-json">{
  &quot;id&quot;: 501064141332029440,
  &quot;hashtags&quot;: &quot;Ferguson&quot;
}
{
  &quot;id&quot;: 501064171707170800,
  &quot;hashtags&quot;: &quot;Ferguson&quot;
}
{
  &quot;id&quot;: 501064180468682750,
  &quot;hashtags&quot;: &quot;Ferguson&quot;
}
{
  &quot;id&quot;: 501064194309906400,
  &quot;hashtags&quot;: &quot;USNews&quot;
}
{
  &quot;id&quot;: 501064196931330050,
  &quot;hashtags&quot;: &quot;Ferguson&quot;
}
{
  &quot;id&quot;: 501064196931330050,
  &quot;hashtags&quot;: &quot;MikeBrown&quot;
}
/*ETC...*/
</code></pre>
<p><code>id: .id</code> just keeps the <code>id</code> field unchanged.
The <code>[]</code> in <code>.hashtags[].text</code> breaks open the array of hashtags in each tweet, allowing us to extract the value of the <code>text</code> key from each one.
Note, however, that tweet ID <code>501064196931330050</code> shows up twice in the results, because it had 2 hashtags: <code>Ferguson</code> and <code>MikeBrown</code>.
We want the tweet ID to only show up once, with an array of hashtags.
To do this, let&#39;s edit our filter by adding another set of <code>[]</code>, this time wrapping around <code>.hashtags[].text</code>:</p>
<pre><code class="language-txt">{id: .id, hashtags: .entities.hashtags} | {id: .id, hashtags: [.hashtags[].text]}
</code></pre>
<p>By adding <code>[]</code> around <code>.hashtags[].text</code>, we tell jq to collect the individual results of <code>.hashtags[].text</code> within an array.
If it finds multiple results, it will put them together in the same array.
Note that tweet ID <code>501064196931330050</code> now has just one object, with an embedded array of two hashtags:</p>
<pre><code class="language-json">/* ... */
{
  &quot;id&quot;: 501064196931330050,
  &quot;hashtags&quot;: [
    &quot;Ferguson&quot;,
    &quot;MikeBrown&quot;
  ]
}
/*ETC...*/
</code></pre>
<p>Finally, we want to express this as a CSV file, delimiting the hashtags with <code>;</code>.
To do this, we need to add one more intermediary JSON object:</p>
<pre><code class="language-txt">{id: .id, hashtags: .entities.hashtags} | {id: .id, hashtags: [.hashtags[].text]} | {id: .id, hashtags: .hashtags | join(&quot;;&quot;)}
</code></pre>
<p>Once again, we use <code>id: .id</code> to preserve the <code>id</code> value unchanged.
However, we change the value of <code>hashtags</code> one last time.
<code>.hashtags | join(&quot;;&quot;)</code> uses the <a href="https://stedolan.github.io/jq/manual/#join(str)"><code>join()</code></a> command, which takes an array as input and joins the elements together using the provided string (in this case, <code>&quot;;&quot;</code>):</p>
<pre><code class="language-json">{
  &quot;id&quot;: 501064141332029440,
  &quot;hashtags&quot;: &quot;Ferguson&quot;
}
{
  &quot;id&quot;: 501064171707170800,
  &quot;hashtags&quot;: &quot;Ferguson&quot;
}
{
  &quot;id&quot;: 501064180468682750,
  &quot;hashtags&quot;: &quot;Ferguson&quot;
}
{
  &quot;id&quot;: 501064188211765250,
  &quot;hashtags&quot;: &quot;&quot;
}
{
  &quot;id&quot;: 501064194309906400,
  &quot;hashtags&quot;: &quot;USNews&quot;
}
{
  &quot;id&quot;: 501064196931330050,
  &quot;hashtags&quot;: &quot;Ferguson;MikeBrown&quot;
}
/*ETC...*/
</code></pre>
<p>Now, we can finally format the individual rows of the CSV and output it (remember to check the &quot;Raw Output&quot; box):</p>
<pre><code class="language-txt">{id: .id, hashtags: .entities.hashtags} | {id: .id, hashtags: [.hashtags[].text]} | {id: .id, hashtags: .hashtags | join(&quot;;&quot;)} | [.id, .hashtags] | @csv
</code></pre>
<p>This is a very complex, multipart query.
Let&#39;s review its components one more time:</p>
<ol>
<li><code>{id: .id, hashtags: .entities.hashtags} |</code> Create a new set of JSON objects by extracting the <code>id</code> field from each tweet, along with the JSON object describing the tweet&#39;s hashtags.</li>
<li><code>{id: .id, hashtags: [.hashtags[].text]} |</code> Preserve the <code>id</code> key:value pair, and collect the <code>text</code> of each <code>hashtags</code> object in an array, which we reassign to the key <code>hashtags</code>.</li>
<li><code>{id: .id, hashtags: .hashtags | join(&quot;;&quot;)} |</code> Preserve the <code>id</code> key:value pair, and join the contents of the <code>hashtags</code> array together, separated by <code>;</code></li>
<li><code>[.id, .hashtags] |</code> Build an array for each row of our desired table</li>
<li><code>@csv</code> Format everything as a CSV</li>
</ol>
<p>The final results:</p>
<pre><code class="language-txt">501064141332029440,&quot;Ferguson&quot;
501064171707170800,&quot;Ferguson&quot;
501064180468682750,&quot;Ferguson&quot;
501064188211765250,&quot;&quot;
501064194309906400,&quot;USNews&quot;
501064196931330050,&quot;Ferguson;MikeBrown&quot;
501064197396914200,&quot;&quot;
501064197632167940,&quot;Ferguson;tcot;uniteblue;teaparty;gop&quot;
...
</code></pre>
<p>There are ways to get the same results using an even shorter query, but in most cases, it pays to break up your jq transformations into small steps.</p>
<h4 id="one-row-per-hashtag">One row per hashtag</h4>
<p>This is actually simpler to implement in jq, because we can take advantage of jq&#39;s natural behavior of repeating filters.</p>
<p>We will start with the same set of operations that extract the tweet ID and the hashtag objects from the original Twitter JSON:</p>
<pre><code class="language-txt">{id: .id, hashtags: .entities.hashtags} | {id: .id, hashtags: .hashtags[].text}
</code></pre>
<p>This results in a long series of JSON objects with one id and one hashtag per object.
All we need to do is construct the CSV row arrays and pipe them through the <code>@csv</code> operator:</p>
<pre><code class="language-txt">{id: .id, hashtags: .entities.hashtags} | {id: .id, hashtag: .hashtags[].text} | [.id, .hashtag] | @csv
</code></pre>
<p>The results:</p>
<pre><code class="language-txt">501064141332029440,&quot;Ferguson&quot;
501064171707170800,&quot;Ferguson&quot;
501064180468682750,&quot;Ferguson&quot;
501064194309906400,&quot;USNews&quot;
501064196931330050,&quot;Ferguson&quot;
501064196931330050,&quot;MikeBrown&quot;
...
</code></pre>
<h3 id="grouping-and-counting">Grouping and Counting</h3>
<p>Often times, your JSON will be structured around one type of entity (say, artworks from the Rijksmuseum API, or tweets from the Twitter API) when you, the researcher, may be more interested in collecting information about a related, but secondary entity, like an artist, a Twitter hashtag, or a Twitter user.
In this section, we will use jq to extract a table of information about Twitter <em>users</em> from the tweet-based JSON, as well as grouping and counting tweet <em>hashtags</em>.</p>
<p>For the previous examples, we have only needed to consider each tweet individually.
By default, jq will look at one JSON object at a time when parsing a file; consequently, it can <em>stream</em> very large files without having to load the entire set in to memory.</p>
<p>However, in cases where we are aggregating information about the individual objects in a JSON file, we need to give jq access to every JSON object in a file simultaneously.
This is where we want to use &quot;Slurp&quot; (or the <code>-s</code> flag on command-line jq).
&quot;Slurp&quot; tells jq to read every line of the input JSON lines and treat the entire group as one huge array of objects.</p>
<p>With the Twitter data still in the input box on <a href="https://jqplay.org/">jq play</a>, check the &quot;Slurp&quot; box, and just put <code>.</code> in the filter.
Note that it&#39;s wrapped the objects in <code>[]</code>.
Now we can build even more complex commands that require knowledge of the entire input file.</p>
<h4 id="extracting-user-data">Extracting user data</h4>
<p>Because the Twitter API returns per-tweet information, info about the <em>users</em> who send those tweets is repeated with each tweet within an object assigned to the key <code>user</code>.
Let&#39;s look at the user data in the very first tweet in this dataset (remember to keep the &quot;Slurp&quot; option checked.)</p>
<pre><code class="language-txt">.[0].user
</code></pre>
<p>The <code>[0]</code> operator accesses the very first tweet in the data, while <code>.user</code> extracts the embedded information in the user field.
The results will look like this:</p>
<pre><code class="language-json">{
  &quot;follow_request_sent&quot;: false,
  &quot;has_extended_profile&quot;: false,
  &quot;profile_use_background_image&quot;: true,
  &quot;default_profile_image&quot;: false,
  &quot;id&quot;: 851336634,
  &quot;profile_background_image_url_https&quot;: &quot;https://pbs.twimg.com/profile_background_images/834791998/376566559c7f84a79248efd7a1b4b686.jpeg&quot;,
  &quot;verified&quot;: true
  /* ETC... */
}
</code></pre>
<p>To collect information about users, we will want to use the <code>group_by()</code>
<code>group_by(.key)</code> takes an array of objects as its input, and returns an array of arrays, with those sub-arrays filled with objects that share the same value for the specified <code>key</code>.
Because we have read the input JSON lines using the &quot;Slurp&quot; option, we already start with an array of tweet objects.
We can use <code>group_by(.user)</code> to collect these tweets into sub-arrays of one user each.</p>
<pre><code class="language-txt">group_by(.user)
</code></pre>
<p>You should see that the results are now wrapped within an additional pair of <code>[]</code>:</p>
<pre><code class="language-json">[
  [
    {
    &quot;contributors&quot;: null,
      &quot;truncated&quot;: false,
      &quot;text&quot;: &quot;RT @agabriew: -mamá, ¿puedo salir?\n-no.\n-pero todos mis amigos irán.\n-¡no! http://t.co/Z9l3zEdUdH&quot;
      /* ETC ... */
    }
  ]
  /* More sub-arrays of tweets grouped by user... */
]
</code></pre>
<p>We can now create a table of users.
Let&#39;s create a table with columns for the user id, user name, followers count, and a column of their tweet ids separated by a semicolon.</p>
<pre><code class="language-txt">group_by(.user) | .[] | {user_id: .[0].user.id, user_name: .[0].user.screen_name, user_followers: .[0].user.followers_count, tweet_ids: [.[].id | tostring] | join(&quot;;&quot;)}
</code></pre>
<p>The results should look like:</p>
<pre><code class="language-json">{
  &quot;user_id&quot;: 1330235048,
  &quot;user_name&quot;: &quot;yourborwhore&quot;,
  &quot;user_followers&quot;: 1725,
  &quot;tweet_ids&quot;: &quot;619172326886674400&quot;
}
{
  &quot;user_id&quot;: 32537879,
  &quot;user_name&quot;: &quot;WonderWomanMind&quot;,
  &quot;user_followers&quot;: 199,
  &quot;tweet_ids&quot;: &quot;501064215990648800&quot;
}
{
  &quot;user_id&quot;: 558774130,
  &quot;user_name&quot;: &quot;Katyria90&quot;,
  &quot;user_followers&quot;: 202,
  &quot;tweet_ids&quot;: &quot;501064201256071200&quot;
}
/* ETC ... */
</code></pre>
<p>Let&#39;s break down this complex filter:</p>
<ol>
<li><code>group_by(.user) |</code> This takes the big array of tweets and returns an array of sub-arrays, each sharing the exact same information in the <code>user</code> key. Note that this works even when the value at the <code>user</code> key is itself a JSON object wrapped in <code>{}</code>.</li>
<li><code>.[] |</code> Having created an array of sub-arrays, we want to break out the individual sub-arrays.</li>
<li><code>{user_id: .[0].user.id, user_name: .[0].user.screen_name, user_followers: .[0].user.followers_count, tweet_ids: [.[].id | tostring] | join(&quot;;&quot;)}</code> This next bit creates a new set of JSON information, filling in keys and values with the following sub-commands:<ol>
<li><code>user_id: .[0].user.id,</code> This pulls the first tweet in the sub-array and access the user id, assigning it to the key <code>user_id</code> in our new JSON object</li>
<li><code>user_name: .[0].user.screen_name,</code> This does the same for the user name.</li>
<li><code>user_followers: .[0].user.followers_count,</code> This does the same for the number of followers the user has.</li>
<li><code>tweet_ids: [.[].id | tostring] | join(&quot;;&quot;)</code> This command collects all the different tweet ids associated with this user and sticks them into one string, delimited with <code>;</code>. How do we do that?<ol>
<li><code>.[].id</code> While we know that the user id, name, and followers will be the same for every tweet the user makes, the tweet ids will be unique, so instead of using <code>.[0]</code> to get values from just the first tweet, we use <code>.[].id</code> here to get the ids of every single tweet in a user&#39;s sub-array.</li>
<li>The command <code>| tostring</code> converts the tweet id numbers into strings that jq can then paste together with semicolons. <a href="#one-row-per-tweet">We didn&#39;t have to use this last time we used <code>join()</code> to create a column of semicolon-delimited hashtags.</a> Why? Because when we were making a column of hashtags, the original values were already text values wrapped in quotation marks. Tweet ids, on the other hand, are integers that are not wrapped in <code>&quot;&quot;</code>, Because jq can be very picky about data types, we need to convert our integers into strings before using the <code>join()</code> command in the next step.</li>
<li>Both of these commands are wrapped in <code>[]</code> which tells jq to collect every result into one single array, which is passed with a <code>|</code> along to:</li>
<li><code>join(&quot;;&quot;)</code>, which turns that array into one single character string, with semicolon delimiters between multiple tweet ids.</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>This filter created new JSON.
To produce a CSV table from this, we just need to add an array construction and the <code>@csv</code> command at the end of this filter.
You should recognize the way that we combine array construction and <code>@csv</code> <a href="#output-a-csv-csv">from the earlier example of using <code>@csv</code></a>.
Don&#39;t forget to check both the &quot;Slurp&quot; and &quot;Raw Output&quot; options when creating a CSV table with jq:</p>
<pre><code class="language-txt">group_by(.user) | .[] | {user_id: .[0].user.id, user_name: .[0].user.screen_name, user_followers: .[0].user.followers_count, tweet_ids: [.[].id | tostring] | join(&quot;;&quot;)} | [.user_id, .user_name, .user_followers, .tweet_ids] | @csv
</code></pre>
<p>The results should start like this:</p>
<pre><code class="language-txt">1330235048,&quot;yourborwhore&quot;,1725,&quot;619172326886674400&quot;
32537879,&quot;WonderWomanMind&quot;,199,&quot;501064215990648800&quot;
558774130,&quot;Katyria90&quot;,202,&quot;501064201256071200&quot;
2944164937,&quot;mirogeorgiev97&quot;,946,&quot;619172162608463900&quot;
100951936,&quot;elbshari_abdo&quot;,114,&quot;619172278086070300&quot;
...
</code></pre>
<p>Although this table happens to start with users who only have one tweet each in these sample data, you can scroll down through the results to find several users who made multiple tweets.</p>
<h4 id="counting-twitter-hashtags">Counting Twitter hashtags</h4>
<p>In the previous example we combined <code>group_by()</code> with <code>join()</code> to collect multiple values into a text field.
However, we can also use <code>group_by()</code> in conjunction with <code>length</code> to compute new values.
In this final exercise, we will use jq to count the number of times unique hashtags appear in this dataset.</p>
<p>Once again, make sure that the &quot;Slurp&quot; option is checked.
(However, uncheck the &quot;Raw Output&quot; option until we are ready to actually produce the final CSV output.)
Counterintuitively, the first thing we need to do to access the hashtags again is to break them <em>out</em> of that large array:</p>
<pre><code class="language-txt">.[] | {id: .id, hashtag: .entities.hashtags} | {id: .id, hashtag: .hashtag[].text}
</code></pre>
<p>Adding <code>.[]</code> at the beginning splits apart the large array created by the &quot;Slurp&quot; option.
This is necessary because, while tweets can only have one user, they can have multiple hashtags.
Thus, we need to fully break out all the possible hashtag values per tweet, and then collect that entire output back into an array inside <code>[]</code>, so that we can pass a single array into the <code>group_by()</code> function:</p>
<pre><code class="language-txt">[.[] | {id: .id, hashtag: .entities.hashtags} | {id: .id, hashtag: .hashtag[].text}] | group_by(.hashtag)
</code></pre>
<p>Note the change at the start of the filter: the first two components are now wrapped in <code>[]</code>.
We did a similar sort of wrapping in the previous section of this lesson.
We also added the <code>group_by(.hashtag)</code> command at the end of the filter.
The results:</p>
<pre><code class="language-json">[
  [
    {
      &quot;id&quot;: 619172232120692700,
      &quot;hashtag&quot;: &quot;Acquisition&quot;
    }
  ],
  [
    {
      &quot;id&quot;: 501064204288540700,
      &quot;hashtag&quot;: &quot;BLACKMEDIA&quot;
    }
  ],
  [
    {
      &quot;id&quot;: 619172293680345100,
      &quot;hashtag&quot;: &quot;BreakingNew&quot;
    }
  ]
  /*ETC...*/
]
</code></pre>
<p>In the above query, tweet/hashtag pairs are grouped in to arrays based on the value of their <code>hashtag</code> key.
To count the number of times each hashtag is used, we only have to count the size of each of these sub-arrays.</p>
<pre><code class="language-txt">[.[] | {id: .id, hashtag: .entities.hashtags} | {id: .id, hashtag: .hashtag[].text}] | group_by(.hashtag) | .[] | {tag: .[0].hashtag, count: . | length} | [.tag, .count] | @csv
</code></pre>
<p>The results:</p>
<pre><code class="language-txt">&quot;Acquisition&quot;,1
&quot;BLACKMEDIA&quot;,1
&quot;BreakingNew&quot;,1
&quot;CrimeButNoTime&quot;,1
&quot;Farrakhan&quot;,1
&quot;Ferguson&quot;,53
&quot;FergusonShooting&quot;,1
&quot;ForFreedom&quot;,1
&quot;FreeAmirNow&quot;,3
&quot;HandsUpDontShoot&quot;,1
/*ETC...*/
</code></pre>
<p>(Remember, to format CSV output correctly, set jq to &quot;Raw Output&quot; using the <code>-r</code> flag on the command line, or check the &quot;Raw Output&quot; box on <a href="https://jqplay.org/">jq play</a>.)</p>
<p><code>.[]</code> once again breaks apart the large array, so we are left only with the sub-arrays within.
We need to retrieve two pieces of information: first, the name of the hashtag for each sub-array, which we can get by accessing the value of the <code>hashtag</code> key in the first tweet/hashtag combo of the array (accessed with <code>.[0]</code>).
Second, we need to get the length of the array, accessed with <code>. | length</code>.
Finally, we create the CSV and format the CSV rows.</p>
<p>To review:</p>
<ol>
<li><code>[.[] | {id: .id, hashtag: .entities.hashtags} | {id: .id, hashtag: .hashtag[].text}] |</code> This nested filter :<ol>
<li>breaks out individual tweet objects from the large array created by the &quot;Slurp&quot; option (<code>.[]</code>)</li>
<li>retrieves the tweet id and hashtag text (<code>{id: .id, hashtag: .entities.hashtags} | {id: .id, hashtag: .hashtag[].text}</code>)</li>
<li>Wraps both of those filters in <code>[]</code> in order to collect the results in one large array again.</li>
</ol>
</li>
<li><code>group_by(.hashtag) |</code> Takes the large array from the previous step and sorts it into an array of arrays, each sub-array containing tweet objects sharing the same hashtag.</li>
<li><code>.[] |</code> Break the large array produced by <code>group_by()</code> into its component sub-arrays.</li>
<li><code>{tag: .[0].hashtag, count: . | length} |</code> Get the hashtag representing each sub-array by checking the hashtag value of the first member of each sub-array, and then count the size of each sub-array, effectively counting the number of tweets in which that hashtag was used.</li>
<li><code>[.tag, .count] |</code> Create simple arrays with just the tag name and count</li>
<li><code>@csv</code> Format each array as a CSV row</li>
</ol>
<h3 id="challenges">Challenges</h3>
<p>These final challenges will help you test your understanding of how to pipe together <a href="https://stedolan.github.io/jq/">jq</a> commands on your own.</p>
<h4 id="filter-before-counting">Filter before counting</h4>
<p>What function do we need to add to the hashtag-counting filter to only count hashtags when their tweet has been retweeted at least 200 times?
Hint: the retweet count is saved under the key <code>retweet_count</code>.</p>
<p>You should get the following table:</p>
<pre><code class="language-txt">&quot;CrimeButNoTime&quot;,1
&quot;Ferguson&quot;,14
&quot;FergusonShooting&quot;,1
&quot;MikeBrown&quot;,1
&quot;OpFerguson&quot;,1
&quot;RIPMikeBrown&quot;,1
&quot;justiceformikebrown&quot;,1
&quot;stl&quot;,1
&quot;vancouver&quot;,1
&quot;whiteprivilege&quot;,1
</code></pre>
<p><a href="/assets/filter_retweets.txt">There are multiple ways to solve this with jq. See my answer here.</a></p>
<h4 id="count-total-retweets-per-user">Count total retweets per user</h4>
<p>One more challenge to test your mastery of jq: from this dataset, try to compute the total number of times each user has had their tweets (at least within this dataset) retweeted.</p>
<p>Hints:</p>
<ul>
<li>You should have a table with two columns: one for user id, and one for the total number of retweets. There should only be one row per user id.</li>
<li>Since we are looking at per-user statistics that cut accross individual tweets, we&#39;ll need to use <code>group_by()</code> and the &quot;Slurp&quot; option.</li>
<li>We&#39;ve used a few functions that reduce an array of multiple values into one value: <code>length</code> counts the number of values in an array, and <code>join()</code> pastes those values together in one string. If you want to <em>add</em> numeric values together, though, <code>add</code> could be a promising function to try...</li>
</ul>
<p>As a way to verify your results, user <code>356854246</code> should have a total retweet count of <code>51</code> based on this dataset.</p>
<p><a href="/assets/count_retweets.txt">See my answer.</a></p>
<h2 id="using-jq-on-the-command-line">Using jq on the command line</h2>
<p><a href="https://jqplay.org/">jq play</a> is fine when you have under 100-200 lines of JSON to parse.
However, it will become unusably slow on  much larger files.
For fast processing of very large files, or of JSON lines spread across multiple files, you will need to run the command-line version of jq.</p>
<h2 id="installation">Installation</h2>
<h3 id="installation-on-os-x">Installation on OS X</h3>
<p>The easiest way to install jq on OS X is to use the package management system <a href="http://brew.sh/">Homebrew</a>.
This system works via OS X&#39;s &quot;Terminal&quot; application, which gives you access to the Bash command line.
<a href="/lessons/intro-to-bash">For an introduction to this system, see The Programming Historian&#39;s &quot;Introduction to the Bash Command Line&quot;.</a></p>
<p>Follow the installation instructions for Homebrew itself, and then use this command to install jq:</p>
<pre><code class="language-sh">brew install jq
</code></pre>
<h3 id="installation-on-windows">Installation on Windows</h3>
<p>To access the command line easily on Windows, you will need the PowerShell application.
<a href="/lessons/intro-to-powershell.html">See the Programming Historian&#39;s &quot;Introduction to PowerShell&quot;</a></p>
<p>From PowerShell, you can install the Windows package manager <a href="https://chocolatey.org/install">Chocolatey</a>, and then install jq with the following command:</p>
<pre><code class="language-sh">chocolatey install jq
</code></pre>
<h3 id="invoking-jq">Invoking jq</h3>
<pre><code class="language-sh">jq -r &#39;.artObjects[] | [.id, .title, .principalOrFirstMaker, .webImage.url] | @csv&#39; jq_rkm.json &gt; jq_rkm.csv
</code></pre>
<ol>
<li><code>jq</code> calls the jq program.</li>
<li><code>-r</code> sets the &quot;Raw Output&quot; option.</li>
<li>The actual filter text is placed between <code>&#39;&#39;</code> quotes.</li>
<li><code>jq_rkm.json</code> indicates that jq should read JSON from the file <code>jq_rkm.json</code>.</li>
<li><code>&gt; jq_rkm.csv</code> tells the command line to write jq&#39;s output into a file named <code>jq_rkm.csv</code>.</li>
</ol>
<p>Alternatively, you can use bash pipes to send text from the output of one function into jq.
This can be useful when downloading JSON with a utility like <code>wget</code> for retrieving online material.
(See <a href="/lessons/automated-downloading-with-wget">Automated Downloading with Wget</a> to learn the basics of this other command line program.)</p>
<pre><code class="language-sh">wget -qO- http://programminghistorian.org/assets/jq_rkm.json | jq -r &#39;.artObjects[] | [.id, .title, .principalOrFirstMaker, .webImage.url] | @csv&#39;
</code></pre>
<p>Note that you must use the <code>wget</code> flag <code>-qO-</code> in order to send the output of <code>wget</code> into <code>jq</code> by way of a shell pipe.
You can read more about command line pipes in <a href="/lessons/intro-to-bash">&quot;Introduction to the Bash Command Line&quot;</a> (OS X) or <a href="/lessons/intro-to-powershell.html">&quot;Introduction to PowerShell&quot;</a> (Windows).</p>
<h2 id="further-resources">Further Resources</h2>
<p>jq is incredibly powerful, but its advanced features can get quite complicated.</p>
<p>It is possible to do <a href="https://stedolan.github.io/jq/manual/#Math">other basic math functions in jq</a>, however given the complexity of working with JSON&#39;s tree data model, I would suggest that it is only worth doing the most basic counting operations in jq.
If basic counting is all you need to do with your JSON data, then jq can help you avoid adding another tool onto your data analysis pipeline.
For more involved math, however, it would be more sensible to create table(s) with jq and then continue your analysis in Python, R, or even Excel.</p>
<p>If you are working with deeply-nested JSON (that is, many objects within objects), or JSON where objects have inconsistent structure, you may need to use features not covered in this lesson, including <a href="https://stedolan.github.io/jq/manual/#if-then-else">if-then-else statements</a>, <a href="https://stedolan.github.io/jq/manual/#Recursion">recursion</a>, and <a href="https://stedolan.github.io/jq/manual/#Reduce">reduction</a>.
If you can&#39;t figure out the filter you need to go from your given input to your desired output, using the tag <code>jq</code> over at <a href="http://stackoverflow.com/questions/tagged/jq">StackOverflow</a> can often get you a speedy answer.
Make sure that you try to <a href="http://stackoverflow.com/help/how-to-ask">follow best practices when describing your problem</a> and provide a <a href="http://stackoverflow.com/help/mcve">reproducible example</a>.</p>
<!-- HTML_TAG_END -->

<script type="application/json" data-type="svelte-data" data-url="json-and-jq/raw.json">{"status":200,"statusText":"","headers":{"content-type":"application/json; charset=utf-8"},"body":"{\"metadata\":{\"title\":\"Reshaping JSON with jq\",\"layout\":\"lesson\",\"date\":\"2016-05-24T00:00:00.000Z\",\"authors\":[\"Matthew Lincoln\"],\"reviewers\":[\"Shawn Graham\",\"Nick Ruest\"],\"editors\":[\"Ian Milligan\"],\"difficulty\":2,\"review-ticket\":\"https:\u002F\u002Fgithub.com\u002Fprogramminghistorian\u002Fph-submissions\u002Fissues\u002F23\",\"activity\":\"transforming\",\"topics\":[\"data-manipulation\"],\"abstract\":\"Working with data from an art museum API and from the Twitter API, this lesson teaches how to use the command-line utility _jq_ to filter and parse complex JSON files into flat CSV files.\",\"redirect_from\":\"\u002Flessons\u002Fjson-and-jq\",\"avatar_alt\":\"A grid-like device for drawing lines\",\"doi\":\"10.46430\u002Fphen0055\"},\"html_body\":\"\u003Cp\u003E{% include toc.html %}\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"lesson-goals\\\"\u003ELesson goals\u003C\u002Fh2\u003E\\n\u003Cp\u003EJSON (JavaScript Object Notation) is a common data sharing format that can describe complex relationships.\\nMany libraries, archives, museums, and social media sites expose their data through JSON-based APIs.\\n(On accessing APIs, see \u003Ca href=\\\"\u002Flessons\u002Fapplied-archival-downloading-with-wget\\\"\u003Edownloading structured data with wget\u003C\u002Fa\u003E and the \u003Ca href=\\\"\u002Flessons\u002Fintro-to-the-zotero-api\\\"\u003Eseries of lessons on working with APIs\u003C\u002Fa\u003E.)\u003C\u002Fp\u003E\\n\u003Cp\u003EHowever, many tools for data analysis and visualization require input in flat tables (i.e. CSV), and because JSON is such a flexible data format, often with many nested levels of data, there is no one-size-fits-all graphical user interface for transforming JSON into other formats.\u003C\u002Fp\u003E\\n\u003Cp\u003EWorking with data from an art museum API and from the Twitter API, this lesson teaches how to use the command-line utility \u003Ca href=\\\"https:\u002F\u002Fstedolan.github.io\u002Fjq\u002F\\\"\u003Ejq\u003C\u002Fa\u003E to filter and parse complex JSON files into flat CSV files.\\nThis lesson will begin with an overview of the basic operators of the jq query syntax.\\nNext, you will learn progressively more complex ways of connecting these operators together.\\nBy the end of the lesson, you will understand how to combine basic operators to create queries that can reshape many types of JSON data.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"what-is-json\\\"\u003EWhat is JSON?\u003C\u002Fh2\u003E\\n\u003Cp\u003E\u003Ca href=\\\"http:\u002F\u002Fwww.json.org\u002F\\\"\u003EYou may find a short and cogent primer on JSON here.\u003C\u002Fa\u003E\\nIn brief, a JSON \u003Cstrong\u003Eobject\u003C\u002Fstrong\u003E is a series of key\u002Fvalue pairs, where \u003Cstrong\u003Ekeys\u003C\u002Fstrong\u003E are the names for the \u003Cstrong\u003Evalues\u003C\u002Fstrong\u003E they are paired with.\\nFor example, the tiny JSON object:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-json\\\"\u003E{\\n  &quot;name&quot;: &quot;Matthew&quot;,\\n  &quot;role&quot;: &quot;author&quot;\\n}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003Edescribes two data points: a name and a role.\\nKeys are separated from values with a colon (\u003Ccode\u003E:\u003C\u002Fcode\u003E), while key\u002Fvalue pairs are separated from each other by a comma (\u003Ccode\u003E,\u003C\u002Fcode\u003E).\\nThese objects must be wrapped in curly braces. (\u003Ccode\u003E{}\u003C\u002Fcode\u003E)\u003C\u002Fp\u003E\\n\u003Cp\u003EKeys must be text strings (wrapped in double quotation marks: \u003Ccode\u003E&quot;&quot;\u003C\u002Fcode\u003E), while values may be quoted text; the unquoted words \u003Ccode\u003Etrue\u003C\u002Fcode\u003E, \u003Ccode\u003Efalse\u003C\u002Fcode\u003E, or \u003Ccode\u003Enull\u003C\u002Fcode\u003E; an unquoted number; an \u003Cstrong\u003Earray\u003C\u002Fstrong\u003E (multiple equivalent values within square brackets: \u003Ccode\u003E[]\u003C\u002Fcode\u003E); or another JSON object (wrapped in curly braces: \u003Ccode\u003E{}\u003C\u002Fcode\u003E)\u003C\u002Fp\u003E\\n\u003Cp\u003ELet&#39;s consider the JSON for \u003Ca href=\\\"https:\u002F\u002Fwww.rijksmuseum.nl\u002Fnl\u002Fcollectie\u002FSK-C-5\\\"\u003ERembrandt&#39;s \u003Cem\u003ENightwatch\u003C\u002Fem\u003E in the Rijksmuseum\u003C\u002Fa\u003E:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-json\\\"\u003E{\\n  &quot;links&quot;: {\\n    &quot;self&quot;: &quot;https:\u002F\u002Fwww.rijksmuseum.nl\u002Fapi\u002Fnl\u002Fcollection\u002FSK-C-5&quot;,\\n    &quot;web&quot;: &quot;https:\u002F\u002Fwww.rijksmuseum.nl\u002Fnl\u002Fcollectie\u002FSK-C-5&quot;\\n  },\\n  &quot;id&quot;: &quot;nl-SK-C-5&quot;,\\n  &quot;objectNumber&quot;: &quot;SK-C-5&quot;,\\n  &quot;title&quot;: &quot;Schutters van wijk II onder leiding van kapitein Frans Banninck Cocq, bekend als de ‘Nachtwacht’&quot;,\\n  &quot;hasImage&quot;: true,\\n  &quot;principalOrFirstMaker&quot;: &quot;Rembrandt Harmensz. van Rijn&quot;,\\n  &quot;longTitle&quot;: &quot;Schutters van wijk II onder leiding van kapitein Frans Banninck Cocq, bekend als de ‘Nachtwacht’, Rembrandt Harmensz. van Rijn, 1642&quot;,\\n  &quot;showImage&quot;: true,\\n  &quot;permitDownload&quot;: true,\\n  &quot;webImage&quot;: {\\n    &quot;guid&quot;: &quot;3ae88fe0-021c-41ae-a4ce-cc70b7bc6295&quot;,\\n    &quot;offsetPercentageX&quot;: 50,\\n    &quot;offsetPercentageY&quot;: 100,\\n    &quot;width&quot;: 2500,\\n    &quot;height&quot;: 2034,\\n    &quot;url&quot;: &quot;http:\u002F\u002Flh6.ggpht.com\u002FZYWwML8mVFonXzbmg2rQBulNuCSr3rAaf5ppNcUc2Id8qXqudDL1NSYxaqjEXyDLSbeNFzOHRu0H7rbIws0Js4d7s_M=s0&quot;\\n  },\\n  &quot;headerImage&quot;: {\\n    &quot;guid&quot;: &quot;29a2a516-f1d2-4713-9cbd-7a4458026057&quot;,\\n    &quot;offsetPercentageX&quot;: 50,\\n    &quot;offsetPercentageY&quot;: 50,\\n    &quot;width&quot;: 1920,\\n    &quot;height&quot;: 460,\\n    &quot;url&quot;: &quot;http:\u002F\u002Flh3.ggpht.com\u002FrvCc4t2BWHAgDlzyiPlp1sBhc8ju0aSsu2HxR8rN_ZVPBcujP94pukbmF3Blmhi-GW5cx1_YsYYCDMTPePocwM6d2vk=s0&quot;\\n  },\\n  &quot;productionPlaces&quot;: [\\n    &quot;Amsterdam&quot;\\n  ]\\n}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ETakeaways:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003EThe entire text is wrapped in \u003Ccode\u003E{}\u003C\u002Fcode\u003E, identifying it as a JSON object.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003Eid\u003C\u002Fcode\u003E is a key, separated by a colon from its value, \u003Ccode\u003E&quot;nl-SK-C-5&quot;\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003ESome keys here have entire objects as their values. For example, \u003Ccode\u003EwebImage\u003C\u002Fcode\u003E has an object with its own key:value pairs like \u003Ccode\u003E&quot;width&quot;: 2500\u003C\u002Fcode\u003E and \u003Ccode\u003E&quot;height&quot;: 2034\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\\n\u003Cli\u003EThe key \u003Ccode\u003EproductionPlaces\u003C\u002Fcode\u003E has an \u003Cem\u003Earray\u003C\u002Fem\u003E as its value, denoted by the \u003Ccode\u003E[]\u003C\u002Fcode\u003E wrapping it.\\nIn this object, the array only has one value, \u003Ccode\u003E&quot;Amsterdam&quot;\u003C\u002Fcode\u003E, however it could have multiple values, e.g. \u003Ccode\u003E[&quot;Amsterdam&quot;, &quot;Kloveniersdoelen&quot;]\u003C\u002Fcode\u003E.\\nRemember, values of an array have no keys - they are all considered to be semantically equivalent to each other.\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Ch2 id=\\\"lesson-setup\\\"\u003ELesson Setup\u003C\u002Fh2\u003E\\n\u003Cp\u003EFor the bulk of this lesson, we will be working with a web-based version of jq at the site \u003Ca href=\\\"https:\u002F\u002Fjqplay.org\u002F\\\"\u003Ejq play\u003C\u002Fa\u003E.\\nFor this, you will only need your internet browser.\\n\u003Ca href=\\\"https:\u002F\u002Fjqplay.org\u002F\\\"\u003Ejq play\u003C\u002Fa\u003E cannot handle very large JSON files, but it is a great sandbox for learning the query language for jq.\\n(At the end of this lesson, we will download and install the command-line version of jq, which you may use to speedily parse much larger JSON files.)\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;jqplay-screenshot.png&quot; caption=&quot;The jq play website, with input JSON, filter, and results.&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EWe will type all queries into the &quot;Filter&quot; box in the upper-left corner of \u003Ca href=\\\"https:\u002F\u002Fjqplay.org\u002F\\\"\u003Ejq play\u003C\u002Fa\u003E.\\nSome of the filter queries are long, so be sure to scroll all the way to the right when copying them.\\nThe results will immediately display on the right-hand side, and update whenever you change the filter or the input JSON.\\nYou do not need to press enter.\\nAfter each query in this lesson, I will include the first few lines of the expected results, so that you can check your work.\\nIf you see an error displayed in the &quot;Results&quot; field of jq play, don&#39;t panic; just edit the query in the &quot;Filter&quot; field and jq play will re-run everything.\u003C\u002Fp\u003E\\n\u003Cp\u003EIn some instances, we will interact with the checkboxes on the upper-right.\\nThese set various jq \u003Ca href=\\\"https:\u002F\u002Fstedolan.github.io\u002Fjq\u002Fmanual\u002F#Invokingjq\\\"\u003Ecommand-line options, or \u003Cem\u003Eflags\u003C\u002Fem\u003E\u003C\u002Fa\u003E, that affect things like input handling, and the final formatting of the output.\\n\u003Cstrong\u003EStart the lesson with all of them unchecked.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"core-jq-filters\\\"\u003ECore jq filters\u003C\u002Fh2\u003E\\n\u003Cp\u003Ejq operates by way of \u003Cem\u003Efilters\u003C\u002Fem\u003E: a series of text commands that you can string together, and which dictate how jq should transform the JSON you give it.\u003C\u002Fp\u003E\\n\u003Cp\u003ETo learn the basic jq filters, we&#39;ll work with a sample response from the Rijksmuseum API: \u003Ca href=\\\"\u002Fassets\u002Fjq_rkm.json\\\"\u003Erkm.json\u003C\u002Fa\u003E\\nSelect all the text at that link, copy it, and paste it into the &quot;JSON&quot; box at \u003Ca href=\\\"https:\u002F\u002Fjqplay.org\u002F\\\"\u003Ejq play\u003C\u002Fa\u003E on the left hand side.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"the-dot-\\\"\u003EThe dot: \u003Ccode\u003E.\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\\n\u003Cp\u003EThe basic jq operator is the dot: \u003Ccode\u003E.\u003C\u002Fcode\u003E\\nUsed by itself, \u003Ccode\u003E.\u003C\u002Fcode\u003E leaves the input unmodified.\\nAdd the name of a key to it, however, and the filter will return the value of that key.\\nTry the following filter:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E.count\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThis tells jq to return the value of the field \u003Ccode\u003Ecount\u003C\u002Fcode\u003E.\\nThe result should read \u003Ccode\u003E359\u003C\u002Fcode\u003E.\\nIf you want to access a value in an object that&#39;s already within another object, you can chain \u003Ccode\u003E.\u003C\u002Fcode\u003E filters together, e.g. \u003Ccode\u003E.links.self\u003C\u002Fcode\u003E.\\n\u003Ca href=\\\"#output-a-csv-csv\\\"\u003EWe will use this functionality later in the lesson.\u003C\u002Fa\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003ETry the \u003Ccode\u003E.\u003C\u002Fcode\u003E operator again, this time accessing the field \u003Ccode\u003EartObjects\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E.artObjects\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe results:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-json\\\"\u003E[\\n  {\\n    &quot;links&quot;: {\\n      &quot;self&quot;: &quot;https:\u002F\u002Fwww.rijksmuseum.nl\u002Fapi\u002Fnl\u002Fcollection\u002FSK-C-5&quot;,\\n      &quot;web&quot;: &quot;https:\u002F\u002Fwww.rijksmuseum.nl\u002Fnl\u002Fcollectie\u002FSK-C-5&quot;\\n    },\\n    &quot;id&quot;: &quot;nl-SK-C-5&quot;,\\n    &quot;objectNumber&quot;: &quot;SK-C-5&quot;,\\n    &quot;title&quot;: &quot;Schutters van wijk II onder leiding van kapitein Frans Banninck Cocq, bekend als de ‘Nachtwacht’&quot;,\\n    &quot;hasImage&quot;: true,\\n    &quot;principalOrFirstMaker&quot;: &quot;Rembrandt Harmensz. van Rijn&quot;,\\n    &quot;longTitle&quot;: &quot;Schutters van wijk II onder leiding van kapitein Frans Banninck Cocq, bekend als de ‘Nachtwacht’, Rembrandt Harmensz. van Rijn, 1642&quot;,\\n    &quot;showImage&quot;: true,\\n    &quot;permitDownload&quot;: true,\\n    &quot;webImage&quot;: {\\n      &quot;guid&quot;: &quot;3ae88fe0-021c-41ae-a4ce-cc70b7bc6295&quot;,\\n      &quot;offsetPercentageX&quot;: 50\\n      \u002F*ETC...*\u002F\\n    }\\n  }\\n]\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ENote that jq has returned the entire array.\\nRather than being wrapped in \u003Ccode\u003E{}\u003C\u002Fcode\u003E, the result is a series of objects wrapped within an array (\u003Ccode\u003E[{},{},{}]\u003C\u002Fcode\u003E)\\nThe significance of this will be discussed in the next section.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"the-array-operator-\\\"\u003EThe array operator: \u003Ccode\u003E[]\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\\n\u003Cp\u003E\u003Ccode\u003E.artObjects\u003C\u002Fcode\u003E returned one big array of JSON objects.\\nBefore we can access the values inside those objects, we need to break them out of the array that they&#39;re in.\\nBy adding \u003Ccode\u003E[]\u003C\u002Fcode\u003E onto the end of our filter, jq will break up this one array into 10 separate objects:\u003C\u002Fp\u003E\\n\u003Cp\u003ETry it:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E.artObjects[]\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ENotice that the \u003Ccode\u003E[]\u003C\u002Fcode\u003E wrapping our results are now gone.\\nTo make clear what has happened, check the &quot;Compact Output&quot; checkbox in the upper right.\\nThis removes the cosmetic line breaks in the results, returning one JSON object per line.\\nYou should have a 10-line output now.\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;compact-output-multiple.png&quot; caption=&quot;jq&#39;s &#39;Compact Output&#39; option removes all cosmetic line breaks in a file, just leaving one JSON object per line.&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EKeeping &quot;Compact Output&quot; checked, remove the \u003Ccode\u003E[]\u003C\u002Fcode\u003E from the filter, so it just reads \u003Ccode\u003E.artObjects\u003C\u002Fcode\u003E again.\\nThe results should now be just one line, as jq is now just returning one single JSON array:\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;compact-output-single.png&quot; caption=&quot;When jq returns just one JSON object, the &#39;Compact Output&#39; option will produce a one-line result.&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EIf you want to access just the first (or the \u003Cem\u003En\u003C\u002Fem\u003E-th) item in an array, put a digit in the \u003Ccode\u003E[]\u003C\u002Fcode\u003E operator:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E.artObjects[0]\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003E\u003Cstrong\u003EIMPORTANT: you access the first element of an array with \u003Ccode\u003E0\u003C\u002Fcode\u003E, not \u003Ccode\u003E1\u003C\u002Fcode\u003E.\u003C\u002Fstrong\u003E\\nThis is because JavaScript, like quite a few other programming languages (\u003Ca href=\\\"http:\u002F\u002Fstackoverflow.com\u002Fquestions\u002F3135325\u002Fwhy-do-vector-indices-in-r-start-with-1-instead-of-0\\\"\u003Ethough not all!\u003C\u002Fa\u003E), \u003Ca href=\\\"http:\u002F\u002Fskillcrush.com\u002F2013\u002F01\u002F17\u002Fwhy-programmers-start-counting-at-zero\u002F\\\"\u003Estarts counting at 0\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EThis filter returns just the first element of the \u003Ccode\u003EartObjects\u003C\u002Fcode\u003E array.\\n\u003Ccode\u003E.artObjects[1]\u003C\u002Fcode\u003E would return the second, and so on.\u003C\u002Fp\u003E\\n\u003Cp\u003EUncheck the &quot;Compact Output&quot; box again before continuing with the lesson.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"the-pipe-\\\"\u003EThe pipe: \u003Ccode\u003E|\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\\n\u003Cp\u003EThe magic of jq is that you can connect, or \u003Cem\u003Epipe\u003C\u002Fem\u003E, several operators together to accomplish some very complex transformations of your data.\\nWhat&#39;s more, jq will repeat the filter for each JSON object provided by the previous step.\\nTherefore, while we started with just one big JSON object, \u003Ccode\u003E.artObjects[]\u003C\u002Fcode\u003E created 10 smaller JSON objects.\\nAny operator we put after the \u003Ccode\u003E|\u003C\u002Fcode\u003E will be repeated for each of these objects.\u003C\u002Fp\u003E\\n\u003Cp\u003EFor example, try the following query:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E.artObjects[] | .id\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThis will return a list of every value at the key \u003Ccode\u003Eid\u003C\u002Fcode\u003E within the \u003Ccode\u003EartObjects\u003C\u002Fcode\u003E array, separated by a line break.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"filter-select\\\"\u003EFilter: \u003Ccode\u003Eselect()\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\\n\u003Cp\u003ENormally jq repeats every filter operation for each line of input that it receives, passing each answer on to the following filter operation.\\n\u003Ccode\u003Eselect()\u003C\u002Fcode\u003E will only pass on a subset of the input onto the next step of the filter.\u003C\u002Fp\u003E\\n\u003Cp\u003ELet&#39;s filter the Rijksmuseum JSON to only return the ids of objects that have at least one value assigned to their \u003Ccode\u003EproductionPlaces\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E.artObjects[] | select(.productionPlaces | length &gt;= 1) | .id\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThis should return:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-json\\\"\u003E&quot;nl-SK-C-5&quot;\\n&quot;nl-SK-A-3924&quot;\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ELet&#39;s break down this query into its component pieces:\u003C\u002Fp\u003E\\n\u003Col\u003E\\n\u003Cli\u003E\u003Ccode\u003E.artObjects[] |\u003C\u002Fcode\u003E Breaks open the array of objects contained in the original Rijksmuseum JSON, just like we did in the previous step of this lesson. The \u003Ccode\u003E|\u003C\u002Fcode\u003E sends the results of this step along to the next command...\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003Eselect(.productionPlaces | length &gt;= 1) |\u003C\u002Fcode\u003E The command \u003Ccode\u003Eselect(...)\u003C\u002Fcode\u003E will only pass along the JSON objects that match the rule defined inside the parentheses. Our rule has 3 parts:\u003Col\u003E\\n\u003Cli\u003E\u003Ccode\u003E.productionPlaces\u003C\u002Fcode\u003E Access the array at the key named \u003Ccode\u003EproductionPlaces\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E| length\u003C\u002Fcode\u003E The pipe (\u003Ccode\u003E|\u003C\u002Fcode\u003E) sends that array to the next command, \u003Ccode\u003Elength\u003C\u002Fcode\u003E, which returns the number of elements in the array.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E&gt;= 1\u003C\u002Fcode\u003E This last part of our rule checks whether the number returned by \u003Ccode\u003Elength\u003C\u002Fcode\u003E is greater than or equal to 1. If it is \u003Ccode\u003Etrue\u003C\u002Fcode\u003E, then \u003Ccode\u003Eselect()\u003C\u002Fcode\u003E will pass the object along to the last part of our filter. If it is \u003Ccode\u003Efalse\u003C\u002Fcode\u003E, it will not pass it.\u003C\u002Fli\u003E\\n\u003C\u002Fol\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E.id\u003C\u002Fcode\u003E This final command accesses the value stored in the key \u003Ccode\u003Eid\u003C\u002Fcode\u003E in the two objects that make it through the \u003Ccode\u003Eselect()\u003C\u002Fcode\u003E filter.\u003C\u002Fli\u003E\\n\u003C\u002Fol\u003E\\n\u003Cp\u003Ejq can also filter based on regular expressions.\\n(To learn more about regular expressions, see the Programming Historian lesson \u003Ca href=\\\"\u002Flessons\u002Funderstanding-regular-expressions\\\"\u003E&quot;Understanding Regular Expressions&quot;\u003C\u002Fa\u003E.)\\nFor example, let&#39;s select only those objects whose primary maker has the particle &quot;van&quot; in their name, and return the artist name and artwork id.\\n\u003Ccode\u003Etest(&quot;van&quot;)\u003C\u002Fcode\u003E takes the value returned by the operator \u003Ccode\u003E.principalOrFirstMaker\u003C\u002Fcode\u003E and returns true if that value contains the string \u003Ccode\u003Evan\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E.artObjects[] | select(.principalOrFirstMaker | test(&quot;van&quot;)) | {id: .id, artist: .principalOrFirstMaker}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe results:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-json\\\"\u003E{\\n  &quot;id&quot;: &quot;nl-SK-C-5&quot;,\\n  &quot;artist&quot;: &quot;Rembrandt Harmensz. van Rijn&quot;\\n}\\n{\\n  &quot;id&quot;: &quot;nl-SK-A-180&quot;,\\n  &quot;artist&quot;: &quot;Gerard van Honthorst&quot;\\n}\\n{\\n  &quot;id&quot;: &quot;nl-SK-A-2205&quot;,\\n  &quot;artist&quot;: &quot;Gerrit van Vucht&quot;\\n}\\n{\\n  &quot;id&quot;: &quot;nl-SK-A-1935&quot;,\\n  &quot;artist&quot;: &quot;Rembrandt Harmensz. van Rijn&quot;\\n}\\n{\\n  &quot;id&quot;: &quot;nl-SK-A-3246&quot;,\\n  &quot;artist&quot;: &quot;Adriaen van Ostade&quot;\\n}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ETo see other types of rules for \u003Ccode\u003Eselect()\u003C\u002Fcode\u003E, \u003Ca href=\\\"https:\u002F\u002Fstedolan.github.io\u002Fjq\u002Fmanual\u002F#ConditionalsandComparisons\\\"\u003Econsult the full list of jq conditionals and comparisons.\u003C\u002Fa\u003E\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"create-new-json--and-\\\"\u003ECreate new JSON: \u003Ccode\u003E[]\u003C\u002Fcode\u003E and \u003Ccode\u003E{}\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\\n\u003Cp\u003EBy wrapping \u003Ccode\u003E.\u003C\u002Fcode\u003E operators within either \u003Ccode\u003E[]\u003C\u002Fcode\u003E or \u003Ccode\u003E{}\u003C\u002Fcode\u003E, jq can synthesize new JSON arrays and objects.\\nThis can be useful if you want to output a new JSON file.\\nAs we will see below, this can also be a crucial intermediate step when reshaping complex JSON.\u003C\u002Fp\u003E\\n\u003Cp\u003ECreate a new set of JSON objects with the following filter:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E.artObjects[] | {id: .id, title: .title}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EWhen creating an object with \u003Ccode\u003E{}\u003C\u002Fcode\u003E, you specify the names of the keys with unquoted text, and then assign the values with regular jq filters.\\nThe resulting set of JSON objects have just two keys: \u003Ccode\u003Eid\u003C\u002Fcode\u003E and \u003Ccode\u003Etitle\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-json\\\"\u003E{\\n  &quot;id&quot;: &quot;nl-SK-C-5&quot;,\\n  &quot;title&quot;: &quot;Schutters van wijk II onder leiding van kapitein Frans Banninck Cocq, bekend als de ‘Nachtwacht’&quot;\\n}\\n{\\n  &quot;id&quot;: &quot;nl-SK-A-1505&quot;,\\n  &quot;title&quot;: &quot;Een molen aan een poldervaart, bekend als ‘In de maand juli’&quot;\\n}\\n\u002F*ETC...*\u002F\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EWe can also create arrays using \u003Ccode\u003E[]\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E.artObjects[] | [.id, .title]\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe results:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-json\\\"\u003E[\\n  &quot;nl-SK-C-5&quot;,\\n  &quot;Schutters van wijk II onder leiding van kapitein Frans Banninck Cocq, bekend als de ‘Nachtwacht’&quot;\\n]\\n[\\n  &quot;nl-SK-A-1505&quot;,\\n  &quot;Een molen aan een poldervaart, bekend als ‘In de maand juli’&quot;\\n]\\n\u002F*ETC...*\u002F\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EUnlike objects made using \u003Ccode\u003E{}\u003C\u002Fcode\u003E, arrays have no keys; they are just simple lists of values.\\nCreating simple arrays is crucial, however, for mapping our JSON into a CSV file.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"output-a-csv-csv\\\"\u003EOutput a CSV: \u003Ccode\u003E@csv\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\\n\u003Cp\u003ETo create a CSV table with jq we want to filter our input JSON into a series of arrays, with each array being a row of the CSV.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe previous filter gave us an array with the \u003Ccode\u003Eid\u003C\u002Fcode\u003E and \u003Ccode\u003Etitle\u003C\u002Fcode\u003E keys of each painting.\\nLet&#39;s add the primary artist for each artwork as well:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E.artObjects[] | [.id, .title, .principalOrFirstMaker, .webImage.url]\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe results:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-json\\\"\u003E[\\n  &quot;nl-SK-C-5&quot;,\\n  &quot;Schutters van wijk II onder leiding van kapitein Frans Banninck Cocq, bekend als de ‘Nachtwacht’&quot;,\\n  &quot;Rembrandt Harmensz. van Rijn&quot;,\\n  &quot;http:\u002F\u002Flh6.ggpht.com\u002FZYWwML8mVFonXzbmg2rQBulNuCSr3rAaf5ppNcUc2Id8qXqudDL1NSYxaqjEXyDLSbeNFzOHRu0H7rbIws0Js4d7s_M=s0&quot;\\n]\\n[\\n  &quot;nl-SK-A-1505&quot;,\\n  &quot;Een molen aan een poldervaart, bekend als ‘In de maand juli’&quot;,\\n  &quot;Paul Joseph Constantin Gabriël&quot;,\\n  &quot;http:\u002F\u002Flh4.ggpht.com\u002FPkQr-nNqzn0OVXVd4-hdJ6PPdWZ6-DQ_74WfBT3MZIV4LNYA-q8LUrtReXNstuzl9k6gKWkaBwG-LcFZ7zWU9Ch92g=s0&quot;\\n]\\n\u002F*ETC...*\u002F\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ENote that, to access the url nested in the \u003Ccode\u003EwebImage\u003C\u002Fcode\u003E object, we chained together \u003Ccode\u003E.webImage.url\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003ETo format this as CSV, add the operator \u003Ccode\u003E@csv\u003C\u002Fcode\u003E on the end with another pipe and check the &quot;Raw Output&quot; box in the upper right.\\n\u003Ccode\u003E@csv\u003C\u002Fcode\u003E properly joins the arrays with \u003Ccode\u003E,\u003C\u002Fcode\u003E and adds quotes where needed.\\n&quot;Raw Output&quot; tells jq that we want to produce a text file, rather than a new JSON file.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E.artObjects[] | [.id, .title, .principalOrFirstMaker, .webImage.url] | @csv\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe results:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E&quot;nl-SK-C-5&quot;,&quot;Schutters van wijk II onder leiding van kapitein Frans Banninck Cocq, bekend als de ‘Nachtwacht’&quot;,&quot;Rembrandt Harmensz. van Rijn&quot;,&quot;http:\u002F\u002Flh6.ggpht.com\u002FZYWwML8mVFonXzbmg2rQBulNuCSr3rAaf5ppNcUc2Id8qXqudDL1NSYxaqjEXyDLSbeNFzOHRu0H7rbIws0Js4d7s_M=s0&quot;\\n&quot;nl-SK-A-1505&quot;,&quot;Een molen aan een poldervaart, bekend als ‘In de maand juli’&quot;,&quot;Paul Joseph Constantin Gabriël&quot;,&quot;http:\u002F\u002Flh4.ggpht.com\u002FPkQr-nNqzn0OVXVd4-hdJ6PPdWZ6-DQ_74WfBT3MZIV4LNYA-q8LUrtReXNstuzl9k6gKWkaBwG-LcFZ7zWU9Ch92g=s0&quot;\\n...\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThis is a valid CSV file, which we could now import into an analysis program.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"advanced-operations\\\"\u003EAdvanced operations\u003C\u002Fh2\u003E\\n\u003Ch3 id=\\\"json-vs-json-lines\\\"\u003EJSON vs. JSON Lines\u003C\u002Fh3\u003E\\n\u003Cp\u003EYou may encounter two different types of JSON files in the wild: files with one large JSON object, and so-called &quot;JSON lines&quot; files, which have multiple, separate JSON objects each on one single line, not wrapped by \u003Ccode\u003E[]\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EYou will commonly find larger data dumps of JSON will come in a JSON lines format.\\nFor example, the \u003Ca href=\\\"https:\u002F\u002Fgithub.com\u002FNYPL-publicdomain\u002Fdata-and-utilities\u002Ftree\u002Fmaster\u002Fitems\\\"\u003ENew York Public Library released their public domain collections in multiple JSON lines-formatted files\u003C\u002Fa\u003E.\\nYou&#39;ll note that the NYPL used the file extension \u003Ccode\u003E.ndjson\u003C\u002Fcode\u003E, but is is just one convention --- others use \u003Ccode\u003E.jsonl\u003C\u002Fcode\u003E or even just \u003Ccode\u003E.json\u003C\u002Fcode\u003E.\\nBecause there is no standard for naming JSON vs. JSON lines files, the only way to check what type you are getting is to open the file in a text editor (or use \u003Ccode\u003Ehead\u003C\u002Fcode\u003E on the command line) to check if the file has one object per line, or is one big object (or a series of objects wrapped with \u003Ccode\u003E[]\u003C\u002Fcode\u003E) spread out over many lines.\u003C\u002Fp\u003E\\n\u003Cp\u003Ejq will repeat your entire filter statement \u003Cem\u003Eper JSON object\u003C\u002Fem\u003E.\\nThis means that it will run your filter once on a file with a large JSON object, and run it \u003Cem\u003Eonce per line\u003C\u002Fem\u003E on a &quot;JSON lines&quot; file.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe Rijksmuseum example above is a single JSON object that contains many smaller sub-objects, each of which stands for an artwork in the collection.\\nWe will now begin working with a set of Twitter JSON in the &quot;JSON lines&quot; format, transforming complex relationships into usable flat tables.\u003C\u002Fp\u003E\\n\u003Cp\u003EData about tweets can be accessed via the \u003Ca href=\\\"https:\u002F\u002Fdev.twitter.com\u002Foverview\u002Fapi\\\"\u003ETwitter API\u003C\u002Fa\u003E, which returns JSON data.\\nOne of the easiest ways to search and download Twitter data is using the excellent utility \u003Ca href=\\\"https:\u002F\u002Fgithub.com\u002Fedsu\u002Ftwarc\\\"\u003Etwarc\u003C\u002Fa\u003E, which saves data as JSON lines.\u003C\u002Fp\u003E\\n\u003Cp\u003EFor this lesson, we will use a small sample of 50 public tweets.\\nClear the &quot;Filter&quot;, &quot;JSON&quot; and &quot;Result&quot; boxes on \u003Ca href=\\\"https:\u002F\u002Fjqplay.org\u002F\\\"\u003Ejq play\u003C\u002Fa\u003E, and ensure all the checkboxes are unchecked.\\n\u003Ca href=\\\"\u002Fassets\u002Fjq_twitter.json\\\"\u003EThen copy this sample Twitter data\u003C\u002Fa\u003E into \u003Ca href=\\\"https:\u002F\u002Fjqplay.org\u002F\\\"\u003Ejq play\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"one-to-many-relationships-tweet-hashtags\\\"\u003EOne-to-many relationships: Tweet hashtags\u003C\u002Fh3\u003E\\n\u003Cp\u003EOften you may wish to create a table that expresses a one-to-many relationship, such as a tweet and its hashtags.\\nA tweet will always have exactly one tweet ID, while it may have zero, one, or more hashtags.\\nThere are a few ways to express this as a CSV table, but we will implement two common solutions here:\u003C\u002Fp\u003E\\n\u003Col\u003E\\n\u003Cli\u003EOne row per tweet, with multiple hashtags in the same cell\u003C\u002Fli\u003E\\n\u003Cli\u003EOne row per hashtag\u002Ftweet combination (\u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FWide_and_narrow_data\\\"\u003Ealso known as &quot;long&quot; or &quot;narrow&quot; data\u003C\u002Fa\u003E), with tweet IDs and hashtags repeated as necessary\u003C\u002Fli\u003E\\n\u003C\u002Fol\u003E\\n\u003Ch4 id=\\\"one-row-per-tweet\\\"\u003EOne row per tweet\u003C\u002Fh4\u003E\\n\u003Cp\u003ELet&#39;s create a table with one column with a tweet ID, and a second column with all the hashtags in each tweet, separated by a semicolon: \u003Ccode\u003E;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EThis is a relatively complex query that will require a multi-step filter.\\nFirst, let&#39;s reduce the Twitter JSON to just ids and the objects describing the hashtags.\\nPaste this filter into \u003Ca href=\\\"https:\u002F\u002Fjqplay.org\u002F\\\"\u003Ejq play\u003C\u002Fa\u003E:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E{id: .id, hashtags: .entities.hashtags}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe results:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-json\\\"\u003E{\\n  &quot;id&quot;: 501064141332029440,\\n  &quot;hashtags&quot;: [\\n    {\\n      &quot;indices&quot;: [\\n        41,\\n        50\\n      ],\\n      &quot;text&quot;: &quot;Ferguson&quot;\\n    }\\n  ]\\n}\\n{\\n  &quot;id&quot;: 501064171707170800,\\n  &quot;hashtags&quot;: [\\n    {\\n      &quot;indices&quot;: [\\n        139,\\n        140\\n      ],\\n      &quot;text&quot;: &quot;Ferguson&quot;\\n    }\\n  ]\\n}\\n\u002F*ETC...*\u002F\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ENote that we do not have to start this query by breaking apart an array like we did with the Rijskmuseum data.\\nThis is because the Twitter data comes in the JSON lines format, with one separate JSON object per line in the file.\\njq simply repeats the filter for each of these separate objects.\\nThis has created a set of JSON objects (wrapped in \u003Ccode\u003E{}\u003C\u002Fcode\u003E) with an \u003Ccode\u003Eid\u003C\u002Fcode\u003E key and a \u003Ccode\u003Ehashtags\u003C\u002Fcode\u003E key.\\nThe value of \u003Ccode\u003Ehashtags\u003C\u002Fcode\u003E is the  array (wrapped in \u003Ccode\u003E[]\u003C\u002Fcode\u003E) from the original data, which may have 0 or more objects inside it.\\nLet&#39;s add a second query to preserve just the text of those hashtags:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E{id: .id, hashtags: .entities.hashtags} | {id: .id, hashtags: .hashtags[].text}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe results:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-json\\\"\u003E{\\n  &quot;id&quot;: 501064141332029440,\\n  &quot;hashtags&quot;: &quot;Ferguson&quot;\\n}\\n{\\n  &quot;id&quot;: 501064171707170800,\\n  &quot;hashtags&quot;: &quot;Ferguson&quot;\\n}\\n{\\n  &quot;id&quot;: 501064180468682750,\\n  &quot;hashtags&quot;: &quot;Ferguson&quot;\\n}\\n{\\n  &quot;id&quot;: 501064194309906400,\\n  &quot;hashtags&quot;: &quot;USNews&quot;\\n}\\n{\\n  &quot;id&quot;: 501064196931330050,\\n  &quot;hashtags&quot;: &quot;Ferguson&quot;\\n}\\n{\\n  &quot;id&quot;: 501064196931330050,\\n  &quot;hashtags&quot;: &quot;MikeBrown&quot;\\n}\\n\u002F*ETC...*\u002F\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003E\u003Ccode\u003Eid: .id\u003C\u002Fcode\u003E just keeps the \u003Ccode\u003Eid\u003C\u002Fcode\u003E field unchanged.\\nThe \u003Ccode\u003E[]\u003C\u002Fcode\u003E in \u003Ccode\u003E.hashtags[].text\u003C\u002Fcode\u003E breaks open the array of hashtags in each tweet, allowing us to extract the value of the \u003Ccode\u003Etext\u003C\u002Fcode\u003E key from each one.\\nNote, however, that tweet ID \u003Ccode\u003E501064196931330050\u003C\u002Fcode\u003E shows up twice in the results, because it had 2 hashtags: \u003Ccode\u003EFerguson\u003C\u002Fcode\u003E and \u003Ccode\u003EMikeBrown\u003C\u002Fcode\u003E.\\nWe want the tweet ID to only show up once, with an array of hashtags.\\nTo do this, let&#39;s edit our filter by adding another set of \u003Ccode\u003E[]\u003C\u002Fcode\u003E, this time wrapping around \u003Ccode\u003E.hashtags[].text\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E{id: .id, hashtags: .entities.hashtags} | {id: .id, hashtags: [.hashtags[].text]}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EBy adding \u003Ccode\u003E[]\u003C\u002Fcode\u003E around \u003Ccode\u003E.hashtags[].text\u003C\u002Fcode\u003E, we tell jq to collect the individual results of \u003Ccode\u003E.hashtags[].text\u003C\u002Fcode\u003E within an array.\\nIf it finds multiple results, it will put them together in the same array.\\nNote that tweet ID \u003Ccode\u003E501064196931330050\u003C\u002Fcode\u003E now has just one object, with an embedded array of two hashtags:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-json\\\"\u003E\u002F* ... *\u002F\\n{\\n  &quot;id&quot;: 501064196931330050,\\n  &quot;hashtags&quot;: [\\n    &quot;Ferguson&quot;,\\n    &quot;MikeBrown&quot;\\n  ]\\n}\\n\u002F*ETC...*\u002F\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EFinally, we want to express this as a CSV file, delimiting the hashtags with \u003Ccode\u003E;\u003C\u002Fcode\u003E.\\nTo do this, we need to add one more intermediary JSON object:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E{id: .id, hashtags: .entities.hashtags} | {id: .id, hashtags: [.hashtags[].text]} | {id: .id, hashtags: .hashtags | join(&quot;;&quot;)}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EOnce again, we use \u003Ccode\u003Eid: .id\u003C\u002Fcode\u003E to preserve the \u003Ccode\u003Eid\u003C\u002Fcode\u003E value unchanged.\\nHowever, we change the value of \u003Ccode\u003Ehashtags\u003C\u002Fcode\u003E one last time.\\n\u003Ccode\u003E.hashtags | join(&quot;;&quot;)\u003C\u002Fcode\u003E uses the \u003Ca href=\\\"https:\u002F\u002Fstedolan.github.io\u002Fjq\u002Fmanual\u002F#join(str)\\\"\u003E\u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E\u003C\u002Fa\u003E command, which takes an array as input and joins the elements together using the provided string (in this case, \u003Ccode\u003E&quot;;&quot;\u003C\u002Fcode\u003E):\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-json\\\"\u003E{\\n  &quot;id&quot;: 501064141332029440,\\n  &quot;hashtags&quot;: &quot;Ferguson&quot;\\n}\\n{\\n  &quot;id&quot;: 501064171707170800,\\n  &quot;hashtags&quot;: &quot;Ferguson&quot;\\n}\\n{\\n  &quot;id&quot;: 501064180468682750,\\n  &quot;hashtags&quot;: &quot;Ferguson&quot;\\n}\\n{\\n  &quot;id&quot;: 501064188211765250,\\n  &quot;hashtags&quot;: &quot;&quot;\\n}\\n{\\n  &quot;id&quot;: 501064194309906400,\\n  &quot;hashtags&quot;: &quot;USNews&quot;\\n}\\n{\\n  &quot;id&quot;: 501064196931330050,\\n  &quot;hashtags&quot;: &quot;Ferguson;MikeBrown&quot;\\n}\\n\u002F*ETC...*\u002F\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ENow, we can finally format the individual rows of the CSV and output it (remember to check the &quot;Raw Output&quot; box):\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E{id: .id, hashtags: .entities.hashtags} | {id: .id, hashtags: [.hashtags[].text]} | {id: .id, hashtags: .hashtags | join(&quot;;&quot;)} | [.id, .hashtags] | @csv\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThis is a very complex, multipart query.\\nLet&#39;s review its components one more time:\u003C\u002Fp\u003E\\n\u003Col\u003E\\n\u003Cli\u003E\u003Ccode\u003E{id: .id, hashtags: .entities.hashtags} |\u003C\u002Fcode\u003E Create a new set of JSON objects by extracting the \u003Ccode\u003Eid\u003C\u002Fcode\u003E field from each tweet, along with the JSON object describing the tweet&#39;s hashtags.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E{id: .id, hashtags: [.hashtags[].text]} |\u003C\u002Fcode\u003E Preserve the \u003Ccode\u003Eid\u003C\u002Fcode\u003E key:value pair, and collect the \u003Ccode\u003Etext\u003C\u002Fcode\u003E of each \u003Ccode\u003Ehashtags\u003C\u002Fcode\u003E object in an array, which we reassign to the key \u003Ccode\u003Ehashtags\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E{id: .id, hashtags: .hashtags | join(&quot;;&quot;)} |\u003C\u002Fcode\u003E Preserve the \u003Ccode\u003Eid\u003C\u002Fcode\u003E key:value pair, and join the contents of the \u003Ccode\u003Ehashtags\u003C\u002Fcode\u003E array together, separated by \u003Ccode\u003E;\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E[.id, .hashtags] |\u003C\u002Fcode\u003E Build an array for each row of our desired table\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E@csv\u003C\u002Fcode\u003E Format everything as a CSV\u003C\u002Fli\u003E\\n\u003C\u002Fol\u003E\\n\u003Cp\u003EThe final results:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E501064141332029440,&quot;Ferguson&quot;\\n501064171707170800,&quot;Ferguson&quot;\\n501064180468682750,&quot;Ferguson&quot;\\n501064188211765250,&quot;&quot;\\n501064194309906400,&quot;USNews&quot;\\n501064196931330050,&quot;Ferguson;MikeBrown&quot;\\n501064197396914200,&quot;&quot;\\n501064197632167940,&quot;Ferguson;tcot;uniteblue;teaparty;gop&quot;\\n...\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThere are ways to get the same results using an even shorter query, but in most cases, it pays to break up your jq transformations into small steps.\u003C\u002Fp\u003E\\n\u003Ch4 id=\\\"one-row-per-hashtag\\\"\u003EOne row per hashtag\u003C\u002Fh4\u003E\\n\u003Cp\u003EThis is actually simpler to implement in jq, because we can take advantage of jq&#39;s natural behavior of repeating filters.\u003C\u002Fp\u003E\\n\u003Cp\u003EWe will start with the same set of operations that extract the tweet ID and the hashtag objects from the original Twitter JSON:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E{id: .id, hashtags: .entities.hashtags} | {id: .id, hashtags: .hashtags[].text}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThis results in a long series of JSON objects with one id and one hashtag per object.\\nAll we need to do is construct the CSV row arrays and pipe them through the \u003Ccode\u003E@csv\u003C\u002Fcode\u003E operator:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E{id: .id, hashtags: .entities.hashtags} | {id: .id, hashtag: .hashtags[].text} | [.id, .hashtag] | @csv\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe results:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E501064141332029440,&quot;Ferguson&quot;\\n501064171707170800,&quot;Ferguson&quot;\\n501064180468682750,&quot;Ferguson&quot;\\n501064194309906400,&quot;USNews&quot;\\n501064196931330050,&quot;Ferguson&quot;\\n501064196931330050,&quot;MikeBrown&quot;\\n...\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Ch3 id=\\\"grouping-and-counting\\\"\u003EGrouping and Counting\u003C\u002Fh3\u003E\\n\u003Cp\u003EOften times, your JSON will be structured around one type of entity (say, artworks from the Rijksmuseum API, or tweets from the Twitter API) when you, the researcher, may be more interested in collecting information about a related, but secondary entity, like an artist, a Twitter hashtag, or a Twitter user.\\nIn this section, we will use jq to extract a table of information about Twitter \u003Cem\u003Eusers\u003C\u002Fem\u003E from the tweet-based JSON, as well as grouping and counting tweet \u003Cem\u003Ehashtags\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EFor the previous examples, we have only needed to consider each tweet individually.\\nBy default, jq will look at one JSON object at a time when parsing a file; consequently, it can \u003Cem\u003Estream\u003C\u002Fem\u003E very large files without having to load the entire set in to memory.\u003C\u002Fp\u003E\\n\u003Cp\u003EHowever, in cases where we are aggregating information about the individual objects in a JSON file, we need to give jq access to every JSON object in a file simultaneously.\\nThis is where we want to use &quot;Slurp&quot; (or the \u003Ccode\u003E-s\u003C\u002Fcode\u003E flag on command-line jq).\\n&quot;Slurp&quot; tells jq to read every line of the input JSON lines and treat the entire group as one huge array of objects.\u003C\u002Fp\u003E\\n\u003Cp\u003EWith the Twitter data still in the input box on \u003Ca href=\\\"https:\u002F\u002Fjqplay.org\u002F\\\"\u003Ejq play\u003C\u002Fa\u003E, check the &quot;Slurp&quot; box, and just put \u003Ccode\u003E.\u003C\u002Fcode\u003E in the filter.\\nNote that it&#39;s wrapped the objects in \u003Ccode\u003E[]\u003C\u002Fcode\u003E.\\nNow we can build even more complex commands that require knowledge of the entire input file.\u003C\u002Fp\u003E\\n\u003Ch4 id=\\\"extracting-user-data\\\"\u003EExtracting user data\u003C\u002Fh4\u003E\\n\u003Cp\u003EBecause the Twitter API returns per-tweet information, info about the \u003Cem\u003Eusers\u003C\u002Fem\u003E who send those tweets is repeated with each tweet within an object assigned to the key \u003Ccode\u003Euser\u003C\u002Fcode\u003E.\\nLet&#39;s look at the user data in the very first tweet in this dataset (remember to keep the &quot;Slurp&quot; option checked.)\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E.[0].user\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe \u003Ccode\u003E[0]\u003C\u002Fcode\u003E operator accesses the very first tweet in the data, while \u003Ccode\u003E.user\u003C\u002Fcode\u003E extracts the embedded information in the user field.\\nThe results will look like this:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-json\\\"\u003E{\\n  &quot;follow_request_sent&quot;: false,\\n  &quot;has_extended_profile&quot;: false,\\n  &quot;profile_use_background_image&quot;: true,\\n  &quot;default_profile_image&quot;: false,\\n  &quot;id&quot;: 851336634,\\n  &quot;profile_background_image_url_https&quot;: &quot;https:\u002F\u002Fpbs.twimg.com\u002Fprofile_background_images\u002F834791998\u002F376566559c7f84a79248efd7a1b4b686.jpeg&quot;,\\n  &quot;verified&quot;: true\\n  \u002F* ETC... *\u002F\\n}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ETo collect information about users, we will want to use the \u003Ccode\u003Egroup_by()\u003C\u002Fcode\u003E\\n\u003Ccode\u003Egroup_by(.key)\u003C\u002Fcode\u003E takes an array of objects as its input, and returns an array of arrays, with those sub-arrays filled with objects that share the same value for the specified \u003Ccode\u003Ekey\u003C\u002Fcode\u003E.\\nBecause we have read the input JSON lines using the &quot;Slurp&quot; option, we already start with an array of tweet objects.\\nWe can use \u003Ccode\u003Egroup_by(.user)\u003C\u002Fcode\u003E to collect these tweets into sub-arrays of one user each.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003Egroup_by(.user)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EYou should see that the results are now wrapped within an additional pair of \u003Ccode\u003E[]\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-json\\\"\u003E[\\n  [\\n    {\\n    &quot;contributors&quot;: null,\\n      &quot;truncated&quot;: false,\\n      &quot;text&quot;: &quot;RT @agabriew: -mamá, ¿puedo salir?\\\\n-no.\\\\n-pero todos mis amigos irán.\\\\n-¡no! http:\u002F\u002Ft.co\u002FZ9l3zEdUdH&quot;\\n      \u002F* ETC ... *\u002F\\n    }\\n  ]\\n  \u002F* More sub-arrays of tweets grouped by user... *\u002F\\n]\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EWe can now create a table of users.\\nLet&#39;s create a table with columns for the user id, user name, followers count, and a column of their tweet ids separated by a semicolon.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003Egroup_by(.user) | .[] | {user_id: .[0].user.id, user_name: .[0].user.screen_name, user_followers: .[0].user.followers_count, tweet_ids: [.[].id | tostring] | join(&quot;;&quot;)}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe results should look like:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-json\\\"\u003E{\\n  &quot;user_id&quot;: 1330235048,\\n  &quot;user_name&quot;: &quot;yourborwhore&quot;,\\n  &quot;user_followers&quot;: 1725,\\n  &quot;tweet_ids&quot;: &quot;619172326886674400&quot;\\n}\\n{\\n  &quot;user_id&quot;: 32537879,\\n  &quot;user_name&quot;: &quot;WonderWomanMind&quot;,\\n  &quot;user_followers&quot;: 199,\\n  &quot;tweet_ids&quot;: &quot;501064215990648800&quot;\\n}\\n{\\n  &quot;user_id&quot;: 558774130,\\n  &quot;user_name&quot;: &quot;Katyria90&quot;,\\n  &quot;user_followers&quot;: 202,\\n  &quot;tweet_ids&quot;: &quot;501064201256071200&quot;\\n}\\n\u002F* ETC ... *\u002F\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ELet&#39;s break down this complex filter:\u003C\u002Fp\u003E\\n\u003Col\u003E\\n\u003Cli\u003E\u003Ccode\u003Egroup_by(.user) |\u003C\u002Fcode\u003E This takes the big array of tweets and returns an array of sub-arrays, each sharing the exact same information in the \u003Ccode\u003Euser\u003C\u002Fcode\u003E key. Note that this works even when the value at the \u003Ccode\u003Euser\u003C\u002Fcode\u003E key is itself a JSON object wrapped in \u003Ccode\u003E{}\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E.[] |\u003C\u002Fcode\u003E Having created an array of sub-arrays, we want to break out the individual sub-arrays.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E{user_id: .[0].user.id, user_name: .[0].user.screen_name, user_followers: .[0].user.followers_count, tweet_ids: [.[].id | tostring] | join(&quot;;&quot;)}\u003C\u002Fcode\u003E This next bit creates a new set of JSON information, filling in keys and values with the following sub-commands:\u003Col\u003E\\n\u003Cli\u003E\u003Ccode\u003Euser_id: .[0].user.id,\u003C\u002Fcode\u003E This pulls the first tweet in the sub-array and access the user id, assigning it to the key \u003Ccode\u003Euser_id\u003C\u002Fcode\u003E in our new JSON object\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003Euser_name: .[0].user.screen_name,\u003C\u002Fcode\u003E This does the same for the user name.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003Euser_followers: .[0].user.followers_count,\u003C\u002Fcode\u003E This does the same for the number of followers the user has.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003Etweet_ids: [.[].id | tostring] | join(&quot;;&quot;)\u003C\u002Fcode\u003E This command collects all the different tweet ids associated with this user and sticks them into one string, delimited with \u003Ccode\u003E;\u003C\u002Fcode\u003E. How do we do that?\u003Col\u003E\\n\u003Cli\u003E\u003Ccode\u003E.[].id\u003C\u002Fcode\u003E While we know that the user id, name, and followers will be the same for every tweet the user makes, the tweet ids will be unique, so instead of using \u003Ccode\u003E.[0]\u003C\u002Fcode\u003E to get values from just the first tweet, we use \u003Ccode\u003E.[].id\u003C\u002Fcode\u003E here to get the ids of every single tweet in a user&#39;s sub-array.\u003C\u002Fli\u003E\\n\u003Cli\u003EThe command \u003Ccode\u003E| tostring\u003C\u002Fcode\u003E converts the tweet id numbers into strings that jq can then paste together with semicolons. \u003Ca href=\\\"#one-row-per-tweet\\\"\u003EWe didn&#39;t have to use this last time we used \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E to create a column of semicolon-delimited hashtags.\u003C\u002Fa\u003E Why? Because when we were making a column of hashtags, the original values were already text values wrapped in quotation marks. Tweet ids, on the other hand, are integers that are not wrapped in \u003Ccode\u003E&quot;&quot;\u003C\u002Fcode\u003E, Because jq can be very picky about data types, we need to convert our integers into strings before using the \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E command in the next step.\u003C\u002Fli\u003E\\n\u003Cli\u003EBoth of these commands are wrapped in \u003Ccode\u003E[]\u003C\u002Fcode\u003E which tells jq to collect every result into one single array, which is passed with a \u003Ccode\u003E|\u003C\u002Fcode\u003E along to:\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003Ejoin(&quot;;&quot;)\u003C\u002Fcode\u003E, which turns that array into one single character string, with semicolon delimiters between multiple tweet ids.\u003C\u002Fli\u003E\\n\u003C\u002Fol\u003E\\n\u003C\u002Fli\u003E\\n\u003C\u002Fol\u003E\\n\u003C\u002Fli\u003E\\n\u003C\u002Fol\u003E\\n\u003Cp\u003EThis filter created new JSON.\\nTo produce a CSV table from this, we just need to add an array construction and the \u003Ccode\u003E@csv\u003C\u002Fcode\u003E command at the end of this filter.\\nYou should recognize the way that we combine array construction and \u003Ccode\u003E@csv\u003C\u002Fcode\u003E \u003Ca href=\\\"#output-a-csv-csv\\\"\u003Efrom the earlier example of using \u003Ccode\u003E@csv\u003C\u002Fcode\u003E\u003C\u002Fa\u003E.\\nDon&#39;t forget to check both the &quot;Slurp&quot; and &quot;Raw Output&quot; options when creating a CSV table with jq:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003Egroup_by(.user) | .[] | {user_id: .[0].user.id, user_name: .[0].user.screen_name, user_followers: .[0].user.followers_count, tweet_ids: [.[].id | tostring] | join(&quot;;&quot;)} | [.user_id, .user_name, .user_followers, .tweet_ids] | @csv\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe results should start like this:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E1330235048,&quot;yourborwhore&quot;,1725,&quot;619172326886674400&quot;\\n32537879,&quot;WonderWomanMind&quot;,199,&quot;501064215990648800&quot;\\n558774130,&quot;Katyria90&quot;,202,&quot;501064201256071200&quot;\\n2944164937,&quot;mirogeorgiev97&quot;,946,&quot;619172162608463900&quot;\\n100951936,&quot;elbshari_abdo&quot;,114,&quot;619172278086070300&quot;\\n...\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EAlthough this table happens to start with users who only have one tweet each in these sample data, you can scroll down through the results to find several users who made multiple tweets.\u003C\u002Fp\u003E\\n\u003Ch4 id=\\\"counting-twitter-hashtags\\\"\u003ECounting Twitter hashtags\u003C\u002Fh4\u003E\\n\u003Cp\u003EIn the previous example we combined \u003Ccode\u003Egroup_by()\u003C\u002Fcode\u003E with \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E to collect multiple values into a text field.\\nHowever, we can also use \u003Ccode\u003Egroup_by()\u003C\u002Fcode\u003E in conjunction with \u003Ccode\u003Elength\u003C\u002Fcode\u003E to compute new values.\\nIn this final exercise, we will use jq to count the number of times unique hashtags appear in this dataset.\u003C\u002Fp\u003E\\n\u003Cp\u003EOnce again, make sure that the &quot;Slurp&quot; option is checked.\\n(However, uncheck the &quot;Raw Output&quot; option until we are ready to actually produce the final CSV output.)\\nCounterintuitively, the first thing we need to do to access the hashtags again is to break them \u003Cem\u003Eout\u003C\u002Fem\u003E of that large array:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E.[] | {id: .id, hashtag: .entities.hashtags} | {id: .id, hashtag: .hashtag[].text}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EAdding \u003Ccode\u003E.[]\u003C\u002Fcode\u003E at the beginning splits apart the large array created by the &quot;Slurp&quot; option.\\nThis is necessary because, while tweets can only have one user, they can have multiple hashtags.\\nThus, we need to fully break out all the possible hashtag values per tweet, and then collect that entire output back into an array inside \u003Ccode\u003E[]\u003C\u002Fcode\u003E, so that we can pass a single array into the \u003Ccode\u003Egroup_by()\u003C\u002Fcode\u003E function:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E[.[] | {id: .id, hashtag: .entities.hashtags} | {id: .id, hashtag: .hashtag[].text}] | group_by(.hashtag)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ENote the change at the start of the filter: the first two components are now wrapped in \u003Ccode\u003E[]\u003C\u002Fcode\u003E.\\nWe did a similar sort of wrapping in the previous section of this lesson.\\nWe also added the \u003Ccode\u003Egroup_by(.hashtag)\u003C\u002Fcode\u003E command at the end of the filter.\\nThe results:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-json\\\"\u003E[\\n  [\\n    {\\n      &quot;id&quot;: 619172232120692700,\\n      &quot;hashtag&quot;: &quot;Acquisition&quot;\\n    }\\n  ],\\n  [\\n    {\\n      &quot;id&quot;: 501064204288540700,\\n      &quot;hashtag&quot;: &quot;BLACKMEDIA&quot;\\n    }\\n  ],\\n  [\\n    {\\n      &quot;id&quot;: 619172293680345100,\\n      &quot;hashtag&quot;: &quot;BreakingNew&quot;\\n    }\\n  ]\\n  \u002F*ETC...*\u002F\\n]\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EIn the above query, tweet\u002Fhashtag pairs are grouped in to arrays based on the value of their \u003Ccode\u003Ehashtag\u003C\u002Fcode\u003E key.\\nTo count the number of times each hashtag is used, we only have to count the size of each of these sub-arrays.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E[.[] | {id: .id, hashtag: .entities.hashtags} | {id: .id, hashtag: .hashtag[].text}] | group_by(.hashtag) | .[] | {tag: .[0].hashtag, count: . | length} | [.tag, .count] | @csv\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe results:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E&quot;Acquisition&quot;,1\\n&quot;BLACKMEDIA&quot;,1\\n&quot;BreakingNew&quot;,1\\n&quot;CrimeButNoTime&quot;,1\\n&quot;Farrakhan&quot;,1\\n&quot;Ferguson&quot;,53\\n&quot;FergusonShooting&quot;,1\\n&quot;ForFreedom&quot;,1\\n&quot;FreeAmirNow&quot;,3\\n&quot;HandsUpDontShoot&quot;,1\\n\u002F*ETC...*\u002F\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003E(Remember, to format CSV output correctly, set jq to &quot;Raw Output&quot; using the \u003Ccode\u003E-r\u003C\u002Fcode\u003E flag on the command line, or check the &quot;Raw Output&quot; box on \u003Ca href=\\\"https:\u002F\u002Fjqplay.org\u002F\\\"\u003Ejq play\u003C\u002Fa\u003E.)\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003E.[]\u003C\u002Fcode\u003E once again breaks apart the large array, so we are left only with the sub-arrays within.\\nWe need to retrieve two pieces of information: first, the name of the hashtag for each sub-array, which we can get by accessing the value of the \u003Ccode\u003Ehashtag\u003C\u002Fcode\u003E key in the first tweet\u002Fhashtag combo of the array (accessed with \u003Ccode\u003E.[0]\u003C\u002Fcode\u003E).\\nSecond, we need to get the length of the array, accessed with \u003Ccode\u003E. | length\u003C\u002Fcode\u003E.\\nFinally, we create the CSV and format the CSV rows.\u003C\u002Fp\u003E\\n\u003Cp\u003ETo review:\u003C\u002Fp\u003E\\n\u003Col\u003E\\n\u003Cli\u003E\u003Ccode\u003E[.[] | {id: .id, hashtag: .entities.hashtags} | {id: .id, hashtag: .hashtag[].text}] |\u003C\u002Fcode\u003E This nested filter :\u003Col\u003E\\n\u003Cli\u003Ebreaks out individual tweet objects from the large array created by the &quot;Slurp&quot; option (\u003Ccode\u003E.[]\u003C\u002Fcode\u003E)\u003C\u002Fli\u003E\\n\u003Cli\u003Eretrieves the tweet id and hashtag text (\u003Ccode\u003E{id: .id, hashtag: .entities.hashtags} | {id: .id, hashtag: .hashtag[].text}\u003C\u002Fcode\u003E)\u003C\u002Fli\u003E\\n\u003Cli\u003EWraps both of those filters in \u003Ccode\u003E[]\u003C\u002Fcode\u003E in order to collect the results in one large array again.\u003C\u002Fli\u003E\\n\u003C\u002Fol\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003Egroup_by(.hashtag) |\u003C\u002Fcode\u003E Takes the large array from the previous step and sorts it into an array of arrays, each sub-array containing tweet objects sharing the same hashtag.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E.[] |\u003C\u002Fcode\u003E Break the large array produced by \u003Ccode\u003Egroup_by()\u003C\u002Fcode\u003E into its component sub-arrays.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E{tag: .[0].hashtag, count: . | length} |\u003C\u002Fcode\u003E Get the hashtag representing each sub-array by checking the hashtag value of the first member of each sub-array, and then count the size of each sub-array, effectively counting the number of tweets in which that hashtag was used.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E[.tag, .count] |\u003C\u002Fcode\u003E Create simple arrays with just the tag name and count\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E@csv\u003C\u002Fcode\u003E Format each array as a CSV row\u003C\u002Fli\u003E\\n\u003C\u002Fol\u003E\\n\u003Ch3 id=\\\"challenges\\\"\u003EChallenges\u003C\u002Fh3\u003E\\n\u003Cp\u003EThese final challenges will help you test your understanding of how to pipe together \u003Ca href=\\\"https:\u002F\u002Fstedolan.github.io\u002Fjq\u002F\\\"\u003Ejq\u003C\u002Fa\u003E commands on your own.\u003C\u002Fp\u003E\\n\u003Ch4 id=\\\"filter-before-counting\\\"\u003EFilter before counting\u003C\u002Fh4\u003E\\n\u003Cp\u003EWhat function do we need to add to the hashtag-counting filter to only count hashtags when their tweet has been retweeted at least 200 times?\\nHint: the retweet count is saved under the key \u003Ccode\u003Eretweet_count\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EYou should get the following table:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-txt\\\"\u003E&quot;CrimeButNoTime&quot;,1\\n&quot;Ferguson&quot;,14\\n&quot;FergusonShooting&quot;,1\\n&quot;MikeBrown&quot;,1\\n&quot;OpFerguson&quot;,1\\n&quot;RIPMikeBrown&quot;,1\\n&quot;justiceformikebrown&quot;,1\\n&quot;stl&quot;,1\\n&quot;vancouver&quot;,1\\n&quot;whiteprivilege&quot;,1\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003E\u003Ca href=\\\"\u002Fassets\u002Ffilter_retweets.txt\\\"\u003EThere are multiple ways to solve this with jq. See my answer here.\u003C\u002Fa\u003E\u003C\u002Fp\u003E\\n\u003Ch4 id=\\\"count-total-retweets-per-user\\\"\u003ECount total retweets per user\u003C\u002Fh4\u003E\\n\u003Cp\u003EOne more challenge to test your mastery of jq: from this dataset, try to compute the total number of times each user has had their tweets (at least within this dataset) retweeted.\u003C\u002Fp\u003E\\n\u003Cp\u003EHints:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003EYou should have a table with two columns: one for user id, and one for the total number of retweets. There should only be one row per user id.\u003C\u002Fli\u003E\\n\u003Cli\u003ESince we are looking at per-user statistics that cut accross individual tweets, we&#39;ll need to use \u003Ccode\u003Egroup_by()\u003C\u002Fcode\u003E and the &quot;Slurp&quot; option.\u003C\u002Fli\u003E\\n\u003Cli\u003EWe&#39;ve used a few functions that reduce an array of multiple values into one value: \u003Ccode\u003Elength\u003C\u002Fcode\u003E counts the number of values in an array, and \u003Ccode\u003Ejoin()\u003C\u002Fcode\u003E pastes those values together in one string. If you want to \u003Cem\u003Eadd\u003C\u002Fem\u003E numeric values together, though, \u003Ccode\u003Eadd\u003C\u002Fcode\u003E could be a promising function to try...\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003EAs a way to verify your results, user \u003Ccode\u003E356854246\u003C\u002Fcode\u003E should have a total retweet count of \u003Ccode\u003E51\u003C\u002Fcode\u003E based on this dataset.\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ca href=\\\"\u002Fassets\u002Fcount_retweets.txt\\\"\u003ESee my answer.\u003C\u002Fa\u003E\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"using-jq-on-the-command-line\\\"\u003EUsing jq on the command line\u003C\u002Fh2\u003E\\n\u003Cp\u003E\u003Ca href=\\\"https:\u002F\u002Fjqplay.org\u002F\\\"\u003Ejq play\u003C\u002Fa\u003E is fine when you have under 100-200 lines of JSON to parse.\\nHowever, it will become unusably slow on  much larger files.\\nFor fast processing of very large files, or of JSON lines spread across multiple files, you will need to run the command-line version of jq.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"installation\\\"\u003EInstallation\u003C\u002Fh2\u003E\\n\u003Ch3 id=\\\"installation-on-os-x\\\"\u003EInstallation on OS X\u003C\u002Fh3\u003E\\n\u003Cp\u003EThe easiest way to install jq on OS X is to use the package management system \u003Ca href=\\\"http:\u002F\u002Fbrew.sh\u002F\\\"\u003EHomebrew\u003C\u002Fa\u003E.\\nThis system works via OS X&#39;s &quot;Terminal&quot; application, which gives you access to the Bash command line.\\n\u003Ca href=\\\"\u002Flessons\u002Fintro-to-bash\\\"\u003EFor an introduction to this system, see The Programming Historian&#39;s &quot;Introduction to the Bash Command Line&quot;.\u003C\u002Fa\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EFollow the installation instructions for Homebrew itself, and then use this command to install jq:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-sh\\\"\u003Ebrew install jq\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Ch3 id=\\\"installation-on-windows\\\"\u003EInstallation on Windows\u003C\u002Fh3\u003E\\n\u003Cp\u003ETo access the command line easily on Windows, you will need the PowerShell application.\\n\u003Ca href=\\\"\u002Flessons\u002Fintro-to-powershell.html\\\"\u003ESee the Programming Historian&#39;s &quot;Introduction to PowerShell&quot;\u003C\u002Fa\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EFrom PowerShell, you can install the Windows package manager \u003Ca href=\\\"https:\u002F\u002Fchocolatey.org\u002Finstall\\\"\u003EChocolatey\u003C\u002Fa\u003E, and then install jq with the following command:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-sh\\\"\u003Echocolatey install jq\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Ch3 id=\\\"invoking-jq\\\"\u003EInvoking jq\u003C\u002Fh3\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-sh\\\"\u003Ejq -r &#39;.artObjects[] | [.id, .title, .principalOrFirstMaker, .webImage.url] | @csv&#39; jq_rkm.json &gt; jq_rkm.csv\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Col\u003E\\n\u003Cli\u003E\u003Ccode\u003Ejq\u003C\u002Fcode\u003E calls the jq program.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E-r\u003C\u002Fcode\u003E sets the &quot;Raw Output&quot; option.\u003C\u002Fli\u003E\\n\u003Cli\u003EThe actual filter text is placed between \u003Ccode\u003E&#39;&#39;\u003C\u002Fcode\u003E quotes.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003Ejq_rkm.json\u003C\u002Fcode\u003E indicates that jq should read JSON from the file \u003Ccode\u003Ejq_rkm.json\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E&gt; jq_rkm.csv\u003C\u002Fcode\u003E tells the command line to write jq&#39;s output into a file named \u003Ccode\u003Ejq_rkm.csv\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\\n\u003C\u002Fol\u003E\\n\u003Cp\u003EAlternatively, you can use bash pipes to send text from the output of one function into jq.\\nThis can be useful when downloading JSON with a utility like \u003Ccode\u003Ewget\u003C\u002Fcode\u003E for retrieving online material.\\n(See \u003Ca href=\\\"\u002Flessons\u002Fautomated-downloading-with-wget\\\"\u003EAutomated Downloading with Wget\u003C\u002Fa\u003E to learn the basics of this other command line program.)\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-sh\\\"\u003Ewget -qO- http:\u002F\u002Fprogramminghistorian.org\u002Fassets\u002Fjq_rkm.json | jq -r &#39;.artObjects[] | [.id, .title, .principalOrFirstMaker, .webImage.url] | @csv&#39;\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ENote that you must use the \u003Ccode\u003Ewget\u003C\u002Fcode\u003E flag \u003Ccode\u003E-qO-\u003C\u002Fcode\u003E in order to send the output of \u003Ccode\u003Ewget\u003C\u002Fcode\u003E into \u003Ccode\u003Ejq\u003C\u002Fcode\u003E by way of a shell pipe.\\nYou can read more about command line pipes in \u003Ca href=\\\"\u002Flessons\u002Fintro-to-bash\\\"\u003E&quot;Introduction to the Bash Command Line&quot;\u003C\u002Fa\u003E (OS X) or \u003Ca href=\\\"\u002Flessons\u002Fintro-to-powershell.html\\\"\u003E&quot;Introduction to PowerShell&quot;\u003C\u002Fa\u003E (Windows).\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"further-resources\\\"\u003EFurther Resources\u003C\u002Fh2\u003E\\n\u003Cp\u003Ejq is incredibly powerful, but its advanced features can get quite complicated.\u003C\u002Fp\u003E\\n\u003Cp\u003EIt is possible to do \u003Ca href=\\\"https:\u002F\u002Fstedolan.github.io\u002Fjq\u002Fmanual\u002F#Math\\\"\u003Eother basic math functions in jq\u003C\u002Fa\u003E, however given the complexity of working with JSON&#39;s tree data model, I would suggest that it is only worth doing the most basic counting operations in jq.\\nIf basic counting is all you need to do with your JSON data, then jq can help you avoid adding another tool onto your data analysis pipeline.\\nFor more involved math, however, it would be more sensible to create table(s) with jq and then continue your analysis in Python, R, or even Excel.\u003C\u002Fp\u003E\\n\u003Cp\u003EIf you are working with deeply-nested JSON (that is, many objects within objects), or JSON where objects have inconsistent structure, you may need to use features not covered in this lesson, including \u003Ca href=\\\"https:\u002F\u002Fstedolan.github.io\u002Fjq\u002Fmanual\u002F#if-then-else\\\"\u003Eif-then-else statements\u003C\u002Fa\u003E, \u003Ca href=\\\"https:\u002F\u002Fstedolan.github.io\u002Fjq\u002Fmanual\u002F#Recursion\\\"\u003Erecursion\u003C\u002Fa\u003E, and \u003Ca href=\\\"https:\u002F\u002Fstedolan.github.io\u002Fjq\u002Fmanual\u002F#Reduce\\\"\u003Ereduction\u003C\u002Fa\u003E.\\nIf you can&#39;t figure out the filter you need to go from your given input to your desired output, using the tag \u003Ccode\u003Ejq\u003C\u002Fcode\u003E over at \u003Ca href=\\\"http:\u002F\u002Fstackoverflow.com\u002Fquestions\u002Ftagged\u002Fjq\\\"\u003EStackOverflow\u003C\u002Fa\u003E can often get you a speedy answer.\\nMake sure that you try to \u003Ca href=\\\"http:\u002F\u002Fstackoverflow.com\u002Fhelp\u002Fhow-to-ask\\\"\u003Efollow best practices when describing your problem\u003C\u002Fa\u003E and provide a \u003Ca href=\\\"http:\u002F\u002Fstackoverflow.com\u002Fhelp\u002Fmcve\\\"\u003Ereproducible example\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\\n\"}"}</script></div>
	</body>
</html>
