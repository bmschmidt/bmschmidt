{"metadata":{"title":"Basic Text Processing in R\n","authors":["Taylor Arnold","Lauren Tilton"],"date":"2017-03-27T00:00:00.000Z","tested_date":"2021-10-21T00:00:00.000Z","reviewers":["Brandon Walsh","John Russell"],"review-ticket":"https://github.com/programminghistorian/ph-submissions/issues/34","editors":["Jeri Wieringa"],"difficulty":2,"layout":"lesson","activity":"analyzing","topics":["distant-reading"],"abstract":"Learn how to use R to analyze high-level patterns in texts, apply stylometric methods over time and across authors, and use summary methods to describe items in a corpus.\n","redirect_from":"/lessons/basic-text-processing-in-r","avatar_alt":"Children visiting a mobile book-mobile","doi":"10.46430/phen0061"},"html_body":"<p>{% include toc.html %}</p>\n<h1 id=\"learning-goals\">Learning Goals</h1>\n<p>A substantial amount of historical data is now available in the form of raw, digitized text. Common examples include letters, newspaper articles, personal notes, diary entries, legal documents and transcribed speeches. While some stand-alone software applications provide tools for analyzing text data, a programming language offers increased flexibility to analyze a corpus of text documents. In this tutorial we guide users through the basics of text analysis within the R programming language. The approach we take involves only using a tokenizer that parses text into elements such as words, phrases and sentences. By the end of the lesson users will be able to:</p>\n<ul>\n<li>employ exploratory analyses to check for errors and detect high-level patterns;</li>\n<li>apply basic stylometric methods over time and across authors;</li>\n<li>approach document summarization to provide a high-level description of the\nelements in a corpus.</li>\n</ul>\n<p>All of these will be demonstrated on a dataset from the text of United States Presidential State of the Union Addresses.[^2]</p>\n<p>We assume that users have only a very basic understanding of the R programming language. The <a href=\"/lessons/r-basics-with-tabular-data\">&#39;R Basics with Tabular Data&#39; lesson by Taryn Dewar</a>[^1] is an excellent guide that covers all of the R knowledge assumed here, such as installing and starting R, installing and loading packages, importing data and working with basic R data. Users can download R for their operating system from <a href=\"https://cran.r-project.org/\">The Comprehensive R Archive Network</a>. Though not required, we also recommend that new users download <a href=\"https://www.rstudio.com/products/rstudio/#Desktop\">RStudio</a>, an open source development environment for writing and executing R programs.</p>\n<p>All of the code in this lesson was tested in R version 3.3.2, though we expect it to run properly on any future version of the software.</p>\n<h1 id=\"a-small-example\">A Small Example</h1>\n<h2 id=\"package-set-up\">Package Set-up</h2>\n<p>Two R packages need to be installed before moving on through the tutorial. These are <strong>tidyverse</strong>[^8] and <strong>tokenizers</strong>.[^9] The first provides convenient tools for reading in and working with data sets, and the second contains the functions that allow us to split text data into words and sentences. To install these, simply start R on your computer and run the following two lines in the console:</p>\n<pre><code class=\"language-{r}\">install.packages(&quot;tidyverse&quot;)\ninstall.packages(&quot;tokenizers&quot;)\n</code></pre>\n<p>Depending on your system setup, these may open a dialog box asking you to choose a mirror to download from. Select one near your current location. The download and installation should follow automatically.</p>\n<p>Now that these packages are downloaded to your machine, we need to tell R that these packages should also be loaded for use. We do this via the <code>library</code> command; some warnings may be printed out as other dependencies are loaded, but can usually be safely ignored.</p>\n<pre><code class=\"language-{r}\">library(tidyverse)\nlibrary(tokenizers)\n</code></pre>\n<p>While the <code>install.packages</code> command will only need to be run the very first time\nyou use this tutorial, the <code>library</code> commands must be run each and every time you\nrestart R.</p>\n<h2 id=\"word-tokenization\">Word Tokenization</h2>\n<p>In this section, we will work with a single paragraph of text. The\nexample here is a paragraph from the opening of Barack Obama&#39;s final State of the Union address in 2016.</p>\n<p>To read this into R, copy and paste the following into the R console.</p>\n<pre><code class=\"language-{r}\">text &lt;- paste(&quot;Now, I understand that because it&#39;s an election season&quot;,\n          &quot;expectations for what we will achieve this year are low.&quot;,\n          &quot;But, Mister Speaker, I appreciate the constructive approach&quot;,\n          &quot;that you and other leaders took at the end of last year&quot;,\n          &quot;to pass a budget and make tax cuts permanent for working&quot;,\n          &quot;families. So I hope we can work together this year on some&quot;,\n          &quot;bipartisan priorities like criminal justice reform and&quot;,\n          &quot;helping people who are battling prescription drug abuse&quot;,\n          &quot;and heroin abuse. So, who knows, we might surprise the&quot;,\n          &quot;cynics again&quot;)\n</code></pre>\n<p>After running this, type <code>text</code> in the console and hit enter. R will print\nout the paragraph of text verbatim because the variable &#39;text&#39; now stores the document inside it.</p>\n<p>As a first step in processing this text, we will use the <code>tokenize_words</code> function\nfrom the <strong>tokenizers</strong> package to split the text into individual words.</p>\n<pre><code class=\"language-{r}\">words &lt;- tokenize_words(text)\n</code></pre>\n<p>To print out the results to your R console window, giving both the tokenized output as well as a counter showing the position of each token in the left hand margin, enter <code>words</code> into the console:</p>\n<pre><code class=\"language-{r}\">words\n</code></pre>\n<p>Which gives the following output:</p>\n<pre><code>[[1]]\n [1] &quot;now&quot;          &quot;i&quot;            &quot;understand&quot;   &quot;that&quot;         &quot;because&quot;\n [6] &quot;it&#39;s&quot;         &quot;an&quot;           &quot;election&quot;     &quot;season&quot;       &quot;expectations&quot;\n[11] &quot;for&quot;          &quot;what&quot;         &quot;we&quot;           &quot;will&quot;         &quot;achieve&quot;\n[16] &quot;this&quot;         &quot;year&quot;         &quot;are&quot;          &quot;low&quot;          &quot;but&quot;\n[21] &quot;mister&quot;       &quot;speaker&quot;      &quot;i&quot;            &quot;appreciate&quot;   &quot;the&quot;\n[26] &quot;constructive&quot; &quot;approach&quot;     &quot;that&quot;         &quot;you&quot;          &quot;and&quot;\n[31] &quot;other&quot;        &quot;leaders&quot;      &quot;took&quot;         &quot;at&quot;           &quot;the&quot;\n[36] &quot;end&quot;          &quot;of&quot;           &quot;last&quot;         &quot;year&quot;         &quot;to&quot;\n[41] &quot;pass&quot;         &quot;a&quot;            &quot;budget&quot;       &quot;and&quot;          &quot;make&quot;\n[46] &quot;tax&quot;          &quot;cuts&quot;         &quot;permanent&quot;    &quot;for&quot;          &quot;working&quot;\n[51] &quot;families&quot;     &quot;so&quot;           &quot;i&quot;            &quot;hope&quot;         &quot;we&quot;\n[56] &quot;can&quot;          &quot;work&quot;         &quot;together&quot;     &quot;this&quot;         &quot;year&quot;\n[61] &quot;on&quot;           &quot;some&quot;         &quot;bipartisan&quot;   &quot;priorities&quot;   &quot;like&quot;\n[66] &quot;criminal&quot;     &quot;justice&quot;      &quot;reform&quot;       &quot;and&quot;          &quot;helping&quot;\n[71] &quot;people&quot;       &quot;who&quot;          &quot;are&quot;          &quot;battling&quot;     &quot;prescription&quot;\n[76] &quot;drug&quot;         &quot;abuse&quot;        &quot;and&quot;          &quot;heroin&quot;       &quot;abuse&quot;\n[81] &quot;so&quot;           &quot;who&quot;          &quot;knows&quot;        &quot;we&quot;           &quot;might&quot;\n[86] &quot;surprise&quot;     &quot;the&quot;          &quot;cynics&quot;       &quot;again&quot;\n</code></pre>\n<p>How has the R function changed the input text? It has removed all of the punctuation, split the text into individual words, and converted everything into lowercase characters. We will see shortly why all of these interventions are useful in our analysis.</p>\n<p>How many words are there in this short snippet of text? If we use the <code>length</code> function directly on the <code>words</code> object, the result is not particularly useful.</p>\n<pre><code class=\"language-{r}\">length(words)\n</code></pre>\n<p>With output equal to:</p>\n<pre><code class=\"language-{r}\">[1] 1\n</code></pre>\n<p>The reason that the length is equal to 1 is that the function <code>tokenize_words</code>\nreturns a list object with one entry per document in the input. Our input only has a single document and therefore the list only has one element. To see the words <em>inside</em> the first document, we use the symbol <code>[[1]]</code> to select just the first element of the list:</p>\n<pre><code class=\"language-{r}\">length(words[[1]])\n</code></pre>\n<p>The result is <code>89</code>, indicating that there are 89 words in this\nparagraph of text.</p>\n<p>The separation of the document into individual words makes it possible to see how many times each word was used in the text. To do so, we first apply the\n<code>table</code> function to the words in the first (and here, only) document and then split\napart the names and values of the table into a single object called a data frame.\nData frames in R are used similarly to the way a table is used in a database.\nThese steps, along with printing out the result, are accomplished by the following\nlines of code:</p>\n<pre><code class=\"language-{r}\">tab &lt;- table(words[[1]])\ntab &lt;- data_frame(word = names(tab), count = as.numeric(tab))\ntab\n</code></pre>\n<p>The output from this command should look like this in your console (a tibble is a specific variety of a data frame created by the <strong>tidydata</strong> package):</p>\n<pre><code># A tibble: 71 × 2\n         word count\n        &lt;chr&gt; &lt;dbl&gt;\n1           a     1\n2       abuse     2\n3     achieve     1\n4       again     1\n5          an     1\n6         and     4\n7  appreciate     1\n8    approach     1\n9         are     2\n10         at     1\n# ... with 61 more rows\n</code></pre>\n<p>There is substantial amount of information in this display. We see that there are 71 unique words, as given by the dimensions of the table at the top. The first 10 rows of the dataset are printed, with the second column showing how many times the word in the first column was used. For example, &quot;and&quot; was used 4 times but &quot;achieve&quot; was used only once.</p>\n<p>We can also sort the table using the <code>arrange</code> function. The arrange function takes the dataset to be worked on, here <code>tab</code>, and then the name of the column to arrange by. The <code>desc</code> function in the second argument indicates that we want to sort in <em>desc</em>ending order.</p>\n<pre><code class=\"language-{r}\">arrange(tab, desc(count))\n</code></pre>\n<p>And the output will now be:</p>\n<pre><code class=\"language-{r}\"># A tibble: 71 × 2\n    word count\n   &lt;chr&gt; &lt;dbl&gt;\n1    and     4\n2      i     3\n3    the     3\n4     we     3\n5   year     3\n6  abuse     2\n7    are     2\n8    for     2\n9     so     2\n10  that     2\n# ... with 61 more rows\n</code></pre>\n<p>The most common words are pronouns and functions words such as &quot;and&quot;, &quot;i&quot;, &quot;the&quot;, and &quot;we&quot;. Notice how taking the lower-case version of every word helps in the analysis here. The word &quot;We&quot; at the start of the sentence is not treated differently than the &quot;we&quot; in the middle of a sentence.</p>\n<p>A popular technique is to maintain a list of highly used words and removing these prior to any formal analysis. The words on such a list are called &quot;stopwords&quot;, and usually include words such as pronouns, conjugations of the most common verbs, and conjunctions. In this tutorial we will use a nuanced variation of this technique.</p>\n<h2 id=\"detecting-sentence-boundaries\">Detecting Sentence Boundaries</h2>\n<p>The <strong>tokenizer</strong> package also supplies the function <code>tokenize_sentences</code> that splits a text into sentences rather than words. It can be applied as follows:</p>\n<pre><code class=\"language-{r}\">sentences &lt;- tokenize_sentences(text)\nsentences\n</code></pre>\n<p>With output:</p>\n<pre><code class=\"language-{r}\">&gt; sentences\n[[1]]\n[1] &quot;Now, I understand that because it&#39;s an election season expectations for what we will achieve this year are low.&quot;\n[2] &quot;But, Mister Speaker, I appreciate the constructive approach that you and other leaders took at the end of last year to pass a budget and make tax cuts permanent for working families.&quot;\n[3] &quot;So I hope we can work together this year on some bipartisan priorities like criminal justice reform and helping people who are battling prescription drug abuse and heroin abuse.&quot;\n[4] &quot;So, who knows, we might surprise the cynics again&quot;\n</code></pre>\n<p>The output is given as a character vector, a one-dimensional R object consisting only of elements represented as characters. Notice that the output pushed each sentence into a separate element.</p>\n<p>It is possible to pair the output of the sentence tokenizer with the word tokenizer. If we pass the sentences split from the paragraph to the <code>tokenize_words</code> function, each sentence gets treated as its own document. Apply this using the following line of code and see whether the output looks as you would have expected it, using the second line to print the object.</p>\n<pre><code class=\"language-{r}\">sentence_words &lt;- tokenize_words(sentences[[1]])\nsentence_words\n</code></pre>\n<p>Checking the size of the output directly, we can see that there are four &quot;documents&quot; in the object <code>sentence_words</code>:</p>\n<pre><code class=\"language-{r}\">length(sentence_words)\n</code></pre>\n<p>Accessing each directly, it is possible to figure out how many words are in each sentence of the paragraph:</p>\n<pre><code class=\"language-{r}\">length(sentence_words[[1]])\nlength(sentence_words[[2]])\nlength(sentence_words[[3]])\nlength(sentence_words[[4]])\n</code></pre>\n<p>This can become quite cumbersome, but fortunately there is an easier way. The <code>sapply</code> function applies its second argument to every element of its first argument. As a result, we can calculate the length of every sentence in the paragraph with one line of code:</p>\n<pre><code class=\"language-{r}\">sapply(sentence_words, length)\n</code></pre>\n<p>The output will now look like this:</p>\n<pre><code class=\"language-{r}\">[1] 19 32 29  9\n</code></pre>\n<p>We can see that we have four sentences that are length 19, 32, 29 and 9. We will\nuse this function to manage larger documents.</p>\n<h1 id=\"analyzing-barack-obamas-2016-state-of-the-union-address\">Analyzing Barack Obama&#39;s 2016 State of the Union Address</h1>\n<h2 id=\"exploratory-analysis\">Exploratory Analysis</h2>\n<p>Let us now apply the techniques from the previous section to an entire State of the Union address. For consistency, we will use the same 2016 Obama speech. Here we will load the data in from a file as copying directly becomes too difficult at scale.</p>\n<p>To do so, we will combine the <code>readLines</code> function to read the text into R and the <code>paste</code> function to combine all of the lines into a single object. We will build the URL of the text file using the <code>sprintf</code> function as this format will make it easily modified to grab other addresses.[^3]</p>\n<pre><code class=\"language-{r}\">base_url &lt;- &quot;https://programminghistorian.org/assets/basic-text-processing-in-r&quot;\nurl &lt;- sprintf(&quot;%s/sotu_text/236.txt&quot;, base_url)\ntext &lt;- paste(readLines(url), collapse = &quot;\\n&quot;)\n</code></pre>\n<p>As before, we will tokenize the text and see how many word there are in the\nentire document.</p>\n<pre><code class=\"language-{r}\">words &lt;- tokenize_words(text)\nlength(words[[1]])\n</code></pre>\n<p>From the output we see that this speech contains a total of <code>6113</code> words. Combining the <code>table</code>, <code>data_frame</code>, and <code>arrange</code> functions exactly as we did on the small example, shows the most frequently used words in the entire speech. Notice as you run this how easily we are able to re-use our prior code to repeat an analysis on a new set of data; this is one of the strongest benefits of using a programming language to run a data-based analysis.</p>\n<pre><code class=\"language-{r}\">tab &lt;- table(words[[1]])\ntab &lt;- data_frame(word = names(tab), count = as.numeric(tab))\ntab &lt;- arrange(tab, desc(count))\ntab\n</code></pre>\n<p>The output here should look like this:</p>\n<pre><code class=\"language-{r}\"># A tibble: 1,590 × 2\n    word count\n   &lt;chr&gt; &lt;dbl&gt;\n1    the   281\n2     to   209\n3    and   189\n4     of   148\n5   that   125\n6     we   124\n7      a   120\n8     in   105\n9    our    96\n10    is    72\n# ... with 1,580 more rows\n</code></pre>\n<p>Once again, extremely common words such as &quot;the&quot;, &quot;to&quot;, &quot;and&quot;, and &quot;of&quot; float to the top of the table. These terms are not particularly insightful for determining the content of the speech. Instead, we want to find words that are represented much more often in this text than over a large external corpus of English. To accomplish this we need a dataset giving these frequencies. Here is a dataset from Peter Norvig using the Google Web Trillion Word Corpus, collected from data gathered via Google&#39;s crawling of known English websites:[^4]</p>\n<pre><code class=\"language-{r}\">wf &lt;- read_csv(sprintf(&quot;%s/%s&quot;, base_url, &quot;word_frequency.csv&quot;))\nwf\n</code></pre>\n<p>The first column lists the language (always &quot;en&quot; for English in this case), the second gives the word and the third the percentage of the Trillion Word Corpus consisting of the given word. For example, the word &quot;for&quot; occurs almost exactly in 1 out of every 100 words, at least for text on websites indexed by Google.</p>\n<p>To combine these overall word frequencies with the dataset <code>tab</code> constructed from this one State of the Union speech, we can utilize the <code>inner_join</code> function. This function takes two data sets and combines them on all commonly named columns; in this case the common column is the one named &quot;word&quot;.</p>\n<pre><code class=\"language-{r}\">tab &lt;- inner_join(tab, wf)\ntab\n</code></pre>\n<p>Notice that our dataset now has two extra columns giving the language (relatively\nunhelpful as this is always equal to &quot;en&quot;) and the frequency of the word over a large external corpus. This second new column will be very helpful as we can filter for rows that have a frequency less than 0.1%, that is, occurring more than once in every 1000 words.</p>\n<pre><code class=\"language-{r}\">filter(tab, frequency &lt; 0.1)\n</code></pre>\n<p>Which outputs the following:</p>\n<pre><code class=\"language-{r}\"># A tibble: 1,457 × 4\n       word count language  frequency\n      &lt;chr&gt; &lt;dbl&gt;    &lt;chr&gt;      &lt;dbl&gt;\n1   america    28       en 0.02316088\n2    people    27       en 0.08166699\n3      just    25       en 0.07869701\n4     world    23       en 0.07344269\n5  american    22       en 0.03868825\n6      work    22       en 0.07132574\n7      make    20       en 0.06887739\n8      want    19       en 0.04398566\n9    change    18       en 0.03580897\n10    years    18       en 0.05744387\n# ... with 1,447 more rows\n</code></pre>\n<p>This list is starting to look a bit more interesting. A term such as &quot;america&quot; floats\nto the top because we might speculate that it is used a lot in speeches by politicians, but relatively less so in other domains. Setting the threshold even lower, to 0.002, gives an even better summary of the speech. It will be useful to see more than the default first ten lines here, so we will use the <code>print</code> function along with the option <code>n</code> set to 15 in order to print out more than the default 10 values.</p>\n<pre><code class=\"language-{r}\">print(filter(tab, frequency &lt; 0.002), n = 15)\n</code></pre>\n<p>Which now gives the following result:</p>\n<pre><code class=\"language-{r}\"># A tibble: 463 × 4\n          word count language    frequency\n         &lt;chr&gt; &lt;dbl&gt;    &lt;chr&gt;        &lt;dbl&gt;\n1     laughter    11       en 0.0006433418\n2       voices     8       en 0.0018923179\n3       allies     4       en 0.0008442300\n4       harder     4       en 0.0015197009\n5        qaida     4       en 0.0001831486\n6   terrorists     4       en 0.0012207035\n7   bipartisan     3       en 0.0001451991\n8  generations     3       en 0.0012275704\n9        stamp     3       en 0.0016595929\n10   strongest     3       en 0.0005913999\n11       syria     3       en 0.0013626227\n12   terrorist     3       en 0.0018103454\n13     tougher     3       en 0.0002466358\n14      weaken     3       en 0.0001806348\n15  accelerate     2       en 0.0005439790\n# ... with 448 more rows\n</code></pre>\n<p>Now, these seem to suggest some of the key themes of the speech such as &quot;syria&quot;, &quot;terrorist&quot;, and &quot;qaida&quot; (al-qaida is split into &quot;al&quot; and &quot;qaida&quot; by the tokenizer).</p>\n<h2 id=\"document-summarization\">Document Summarization</h2>\n<p>To supply contextual information for the dataset we are analyzing we have provided a table with metadata about each State of the Union speech. Let us read that into R now:</p>\n<pre><code class=\"language-{r}\">metadata &lt;- read_csv(sprintf(&quot;%s/%s&quot;, base_url, &quot;metadata.csv&quot;))\nmetadata\n</code></pre>\n<p>The first ten rows of the dataset will be printed; they should look like this:</p>\n<pre><code class=\"language-{r}\"># A tibble: 236 × 4\n           president  year       party sotu_type\n               &lt;chr&gt; &lt;int&gt;       &lt;chr&gt;     &lt;chr&gt;\n1  George Washington  1790 Nonpartisan    speech\n2  George Washington  1790 Nonpartisan    speech\n3  George Washington  1791 Nonpartisan    speech\n4  George Washington  1792 Nonpartisan    speech\n5  George Washington  1793 Nonpartisan    speech\n6  George Washington  1794 Nonpartisan    speech\n7  George Washington  1795 Nonpartisan    speech\n8  George Washington  1796 Nonpartisan    speech\n9         John Adams  1797  Federalist    speech\n10        John Adams  1798  Federalist    speech\n# ... with 226 more rows\n</code></pre>\n<p>For each speech we have the president, the year, the president&#39;s party, and whether the State of the Union was given as a speech or as a written address. The 2016 speech is the 236th row of the metadata data, which is also the last one.</p>\n<p>It will be useful in the next section to be able to summarize an address in just a single line of text. We can do that here by extracting the top five most used words that have a frequency less than 0.002% in the Google Web Corpus, and combining this with the president and year.</p>\n<pre><code class=\"language-{r}\">tab &lt;- filter(tab, frequency &lt; 0.002)\nresult &lt;- c(metadata$president[236], metadata$year[236], tab$word[1:5])\npaste(result, collapse = &quot;; &quot;)\n</code></pre>\n<p>This should give the following line as an output:</p>\n<pre><code>[1] &quot;Barack Obama; 2016; laughter; voices; allies; harder; qaida&quot;\n</code></pre>\n<p>Does this line capture everything in the speech? Of course not. Text processing will never replace doing a close reading of a text, but it does help to give a high level summary of the themes discussed (laughter come from notations of audience laughter in the speech text). This summary is useful in several ways. It may give a good ad-hoc title and abstract for a document that has neither; it may serve to remind readers who have read or listened to a speech what exactly the key points discussed were; taking many summaries together at once may elucidate large-scale patterns that get lost over a large corpus. It is this last application that we turn to now as we apply the techniques from this section to the large set of State of the Union addresses.</p>\n<h1 id=\"analyzing-every-state-of-the-union-address-from-1790-to-2016\">Analyzing Every State of the Union Address from 1790 to 2016</h1>\n<h2 id=\"loading-the-corpus\">Loading the Corpus</h2>\n<p>The first step in analyzing the entire State of the Union corpus is to read all of the\naddresses into R together. This involves the same <code>paste</code> and <code>readLines</code> functions as before, but we must put this function in a <code>for</code> loop that applies it over each of the 236 text files. These are combined using the <code>c</code> function.</p>\n<pre><code class=\"language-{r}\">files &lt;- sprintf(&quot;%s/sotu_text/%03d.txt&quot;, base_url, 1:236)\ntext &lt;- c()\nfor (f in files) {\n  text &lt;- c(text, paste(readLines(f), collapse = &quot;\\n&quot;))\n}\n</code></pre>\n<p>This technique loads all of the files one by one off of GitHub. Optionally, you can download a zip file of the entire corpus and read these files in manually. This technique is described in the next section.</p>\n<h2 id=\"alternative-method-for-loading-the-corpus-optional\">Alternative Method for Loading the Corpus (Optional)</h2>\n<p>The entire corpus can be downloaded from here: <a href=\"/assets/basic-text-processing-in-r/sotu_text.zip\">sotu_text.zip</a>. Unzip the repository somewhere on your machine and set the variable <code>input_loc</code> to the full path of the directory where your unzipped file is. For example, if the file is on the desktop of a computer running macOS and the username is stevejobs, <code>input_loc</code> should be set to:</p>\n<pre><code class=\"language-{r}\">input_loc &lt;- &quot;/Users/stevejobs/Desktop/sotu_text&quot;\n</code></pre>\n<p>Once this is done, the following code block can be used to read in all of the texts:</p>\n<pre><code class=\"language-{r}\">files &lt;- dir(input_loc, full.names = TRUE)\ntext &lt;- c()\nfor (f in files) {\n  text &lt;- c(text, paste(readLines(f), collapse = &quot;\\n&quot;))\n}\n</code></pre>\n<p>This same technique can be used to read in your own corpus of text.</p>\n<h2 id=\"exploratory-analysis-1\">Exploratory Analysis</h2>\n<p>Once again calling the <code>tokenize_words</code> function, we now see the length of each address in total number of words.</p>\n<pre><code class=\"language-{r}\">words &lt;- tokenize_words(text)\nsapply(words, length)\n</code></pre>\n<p>Is there a temporal pattern to the length of addresses? How do the lengths of the past several administration&#39;s speeches compare to those of FDR, Abraham Lincoln, and George Washington?</p>\n<p>The best way to see this is by using a scatter plot. You can construct one by using the <code>qplot</code> function, putting the year on the x-axis and the length in words on the y-axis.</p>\n<pre><code class=\"language-{r}\">qplot(metadata$year, sapply(words, length))\n</code></pre>\n<p>This will produce a plot similar to this one:</p>\n<p>{% include figure.html filename=&quot;sotu-number-of-words.jpg&quot; caption=&quot;Number of words in each State of the Union Address plotted by year.&quot; %}</p>\n<p>It seems that for the most part addresses steadily increased in length from 1790 to around 1850, and then increase again until the end of the 19th century. The length dramatically decreased around World War I, with a handful of fairly large outliers scattered throughout the 20th century.</p>\n<p>Is there any rational behind these changes? Setting the color of the points\nto denote whether a speech is written or delivered orally explains a large part of the variation. The command to do this plot is only a small tweak on our other plotting command:</p>\n<pre><code class=\"language-{r}\">qplot(metadata$year, sapply(words, length),\n      color = metadata$sotu_type)\n</code></pre>\n<p>This yields the following plot:</p>\n<p>{% include figure.html filename=&quot;sotu-number-of-words-and-type.jpg&quot; caption=&quot;Number of words in each State of the Union Address plotted by year, with color denoting whether it was a written or oral message.&quot; %}</p>\n<p>We see that the rise in the 19th century occurred when the addresses switched to written documents, and the dramatic drop comes when Woodrow Wilson broke tradition and gave his State of the Union as a speech in Congress. The outliers we saw previously were all written addresses given after the end of World War II .</p>\n<h2 id=\"stylometric-analysis\">Stylometric Analysis</h2>\n<p>Stylometry, the study of linguistic style, makes extensive use of computational methods to describe the style of an author&#39;s writing. With our corpus, it is possible to detect changes in writing style over the course of the 19th and 20th centuries. A more formal stylometric analysis would usually entail the application of part of speech codes or complex, dimensionality reduction algorithms such as principal component analysis to study patterns over time of across authors. For this tutorial we will stick to studying sentence length.</p>\n<p>The corpus can be split into sentences using the <code>tokenize_sentences</code> function. In this case the result is a list with 236 items in it, each representing a specific\ndocument.</p>\n<pre><code class=\"language-{r}\">sentences &lt;- tokenize_sentences(text)\n</code></pre>\n<p>Next, we want to split each of these sentences into words. The <code>tokenize_words</code> may be used, but not directly on the list object <code>sentences</code>. It would be possible to do this with a <code>for</code> loop again, but there is an easier way. The <code>sapply</code> function provides a more straightforward approach. Here, we want to apply the word tokenizer individually to each document, and so this function works perfectly.</p>\n<pre><code class=\"language-{r}\">sentence_words &lt;- sapply(sentences, tokenize_words)\n</code></pre>\n<p>We now have a list (with each element representing a document) of lists (with each element representing the words in a given sentence). The output we need is a list object giving the length of each sentence in a given document. To do this, we now combine a <code>for</code> loop with the <code>sapply</code> function.</p>\n<pre><code class=\"language-{r}\">sentence_length &lt;- list()\nfor (i in 1:nrow(metadata)) {\n  sentence_length[[i]] &lt;- sapply(sentence_words[[i]], length)\n}\n</code></pre>\n<p>The output of <code>sentence_length</code> may be visualized over time. We first need to summarize all of the sentence lengths within a document to a single number. The <code>median</code> function, which finds the 50th percentile of its inputs, is a good choice for summarizing these as it will not be overly effected by a parsing error that may mistakenly create an artificially long sentence.[^5]</p>\n<pre><code class=\"language-{r}\">sentence_length_median &lt;- sapply(sentence_length, median)\n</code></pre>\n<p>We now plot this variable against the speech year using, once again, the <code>qplot</code> function.</p>\n<pre><code class=\"language-{r}\">qplot(metadata$year, sentence_length_median)\n</code></pre>\n<p>{% include figure.html filename=&quot;sotu-sentence-length.jpg&quot; caption=&quot;Median sentence length for each State of the Union Address.&quot; %}</p>\n<p>The plot shows a strong general trend in shorter sentences over the two centuries of our corpus. Recall that a few addresses in the later half of the 20th century were long, written addresses much like those of the 19th century. It is particularly interesting that these do not show up in terms of the median sentence length. This points out at least one way in which the State of the Union addresses have been changed and adapted over time.</p>\n<p>To make the pattern even more explicit, it is possible to add a smoothing line over the plot with the function <code>geom_smooth</code>.</p>\n<pre><code class=\"language-{r}\">qplot(metadata$year, sentence_length_median) +\n  geom_smooth()\n</code></pre>\n<p>{% include figure.html filename=&quot;sotu-sentence-length-smooth.jpg&quot; caption=&quot;Median sentence length for each State of the Union Address, with a smoothing line.&quot; %}</p>\n<p>Smoothing lines are a great addition to many plots. They have a dual purpose of picking out the general trend of time series data, while also highlighting any outlying data points.</p>\n<h2 id=\"document-summarization-1\">Document Summarization</h2>\n<p>As a final task, we want to apply the one-line summarization function we used in the previous section to each of the documents in this larger corpus. This again requires the use of a for loop, but the inner code stays largely the same with the exception of needing to save the results as an element of the vector <code>description</code>.</p>\n<pre><code class=\"language-{r}\">description &lt;- c()\nfor (i in 1:length(words)) {\n  tab &lt;- table(words[[i]])\n  tab &lt;- data_frame(word = names(tab), count = as.numeric(tab))\n  tab &lt;- arrange(tab, desc(count))\n  tab &lt;- inner_join(tab, wf)\n  tab &lt;- filter(tab, frequency &lt; 0.002)\n\n  result &lt;- c(metadata$president[i], metadata$year[i], tab$word[1:5])\n  description &lt;- c(description, paste(result, collapse = &quot;; &quot;))\n}\n</code></pre>\n<p>This will print out a line that says <strong>Joining, by = &quot;word&quot;</strong> as each file is processed as a result of the <code>inner_join</code> function. As the loop may take a minute or more to run, this is a helpful way of being sure that the code is actually processing the files as we wait for it to finish. We can see the output of our loop by simply typing <code>description</code> in the console, but a slightly cleaner view is given through the use of the <code>cat</code> function.</p>\n<pre><code class=\"language-{r}\">cat(description, sep = &quot;\\n&quot;)\n</code></pre>\n<p>The results yield one row for each State of the Union. Here, for example, are the lines from the Bill Clinton, George W. Bush, and Barack Obama administrations:</p>\n<pre><code>William J. Clinton; 1993; deficit; propose; incomes; invest; decade\nWilliam J. Clinton; 1994; deficit; renew; ought; brady; cannot\nWilliam J. Clinton; 1995; ought; covenant; deficit; bureaucracy; voted\nWilliam J. Clinton; 1996; bipartisan; gangs; medicare; deficit; harder\nWilliam J. Clinton; 1997; bipartisan; cannot; balanced; nato; immigrants\nWilliam J. Clinton; 1998; bipartisan; deficit; propose; bosnia; millennium\nWilliam J. Clinton; 1999; medicare; propose; surplus; balanced; bipartisan\nWilliam J. Clinton; 2000; propose; laughter; medicare; bipartisan; prosperity\nGeorge W. Bush; 2001; medicare; courage; surplus; josefina; laughter\nGeorge W. Bush; 2002; terrorist; terrorists; allies; camps; homeland\nGeorge W. Bush; 2003; hussein; saddam; inspectors; qaida; terrorists\nGeorge W. Bush; 2004; terrorists; propose; medicare; seniors; killers\nGeorge W. Bush; 2005; terrorists; iraqis; reforms; decades; generations\nGeorge W. Bush; 2006; hopeful; offensive; retreat; terrorists; terrorist\nGeorge W. Bush; 2007; terrorists; qaida; extremists; struggle; baghdad\nGeorge W. Bush; 2008; terrorists; empower; qaida; extremists; deny\nBarack Obama; 2009; deficit; afford; cannot; lending; invest\nBarack Obama; 2010; deficit; laughter; afford; decade; decades\nBarack Obama; 2011; deficit; republicans; democrats; laughter; afghan\nBarack Obama; 2012; afford; deficit; tuition; cannot; doubling\nBarack Obama; 2013; deficit; deserve; stronger; bipartisan; medicare\nBarack Obama; 2014; cory; laughter; decades; diplomacy; invest\nBarack Obama; 2015; laughter; childcare; democrats; rebekah; republicans\nBarack Obama; 2016; laughter; voices; allies; harder; qaida\n</code></pre>\n<p>As before, these thematic summaries in no way replace a careful reading of each document. They do however serve as a great high-level summary of each presidency. We see, for example,\nBill Clinton&#39;s initial focus on the deficit in the first few years, his turn towards bipartisanship as the House and Senate flipped towards the Republicans in the mid-1990s, and a turn towards Medicare reform at the end of his term. George W. Bush&#39;s speeches focus primarily on terrorism, with the exception of the 2001 speech, which occurred prior to the 9/11 terrorist attacks. Barack Obama returned the focus towards the economy in the shadow of the recession of 2008. The word &quot;laughter&quot; occurs frequently because it was added to the transcripts whenever the audience was laughing long enough to force the speaker to pause.</p>\n<h1 id=\"next-steps\">Next Steps</h1>\n<p>In this short tutorial we have explored some basic ways in which textual data may be analyzed within the R programming language. There are several directions one can pursue to dive further into the cutting edge techniques in text analysis. Three particularly interesting examples are:</p>\n<ul>\n<li>running a full NLP annotation pipeline on the text to extract features such as named entities, part of speech tags, and dependency relationship. These are available in several R packages, including <strong>cleanNLP</strong>.[^6]</li>\n<li>fitting topic models to detect particular discourses in the corpus using packages such as <strong>mallet</strong>[^10] and <strong>topicmodels</strong>.[^11]</li>\n<li>applying dimensionality reduction techniques to plot stylistic tendencies over time or across multiple authors. For example, the package <strong>tsne</strong> performs a powerful form of dimensionality reduction particularly amenable to insightful plots.</li>\n</ul>\n<p>Many generic tutorials exist for all three of these, as well as extensive package documentation.[^7] We hope to offer tutorials particularly focused on historical applications on these in the near future.</p>\n<h1 id=\"endnotes\">Endnotes</h1>\n<p>[^1]: Taryn Dewar, &quot;R Basics with Tabular Data,&quot; Programming Historian (05 September 2016), <a href=\"/lessons/r-basics-with-tabular-data\">/lessons/r-basics-with-tabular-data</a>.</p>\n<p>[^2]: Our corpus has 236 State of the Union addresses. Depending on exactly what is counted, this number can be slightly higher or lower.</p>\n<p>[^3]: All Presidential State of the Union Addresses were downloaded from The American Presidency Project at the University of California Santa Barbara. (Accessed 2016-11-11) <a href=\"http://www.presidency.ucsb.edu/sou.php\">http://www.presidency.ucsb.edu/sou.php</a>.</p>\n<p>[^4]: Peter Norvig. &quot;Google Web Trillion Word Corpus&quot;. (Accessed 2016-11-11) <a href=\"http://norvig.com/ngrams/\">http://norvig.com/ngrams/</a>.</p>\n<p>[^5]: This does happen for a few written State of the Union addresses, where a long bulleted list gets parsed into one very long sentence.</p>\n<p>[^6]: Taylor Arnold. &quot;cleanNLP: A Tidy Data Model for Natural Language Processing&quot;. R Package, Version 0.24. <a href=\"https://cran.r-project.org/web/packages/cleanNLP/index.html\">https://cran.r-project.org/web/packages/cleanNLP/index.html</a></p>\n<p>[^7]: See for example, the author&#39;s text: Taylor Arnold and Lauren Tilton. <em>Humanities Data in R: Exploring Networks, Geospatial Data, Images, and Text</em>. Springer, 2015.</p>\n<p>[^8]: Hadley Wickham. &quot;tidyverse: Easily Install and Load &#39;Tidyverse&#39; Packages&quot;. R Package, Version 1.1.1. <a href=\"https://cran.r-project.org/web/packages/tidyverse/index.html\">https://cran.r-project.org/web/packages/tidyverse/index.html</a></p>\n<p>[^9]: Lincoln Mullen and Dmitriy Selivanov. &quot;tokenizers: A Consistent Interface to Tokenize Natural Language Text Convert&quot;. R Package, Version 0.1.4. <a href=\"https://cran.r-project.org/web/packages/tokenizers/index.html\">https://cran.r-project.org/web/packages/tokenizers/index.html</a></p>\n<p>[^10]: David Mimno. &quot;mallet: A wrapper around the Java machine learning tool MALLET&quot;. R Package, Version 1.0. <a href=\"https://cran.r-project.org/web/packages/mallet/index.html\">https://cran.r-project.org/web/packages/mallet/index.html</a></p>\n<p>[^11]: Bettina Grün and Kurt Hornik. &quot;<a href=\"https://cran.r-project.org/web/packages/topicmodels/index.html&quot;\">https://cran.r-project.org/web/packages/topicmodels/index.html&quot;</a>. R Package, Version 0.2-4. <a href=\"https://cran.r-project.org/web/packages/topicmodels/index.html\">https://cran.r-project.org/web/packages/topicmodels/index.html</a></p>\n"}