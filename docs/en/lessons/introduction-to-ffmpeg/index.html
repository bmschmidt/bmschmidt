<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="description" content="" />
		<link rel="icon" href="/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		

		

		<link rel="stylesheet" href="/_app/assets/start-61d1577b.css">
		<link rel="modulepreload" href="/_app/start-a80c730b.js">
		<link rel="modulepreload" href="/_app/chunks/vendor-9b9d6288.js">
		<link rel="modulepreload" href="/_app/pages/__layout.svelte-de46afb2.js">
		<link rel="modulepreload" href="/_app/pages/_lang_/__layout.svelte-e75718c6.js">
		<link rel="modulepreload" href="/_app/chunks/stores-191d1505.js">
		<link rel="modulepreload" href="/_app/pages/_lang_/_lessons_/_slug_/index.svelte-efe77d76.js">

		<script type="module">
			import { start } from "/_app/start-a80c730b.js";
			start({
				target: document.querySelector("#svelte"),
				paths: {"base":"","assets":""},
				session: {},
				route: true,
				spa: false,
				trailing_slash: "never",
				hydrate: {
					status: 200,
					error: null,
					nodes: [
						import("/_app/pages/__layout.svelte-de46afb2.js"),
						import("/_app/pages/_lang_/__layout.svelte-e75718c6.js"),
						import("/_app/pages/_lang_/_lessons_/_slug_/index.svelte-efe77d76.js")
					],
					url: new URL("sveltekit://prerender/en/lessons/introduction-to-ffmpeg"),
					params: {lang:"en",lessons:"lessons",slug:"introduction-to-ffmpeg"}
				}
			});
		</script><script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('/service-worker.js');
			}
		</script>
	</head>
	<body>
		<div id="svelte">


The Programming Historian <a href="/en">English</a> <a href="/es">Spanish</a>
<br>
This is the en edition.

<h1>Introduction to Audiovisual Transcoding, Editing, and Color Analysis with FFmpeg</h1>

<!-- HTML_TAG_START --><p>{% include toc.html %}</p>
<h2 id="introduction">Introduction</h2>
<p>The Digital Humanities, as a discipline, have historically focused almost exclusively on the analysis of textual sources through computational methods (Hockey, 2004). However, there is growing interest in the field around using computational methods for the analysis of audiovisual cultural heritage materials as indicated by the creation of the <a href="https://avindhsig.wordpress.com/">Alliance of Digital Humanities Organizations Special Interest Group: Audiovisual Materials in the Digital Humanities</a> and <a href="https://figshare.com/articles/AV_in_DH_State_of_the_Field/5680114">the rise in submissions related to audiovisual topics at the global ADHO conference</a> over the past few years. Newer investigations, such as <a href="https://distantviewing.org/">Distant Viewing TV</a>, also indicate a shift in the field toward projects concerned with using computational techniques to expand the scope of materials digital humanists can investigate. As Erik Champion states, &quot;The DH audience is not always literature-focused or interested in traditional forms of literacy,&quot; and applying digital methodologies to the study of audiovisual culture is an exciting and emerging facet of the discipline (Champion, 2017). There are many valuable, free, and open-source tools and resources available to those interested in working with audiovisual materials (for example, the Programming Historian tutorial <a href="/en/lessons/editing-audio-with-audacity">Editing Audio with Audacity</a>), and this tutorial will introduce another: FFmpeg.</p>
<p><a href="https://www.ffmpeg.org/about.html">FFmpeg</a> is &quot;the leading multimedia framework able to decode, encode, transcode, mux, demux, stream, filter, and play pretty much anything that humans and machines have created&quot; (FFmpeg Website - &quot;About&quot;). Many common software applications and websites use FFmpeg to handle reading and writing audiovisual files, including VLC, Google Chrome, YouTube, <a href="https://trac.ffmpeg.org/wiki/Projects">and many more.</a> In addition to being a software and web-developer tool, FFmpeg can be used at the command-line to perform many common, complex, and important tasks related to audiovisual file management, alteration, and analysis. These kinds of processes, such as editing,  transcoding (re-encoding), or extracting metadata from files, usually require access to other software (such as a non-linear video editor like Adobe Premiere or Final Cut Pro), but FFmpeg allows a user to operate on audiovisual files directly without the use of third-party software or interfaces. As such, knowledge of the framework empowers users to manipulate audiovisual materials to meet their needs with a free, open-source solution that carries much of the functionality of expensive audio and video editing software. This tutorial will provide an introduction to reading and writing FFmpeg commands and walk through a use-case for how the framework can be used in Digital Humanities scholarship (specifically, how FFmpeg can be used to extract and analyze color data from an archival video source).</p>
<h2 id="learning-objectives">Learning Objectives</h2>
<ul>
<li>Install FFmpeg on your computer or use a demo version in your web browser</li>
<li>Understand the basic structure and syntax of FFmpeg commands</li>
<li>Execute several useful commands such as:<ul>
<li>Re-wrapping (change file container) &amp; Transcoding (re-encode files)</li>
<li>Demuxing (separating audio and video tracks)</li>
<li>Trimming/Editing files</li>
<li>File playback with FFplay</li>
<li>Creating vectorscopes for color data visualization</li>
<li>Generating color data reports with FFprobe</li>
</ul>
</li>
<li>Introduce outside resources for further exploration and experimentation</li>
</ul>
<h2 id="prerequisites">Prerequisites</h2>
<p>Before starting this tutorial, you should be comfortable with locating and using your computer&#39;s <a href="https://en.wikipedia.org/wiki/Terminal_(macOS)">Terminal</a> or other command-line interface, as this is where you will be entering and executing FFmpeg commands. If you need instruction on how to access and work at the command-line, I recommend the Program Historian&#39;s <a href="/en/lessons/intro-to-bash">Bash tutorial</a> for Mac and Linux users or the <a href="/en/lessons/intro-to-powershell#quick-reference">Windows PowerShell tutorial</a>. Additionally, a basic understanding of audiovisual <a href="https://en.wikipedia.org/wiki/Codec">codecs</a> and <a href="https://en.wikipedia.org/wiki/Digital_container_format">containers</a> will also be useful to understanding what FFmpeg does and how it works. We will provide some additional information and discuss codecs and containers in a bit more detail in the Preliminary Command Examples section of this tutorial.</p>
<h1 id="installing-ffmpeg">Installing FFmpeg</h1>
<p>Installing FFmpeg can be the most difficult part of using FFmpeg. Thankfully, there are some helpful guides and resources available for installing the framework based on your operating system.</p>
<div class="alert alert-warning">
New versions of FFmpeg are released approximately every 6 months. To keep track of these updates, follow FFmpeg on <a href="https://twitter.com/FFmpeg">Twitter</a> or through its website. New versions of FFmpeg usually contain features such as new and updated filters, codec compatibilities, and bug fixes. The syntax of FFmpeg does not change with these updates and old capabilities are rarely removed. To get an idea of what kinds of features come with these updates, you can scroll through previous update announcements in the <a href="https://www.ffmpeg.org/index.html#news">News</a> section of the FFmpeg website.
</div>

<h2 id="for-mac-os-users">For Mac OS Users</h2>
<p>The simplest option is to use a package manager such as <a href="https://brew.sh/">Homebrew</a>
to install FFmpeg and ensure it remains in the most up-to-date version. Homebrew is also useful in ensuring that your computer has the necessary dependencies installed to ensure FFMpeg runs properly. To complete this kind of installation, follow these steps:</p>
<ul>
<li><p>Install Homebrew following the instructions in the above link</p>
</li>
<li><p>You can then run <code>brew install ffmpeg</code> in your Terminal to initiate a basic installation.</p>
<ul>
<li><strong>Note</strong>: Generally, it is recommended to install FFMpeg with additional features than what is included in the basic installation. Including additional options will provide access to more of FFmpeg&#39;s tools and functionalities. Reto Kromer&#39;s <a href="https://avpres.net/FFmpeg/install_Apple.html">Apple installation guide</a> provides a good set of additional options:</li>
</ul>
<pre><code class="language-bash">brew install ffmpeg --with-sdl2 --with-freetype --with-openjpeg --with-x265 --with-rubberband --with-tesseract
</code></pre>
<ul>
<li>For an explanation of these additional options, refer to <a href="https://training.ashleyblewer.com/presentations/ffmpeg.html#10">Ashley Blewer&#39;s FFmpeg guide</a></li>
<li>Additionally, you can run <code>brew options ffmpeg</code> to see what features are or have become available with the current FFmpeg release</li>
</ul>
</li>
<li><p>After installing, it is best practice to update Homebrew and FFmpeg to ensure all dependencies and features are most up-to-date by running:</p>
<pre><code class="language-bash">brew update &amp;&amp; brew upgrade ffmpeg
</code></pre>
</li>
<li><p>For more installation options for Mac OS, see the <a href="https://trac.ffmpeg.org/wiki/CompilationGuide/macOS">Mac OS FFmpeg Compilation Guide</a></p>
</li>
</ul>
<h2 id="for-windows-users">For Windows Users</h2>
<p>Windows users can use the package manager <a href="https://chocolatey.org/">Chocolately</a> to install and maintain FFmpeg. Reto Kromer&#39;s <a href="https://avpres.net/FFmpeg/install_Windows.html">Windows installation guide</a> provides all the necessary information to use Chocolately or to install the software from a build.</p>
<h2 id="for-linux-users">For Linux Users</h2>
<p><a href="http://linuxbrew.sh/">Linuxbrew</a>, a program similar to Homebrew, can be used to
install and maintain FFmpeg in Linux. Reto Kromer also provides a helpful <a href="https://avpres.net/FFmpeg/install_Linux.html">Linux installation guide</a>
that closely resembles the Mac OS installation. Your distribution of Linux may also have its <a href="https://www.linode.com/docs/tools-reference/linux-package-management/">own package manager</a> already installed that include FFmpeg packages available. Depending on your distribution of Linux (Ubuntu, Fedora, Arch Linux, etc.) these builds can vary, so using Linuxbrew could be useful to ensure that the build is the same regardless of which type of Linux you are using.</p>
<h2 id="other-installation-resources">Other Installation Resources</h2>
<ul>
<li><a href="https://www.ffmpeg.org/download.html">Download Packages</a><ul>
<li>FFmpeg allows access to binary files, source code, and static builds for Mac, Windows, and Linux directly through its website, enabling users to build the framework without a package manager. It is likely that only advanced users will want to follow this option.</li>
</ul>
</li>
<li><a href="https://trac.ffmpeg.org/wiki/CompilationGuide">FFmpeg Compilation Guide</a><ul>
<li>The FFmpeg Wiki page also provides a compendium of guides and strategies for building FFmpeg on your computer.</li>
</ul>
</li>
</ul>
<h2 id="testing-the-installation">Testing the Installation</h2>
<ul>
<li><p>To ensure FFmpeg is installed properly, run:</p>
<pre><code class="language-bash">ffmpeg -version
</code></pre>
</li>
<li><p>If you see a long output of information, the installation was successful! It should look similar to this:</p>
<pre><code class="language-bash">ffmpeg version 4.0.1 Copyright (c) 2000-2018 the FFmpeg developers
built with Apple LLVM version 9.1.0 (clang-902.0.39.1)
configuration: --prefix=/usr/local/Cellar/ffmpeg/4.0.1 --enable-shared --enable-pthreads --enable-version3 --enable-hardcoded-tables --enable-avresample --cc=clang --host-cflags= --host-ldflags= --enable-gpl --enable-ffplay --enable-libfreetype --enable-libmp3lame --enable-librubberband --enable-libtesseract --enable-libx264 --enable-libx265 --enable-libxvid --enable-opencl --enable-videotoolbox --disable-lzma --enable-libopenjpeg --disable-decoder=jpeg2000 --extra-cflags=-I/usr/local/Cellar/openjpeg/2.3.0/include/openjpeg-2.3
libavcodec     58. 18.100 / 58. 18.100
libavformat    58. 12.100 / 58. 12.100
libavdevice    58.  3.100 / 58.  3.100
libavfilter     7. 16.100 /  7. 16.100
libavresample   4.  0.  0 /  4.  0.  0
libswscale      5.  1.100 /  5.  1.100
libswresample   3.  1.100 /  3.  1.100
libpostproc    55.  1.100 / 55.  1.100
</code></pre>
</li>
<li><p>If you see something like <code>-bash: ffmpeg: command not found</code> then something has
gone wrong.</p>
<ul>
<li>Note: If you are using a package manager it is unlikely that you will encounter this error message. However, if there is a problem after installing with a package manager, it is likely the issue is with the package manager itself as opposed to FFmpeg. Consult the Troubleshooting sections for <a href="https://docs.brew.sh/Troubleshooting">Homebrew</a>, <a href="https://chocolatey.org/docs/troubleshooting">Chocolatey</a>, or <a href="http://linuxbrew.sh/">Linuxbrew</a> to ensure the package manager is functioning properly on your computer. If you are attempting to install without a package manager and see this error message, cross-reference your method with the FFmpeg Compilation Guide provided above.</li>
</ul>
</li>
</ul>
<h2 id="using-ffmpeg-in-a-web-browser-without-installing">Using FFmpeg in a web browser (without installing)</h2>
<p>If you do not want to install FFmpeg on your computer but would like to become familiar with using it at the command-line, Brian Grinstead&#39;s <a href="https://bgrins.github.io/videoconverter.js/demo/">videoconverter.js</a> provides a way to run FFmpeg commands and learn its basic functions in the web-browser of your choice.
  <div class="alert alert-warning">
  This browser-based interface does not have the functionality to complete the entirety of this tutorial but is useful for learning the basics of FFmpeg commands. Additionally, this resource runs on an older version of FFmpeg and may not contain all the features of the most recent version.</p>
</div>
# Basic Structure and Syntax of FFmpeg commands
Basic FFmepg commands consist of four elements:

<pre><code class="language-bash">[Command Prompt] [Input File] [Flags/Actions] [Output File]
</code></pre>
<ul>
<li>A command prompt will begin every FFmpeg command. Depending on the use, this prompt will either be <code>ffmpeg</code> (changing files), <code>ffprobe</code> (gathering metadata from files), or <code>ffplay</code> (playback of files).</li>
<li>Input files are the files being read, edited, or examined.</li>
<li>Flags and actions are the things you are telling FFmpeg to do the input files. Most commands will contain multiple flags and actions of various complexity.</li>
<li>The output file is the new file created by the command or the report generated by an <code>ffprobe</code> command.</li>
</ul>
<p>Written generically, a basic FFmpeg command looks like this:</p>
<pre><code class="language-bash">ffmpeg -i /filepath/input_file.ext -flag some_action /filepath/output_file.ext
</code></pre>
<div class="alert alert-warning">As with any command-line interface, you will need to write out the filepath of the input and output files depending on location of your working directories. In the examples given in this tutorial, filepaths will not be fully written out and it is assumed that a user has navigated to the working directory containing the input files to execute the commands.</div>

<p>Next, we will look at some examples of several different commands that use this structure and syntax. These commands will also demonstrate some of FFmpeg&#39;s most basic, useful functions and allow us to become more familiar with how digital audiovisual files are constructed.</p>
<h1 id="getting-started">Getting Started</h1>
<p>For this tutorial, we will be taking an archival film called <a href="https://archive.org/details/4050_Destination_Earth_01_47_33_28"><em>Destination Earth</em></a> as our object of study. This film has been made available by the <a href="https://en.wikipedia.org/wiki/Prelinger_Archives">Prelinger Archives</a> collection on the <a href="https://archive.org/">Internet Archive</a>. Released in 1956, this film is a prime example of Cold War-era propaganda produced by the <a href="https://en.wikipedia.org/wiki/American_Petroleum_Institute">American Petroleum Institute</a> and <a href="https://en.wikipedia.org/wiki/John_Sutherland_(producer)">John Sutherland Productions</a> that extols the virtues of capitalism and the American way of life. Utilizing the <a href="https://en.wikipedia.org/wiki/Technicolor">Technicolor</a> process, this science-fiction animated short tells a story of a Martian society living under an oppressive government and their efforts to improve their industrial methods. They send an emissary to Earth who discovers the key to this is oil refining and free-enterprise. We will be using this video to introduce some of the basic functionalities of FFmpeg and analyzing its color properties in relation to its propagandist rhetoric.</p>
<p>{% include figure.html filename=&quot;destEarth_titlecard.png&quot; caption=&quot;Destination Earth (1956)&quot; %}</p>
<p>For this tutorial, you will need to:</p>
<ul>
<li>Navigate to the <a href="https://archive.org/details/4050_Destination_Earth_01_47_33_28"><em>Destination Earth</em></a> page on IA</li>
<li>Download two video files: the &quot;MPEG4&quot; (file extension <code>.m4v</code>) and &quot;OGG&quot; (file extension <code>.ogv</code>) versions of the film</li>
<li>Save these two video files in the same folder somewhere on your computer. Save them with the file names <code>destEarth</code> followed by its extension</li>
</ul>
<p>Take a few minutes to watch the video and get a sense of its structure, message, and visual motifs before moving on with the next commands.</p>
<h1 id="preliminary-command-examples">Preliminary Command Examples</h1>
<h2 id="viewing-basic-metadata-with-ffprobe">Viewing Basic Metadata with FFprobe</h2>
<p>Before we begin manipulating our <code>destEarth</code> files, let&#39;s use FFmpeg to examine some basic information about the file itself using a simple <code>ffprobe</code> command. This will help illuminate how digital audiovisual files are constructed and provide a foundation for the rest of the tutorial. Navigate to the file&#39;s directory and execute:</p>
<pre><code class="language-bash">ffprobe destEarth.ogv
</code></pre>
<p>You will see the file&#39;s basic technical metadata printed in the <code>stdout</code>:</p>
<p>{% include figure.html filename=&quot;ffprobe_ogg.png&quot; caption=&quot;The output of a basic <code>ffprobe</code> command with destEarth.ogv&quot; %}</p>
<p>The <code>Input #0</code> line of the reports identifies the <strong>container</strong> as <a href="https://en.wikipedia.org/wiki/Ogg">ogg</a>. Containers (also called &quot;wrappers&quot;) provide the file with structure for its various streams. Different containers (other common ones include <code>.mkv</code>, <code>.avi</code>, and <code>.flv</code>) have different features and compatibilities with various software. We will examine how and why you might want to change a file&#39;s container in the next command.</p>
<p>The lines <code>Stream #0:0</code> and <code>Stream #0:1</code> provide information about the file&#39;s streams (i.e. the content you see on screen and hear through your speakers) and identify the <strong>codec</strong> of each stream as well. Codecs specify how information is encoded/compressed (written and stored) and decoded/decompressed (played back). Our <code>.ogv</code> file&#39;s video stream (<code>Stream #0:0</code>) uses the <a href="https://en.wikipedia.org/wiki/Theora">theora</a> codec while the audio stream (<code>Stream #0:1</code>) uses the <a href="https://en.wikipedia.org/wiki/Vorbis">vorbis</a> codec. These lines also provide important information related to the video stream&#39;s colorspace (<code>yuv420p</code>), resolution (<code>400x300</code>), and frame-rate (<code>29.97 fps</code>), in addition to audio information such as sample-rate (<code>44100 Hz</code>) and bit-rate (<code>128 kb/s</code>).</p>
<p>Codecs, to a much greater extent than containers, determine an audiovisual file&#39;s quality and compatibility with different software and platforms (other common codecs include <code>DNxHD</code> and <code>ProRes</code> for video and <code>mp3</code> and <code>FLAC</code> for audio). We will examine how and why you might want to change a file&#39;s codec in the next command as well.</p>
<p>Run another <code>ffprobe</code> command, this time with the <code>.m4v</code> file:</p>
<pre><code class="language-bash">ffprobe destEarth.m4v
</code></pre>
<p>Again you&#39;ll see the basic technical metadata printed to the <code>stdout</code>:</p>
<p>{% include figure.html filename=&quot;ffprobe_mp4.png&quot; caption=&quot;The output of a basic <code>ffprobe</code> command with destEarth.m4v&quot; %}</p>
<p>You&#39;ll also notice that the report for the <code>.m4v</code> file contains multiple containers on the <code>Input #0</code> line like <code>mov</code> and <code>m4a</code>. It isn&#39;t necessary to get too far into the details for the purposes of this tutorial, but be aware that the <code>mp4</code> and  <code>mov</code> containers come in many &quot;flavors&quot; and different file extensions. However, they are all very similar in their technical construction, and as such you may see them grouped together in technical metadata. Similarly, the <code>ogg</code> file has the extension <code>.ogv</code>, a &quot;flavor&quot; or variant of the <code>ogg</code> format.</p>
<p>Just as in our previous command, the lines <code>Stream #0:0</code> and <code>Stream #0:1</code>  identify the codec of each stream. We can see our <code>.m4v</code> file uses the <a href="https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC">H.264</a> video codec while the audio stream uses the <a href="https://en.wikipedia.org/wiki/Advanced_Audio_Coding">aac</a> codec. Notice that we are given similar metadata to our <code>.ogv</code> file but some important features related to visual analysis (such as the resolution) are significantly different. Our <code>.m4v</code> has a much higher resolution (<code>640x480</code>) and we will therefore use this version of <em>Destination Earth</em> as our source video.</p>
<p>Now that we know more about the technical make-up of our file, we can begin exploring the transformative features and functionalities of FFmpeg (we will use <code>ffprobe</code> again later in the tutorial to conduct more advanced color metadata extraction).</p>
<h2 id="changing-containers-and-codecs-re-wrap-and-transcode">Changing Containers and Codecs (Re-Wrap and Transcode)</h2>
<p>Depending on your operating system, you may have one or more media players installed. For the purposes of demonstration, let&#39;s see what happens if you try to open <code>destEarth.ogv</code> using the QuickTime media player that comes with Mac OSX:</p>
<p>{% include figure.html filename=&quot;QT_fail.png&quot; caption=&quot;Proprietary media players such as QuickTime are often limited in the kinds of files they can work with.&quot; %}</p>
<p>One option when faced with such a message is to simply use another media player. <a href="https://www.videolan.org/vlc/index.html">VLC</a>, which is built with FFmpeg, is an excellent open-source alternative, but simply &quot;using another software&quot; may not always be a viable solution (and you may not always have another version of a file to work with, either). Many popular video editors such as Adobe Premiere, Final Cut Pro, and DaVinci Resolve all have their own limitations on the kinds of formats they are compatible with. Further, different web-platforms and hosting/streaming sites such as Vimeo have <a href="https://vimeo.com/help/compression">their own requirements as well.</a> As such, it is important to be able to re-wrap and transcode your files to meet the various specifications for playback, editing, digital publication, and conforming files to standards required by digital preservation or archiving platforms.</p>
<div class="alert alert-warning">
For a complete list of codecs and containers supported by your installation of FFmpeg, run <code>ffmpeg -codecs</code> and <code>ffmpeg -formats</code>, respectively, to see the list printed to your <code>stdout</code>.
</div>

<p>As an exercise in learning basic FFmpeg syntax and learning how to transcode between formats, we will begin with our <code>destEarth.ogv</code> file and write a new file with video encoded to <code>H.264</code>, audio to <code>AAC</code>, and wrapped in an <code>.mp4</code> container, a very common and highly-portable combination of codecs and container that is practically identical to the <code>.m4v</code> file we originally downloaded. Here is the command you will execute along with an explanation of each part of the syntax:</p>
<pre><code class="language-bash">ffmpeg -i destEarth.ogv -c:v libx264 -c:a aac destEarth_transcoded.mp4
</code></pre>
<ul>
<li><code>ffmpeg</code> = starts the command</li>
<li><code>-i destEarth.ogv</code> = specifies the input file</li>
<li><code>-c:v libx264</code> = transcodes the video stream to the H.264 codec</li>
<li><code>-c:a aac</code> = transcodes the audio stream to the AAC codec</li>
<li><code>destEarth_transcoded.mp4</code> = specifies the output file. Note this is where the new container type is specified.</li>
</ul>
<p>If you execute this command as it is written and in the same directory as <code>destEarth.ogv</code>, you will see a new file called <code>destEarth_transcoded.mp4</code> appear in the directory. If you are operating in Mac OSX, you will also be able to play this new file with QuickTime. A full exploration of codecs, containers, compatibility, and file extension conventions is beyond the scope of this tutorial, however this preliminary set of examples should give those less familiar with how digital audiovisual files are constructed a baseline set of knowledge that will enable them to complete the rest of the tutorial.</p>
<h2 id="creating-excerpts--demuxing-audio--video">Creating Excerpts &amp; Demuxing Audio &amp; Video</h2>
<p>Now that we have a better understanding of streams, codecs, and containers, let&#39;s look at ways FFmpeg can help us work with video materials at a more granular level. For this tutorial, we will examine two discrete sections of <em>Destination Earth</em> to compare how color is used in relation to the film&#39;s propagandist rhetoric. We will create and prepare these excerpts for analysis using a command that performs two different functions simultaneously:</p>
<ul>
<li>First, the command will create two excerpts from <code>destEarth.m4v</code>.</li>
<li>Second, the command will remove (&quot;demux&quot;) the audio components (<code>Stream #0:1</code>) from these excerpts.<div class="alert alert-warning">
  We are removing the audio in the interest of promoting good practice in saving storage space (the audio information is not necessary for color analysis). This will likely be useful if you hope to use this kind of analysis at larger scales. More on scaling color analysis will be provided near the end of the tutorial.
</div></li>
</ul>
<p>The first excerpt we will be making is a sequence near the beginning of the film depicting the difficult conditions and downtrodden life of the Martian society. The following command specifies start and end points of the excerpt, tells FFmpeg to retain all information in the video stream without transcoding anything, and to write our new file without the audio stream:</p>
<pre><code class="language-bash">ffmpeg -i destEarth.m4v -ss 00:01:00 -to 00:04:35 -c:v copy -an destEarth_Mars_video.mp4
</code></pre>
<ul>
<li><code>ffmpeg</code> = starts the command</li>
<li><code>-i destEarth.m4v</code> = specifies the input file</li>
<li><code>-ss 00:01:00</code> = sets start point at 1 minute from start of file</li>
<li><code>-to 00:04:45</code> = sets end point to 4 minutes and 45 seconds from start of file</li>
<li><code>-c:v copy</code> = copy the video stream directly, without transcoding</li>
<li><code>-an</code> = tells FFmpeg to ignore audio stream when writing the output file.</li>
<li><code>destEarth_Mars_video.mp4</code> = specifies the output file</li>
</ul>
<p>{% include figure.html filename=&quot;Mars_screenshot.png&quot; caption=&quot;Life on Mars&quot; %}</p>
<p>We will now run a similar command to create an &quot;Earth&quot; excerpt. This portion of the film has a similar sequence depicting the wonders of life on Earth and the richness of its society thanks to free-enterprise capitalism and the use of oil and petroleum products:</p>
<pre><code class="language-bash">ffmpeg -i destEarth.m4v -ss 00:07:30 -to 00:11:05 -c:v copy -an destEarth_Earth_video.mp4
</code></pre>
<p>{% include figure.html filename=&quot;Earth_screenshot.png&quot; caption=&quot;Bounty of Earth&quot; %}</p>
<p>You should now have two new files in your directory called <code>destEarth_Mars_video.mp4</code> and <code>destEarth_Earth_video.mp4</code>. You can test one or both files (or any of the other files in the directory) using the <code>ffplay</code> feature of FFmpeg as well. Simply run:</p>
<pre><code class="language-bash">ffplay destEarth_Mars_video.mp4
</code></pre>
<p>and/or</p>
<pre><code class="language-bash">ffplay destEarth_Earth_video.mp4
</code></pre>
<p>You will see a window open and the video will begin at the specified start point, play through once, and then close (in addition, you&#39;ll notice there is no sound in your video). You will also notice that <code>ffplay</code> commands do not require an <code>-i</code> or an output to be specified because the playback itself is the output.</p>
<div class="alert alert-warning">
<code>FFplay</code> is a very versatile media player that comes with a number of <a href="https://ffmpeg.org/ffplay.html#Options">options</a> for customizing playback. For example, adding `-loop 0` to the command will loop playback indefinitely.</div>

<p>We have now created our two excerpts for analysis. If we watch these clips discretely, there appear to be significant, meaningful differences in the way color and color variety are used. In the next part of the tutorial, we will examine and extract data from the video files to quantify and support this hypothesis.</p>
<h2 id="color-data-analysis">Color Data Analysis</h2>
<p>The use of <a href="https://web.archive.org/web/20180317223950/https://filmcolors.org/2018/03/08/vian/">digital tools to analyze color information</a> in motion pictures is another emerging facet of DH scholarship that overlaps with traditional film studies. The <a href="https://filmcolors.org/">FilmColors</a> project, in particular, at the University of Zurich, interrogates the critical intersection of film&#39;s &quot;formal aesthetic features to [the] semantic, historical, and technological aspects&quot; of its production, reception, and dissemination through the use of digital analysis and annotation tools (Flueckiger, 2017). Although there is no standardized method for this kind of investigation at the time of this writing, the <code>ffprobe</code> command offered below is a powerful tool for extracting information related to color that can be used in computational analysis. First, let&#39;s look at another standardized way of representing color information that informs this quantitative, data-driven approach to color analysis.</p>
<h3 id="vectorscopes">Vectorscopes</h3>
<p>For years, video professionals have relied on <a href="https://en.wikipedia.org/wiki/Vectorscope#Video">vectorscopes</a> to view color information in a standardized and easily legible way. A vectorscope plots color information on a circular graticle, and the position of a given plot corresponds to the particular <a href="https://en.wikipedia.org/wiki/Hue">hues</a> found in a video signal. Other factors, like saturation, determine the size of a given plot as well. Below is an example of a vectorscope displaying the color values of SMPTE Bars, which are also pictured.</p>
<p>{% include figure.html filename=&quot;vectorscope.png&quot; caption=&quot;A vectorscope read-out representing standard NTSC SMPTE Bars. Source: Wikimedia Commons&quot; %}</p>
<p>{% include figure.html filename=&quot;smpte_bars.png&quot; caption=&quot;NTSC SMPTE Bars. Source: Wikimedia Commons&quot; %}</p>
<p>FFmpeg can be used to playback and create video files with vectorscopes embedded in them so as to provide a real-time reference for the video&#39;s color information. The following <code>ffplay</code> commands will embed a vectorscope in the lower-right corner of the frame. As the video plays, you will notice the vectorscope plot shift as the on-screen color shifts:</p>
<pre><code class="language-bash">ffplay destEarth_Mars_video.mp4 -vf &quot;split=2[m][v], [v]vectorscope=b=0.7:m=color3:g=green[v],[m][v]overlay=x=W-w:y=H-h&quot;
</code></pre>
<ul>
<li><code>ffplay</code> = starts the command</li>
<li><code>destEarth_Mars_video.mp4</code> = specifies the input file</li>
<li><code>-vf</code> = creates a <a href="https://trac.ffmpeg.org/wiki/FilteringGuide">filter-graph</a> to use for the streams</li>
<li><code>&quot;</code> = quotation mark to start the filter-graph. Information inside the quotation marks will specify the parameters of the vectorscope&#39;s appearance and position.</li>
<li><code>split=2[m][v]</code> = splits the input into two identical outputs called <code>[m]</code> and <code>[v]</code></li>
<li><code>,</code> = comma signifies another parameter is coming</li>
<li><code>[v]vectorscope=b=0.7:m=color3:g=green[v]</code> = assigns the <code>[v]</code> output the vectorscope filter. The <code>b</code> flag specifies the vectorscope&#39;s background opacity, the <code>m</code> flag the vectorscope mode, and the <code>g</code> flag the color of the graticle.</li>
<li><code>[m][v]overlay=x=W-w:y=H-h</code> = overlays the vectorscope on top of the video image (the <code>[m]</code> output) in a certain location determined by x:y coordinates. In this case, the vectorscope will be justified to the lower right corner of the frame.</li>
<li><code>&quot;</code> = ends the filter-graph</li>
</ul>
<div class="alert alert-warning">
For more information on the various options for creating vectorscopes, see <a href="https://ffmpeg.org/ffmpeg-filters.html#vectorscope">the official Documentation</a> and the <a href="https://trac.ffmpeg.org/wiki/Vectorscope">FFmpeg Vectorscope Wiki Page</a>. Additionally, more information on how to position overlays can be found in the <a href="https://ffmpeg.org/ffmpeg-filters.html#overlay-1">FFmpeg overlay filter Documentation</a>.
</div>

<p>{% include figure.html filename=&quot;Mars_screenshot_vector.png&quot; caption=&quot;Screenshot of FFplay window with embedded vectorscope&quot; %}</p>
<p>And for the &quot;Earth&quot; excerpt:</p>
<pre><code class="language-bash">ffplay destEarth_Earth_video.mp4 -vf &quot;split=2[m][v], [v]vectorscope=b=0.7:m=color3:g=green[v],[m][v]overlay=x=W-w:y=H-h&quot;
</code></pre>
<p>{% include figure.html filename=&quot;Earth_screenshot_vector.png&quot; caption=&quot;Screenshot of FFplay window with embedded vectorscope&quot; %}</p>
<p>We can also adjust this command to write new video files with vectorscopes as well:</p>
<pre><code class="language-bash">ffmpeg -i destEarth_Mars_video.mp4 -vf &quot;split=2[m][v], [v]vectorscope=b=0.7:m=color3:g=green[v],[m][v]overlay=x=W-w:y=H-h&quot; -c:v libx264 destEarth_Mars_vectorscope.mp4
</code></pre>
<pre><code class="language-bash">ffmpeg -i destEarth_Earth_video.mp4 -vf &quot;split=2[m][v], [v]vectorscope=b=0.7:m=color3:g=green[v],[m][v]overlay=x=W-w:y=H-h&quot; -c:v libx264 destEarth_Earth_vectorscope.mp4
</code></pre>
<p>Note the slight but important changes in syntax:</p>
<ul>
<li>We have added an <code>-i</code> flag because it is an <code>ffmpeg</code> command.</li>
<li>We have specified the output video codec as <a href="https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC">H.264</a> with the flag <code>-c:v libx264</code> and have left out an option for audio. Although you could add <code>-c:a copy</code> to copy the audio stream (if there is one in the input file) without transcoding or specify another audio codec here if necessary.</li>
<li>We have specified the name of the output file.</li>
</ul>
<p>Take a few minutes to watch these videos with the vectorscopes embedded in them. Notice how dynamic (or not) the changes are between the &quot;Mars&quot; and &quot;Earth&quot; excerpts. Compare what you see in the vectorscope to your own impressions of the video itself. We might use observations from these vectorscopes to make determinations about which shades of color appear more regularly or intensely in a given source video, or we may compare different formats side-by-side to see how color gets encoded or represented differently based on different codecs, resolutions, etc.</p>
<p>Although vectorscopes provide a useful, real-time representation of color information, we may want to also access the raw data beneath them. We can then use this data to develop more flexible visualizations that are not dependent on viewing the video file simultaneously and that offer a more quantitative approach to color analysis. In our next commands, we will use <code>ffprobe</code> to produce a tabular dataset that can be used to create a graph of color data.</p>
<h3 id="color-data-extraction-with-ffprobe">Color Data Extraction with FFprobe</h3>
<p>At the beginning of this tutorial, we used an <code>ffprobe</code> command to view our file&#39;s basic metadata printed to the <code>stdout</code>. In these next examples, we&#39;ll use <code>ffprobe</code> to extract color data from our video excerpts and output this information to <code>.csv</code> files. Within our <code>ffprobe</code> command, we are going to use the <code>signalstats</code> filter to create <code>.csv</code> reports of median color <a href="https://en.wikipedia.org/wiki/Hue">hue</a> information for each frame in the video stream of <code>destEarth_Mars_video.mp4</code> and <code>destEarth_Earth_video.mp4</code>, respectively.</p>
<pre><code class="language-bash">ffprobe -f lavfi -i movie=destEarth_Mars_video.mp4,signalstats -show_entries frame=pkt_pts_time:frame_tags=lavfi.signalstats.HUEMED -print_format csv &gt; destEarth_Mars_hue.csv
</code></pre>
<ul>
<li><code>ffprobe</code> = starts the command</li>
<li><code>-f lavfi</code> = specifies the <a href="https://ffmpeg.org/ffmpeg-devices.html#lavfi">libavfilter</a> virtual input device as the chosen format. This is necessary when using <code>signalstats</code> and many filters in more complex FFmpeg commands.</li>
<li><code>-i movie=destEarth_Mars_video.mp4</code> = name of input file</li>
<li><code>,signalstats</code> = specifies use of the <code>signalstats</code> filter with the input file</li>
<li><code>-show_entries</code> = sets list of entries that will be shown in the report. These are specified by the next options.</li>
<li><code>frame=pkt_pts_time</code> = specifies showing each frame with its corresponding <code>pkt_pts_time</code>, creating a unique entry for each frame of video</li>
<li><code>:frame_tags=lavfi.signalstats.HUEMED</code> = creates a tag for each frame that contains the median hue value</li>
<li><code>-print_format csv</code> = specifies the format of the metadata report</li>
<li><code>&gt; destEarth_Mars_hue.csv</code> = writes a new <code>.csv</code> file containing the metadata report using <code>&gt;</code>, a Bash <a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html">redirection operator</a>. Simply, this operator takes the command the precedes it and &quot;redirects&quot; the output to another location. In this instance, it is writing the output to a new <code>.csv</code> file. The file extension provided here should also match the format specified by the <code>print_format</code> flag</li>
</ul>
<p>Next, run the same command for the &quot;Earth&quot; excerpt:</p>
<pre><code class="language-bash">ffprobe -f lavfi -i movie=destEarth_Earth_video.mp4,signalstats -show_entries frame=pkt_pts_time:frame_tags=lavfi.signalstats.HUEMED -print_format csv &gt; destEarth_Earth_hue.csv
</code></pre>
<div class="alert alert-warning">
For more information about the <code>signalstats</code> filter and the various metrics that can be extracted from video streams, refer to the FFmpeg's <a href="https://ffmpeg.org/ffmpeg-filters.html#signalstats-1">Filters Documentation</a>.
</div>

<p>You should now have two <code>.csv</code> files in your directory. If you open these in a text editor or spreadsheet program, you will see three columns of data:</p>
<p>{% include figure.html filename=&quot;csv_head.png&quot; caption=&quot;The first several rows of our Earth excerpt color report in .csv format&quot; %}</p>
<p>Going from left to right, the first two columns give us information about where we are in the video. The decimal numbers represent fractions of a second that also roughly correspond to the video&#39;s time-base of 30fps. As such, each row in our <code>.csv</code> corresponds to one frame of video. The third column carries a whole number between 0-360, and this value represents the median hue for that frame of video. These numbers are the underlying quantitative data of the vectorscope&#39;s plot and correspond to its position (in radians) on the circular graticle. Referencing our vectorscope image from earlier, you can see that starting at the bottom of the circle (0 degrees) and moving left, &quot;greens&quot; are around 38 degrees, &quot;yellows&quot; at 99 degrees, &quot;reds&quot; at 161 degrees, &quot;magentas&quot; at 218 degrees, &quot;blues&quot; at 279 degrees, and &quot;cyans&quot; at 341 degrees. Once you understand these &quot;ranges&quot; of hue, you can get an idea of what the median hue value for a given video frame is just by looking at this numerical value.</p>
<p>Additionally, It is worth noting that this value extracted by the <code>signalstats</code> filter is not an absolute or complete measure of an image&#39;s color qualities, but simply a meaningful point of reference from which we can explore a data-driven approach to color analysis. Color perception and color theory are <a href="https://colourturn.net/">complex, evolving areas of scholarly investigation</a> that incorporate many different approaches from the humanities, social sciences, and cognitive sciences. As such, we should be mindful that any analytical approach should be taken within the context of these larger discourses and with a collaborative and generative spirit.</p>
<h3 id="graphing-color-data">Graphing Color Data</h3>
<p>The two <code>.csv</code> files we created with the previous commands can now be used to create graphs visualizing the data. There are a number of platforms (both proprietary and open-source) that can be used to achieve this such as <a href="https://www.wikihow.com/Create-a-Graph-in-Excel">Microsoft Excel</a>, <a href="https://rawgraphs.io/">RAWGraphs</a>, and/or <a href="https://plot.ly/">plot.ly</a>. An in-depth discussion of how to use any of these platforms is outside the scope of this tutorial, however, the final visualization of the previous commands (below) was created by uploading the <code>.csv</code> files to plot.ly, an open-source, browser-based service that offers a number of <a href="https://help.plot.ly/tutorials/">tutorials</a> on how to use their platform.</p>
<p>{% include figure.html filename=&quot;Final_Graph_plotly.png&quot; caption=&quot;Graph including median hue data from both video excerpts&quot; %}</p>
<h3 id="conclusions">Conclusions</h3>
<p>From looking at the graph, we can see that the Mars and Earth traces have very different dynamic ranges in their median hue values. The Mars trace is very limited and keeps within the red and yellow ranges (roughly between 100 - 160) throughout the majority of the excerpt. This suggests something about the film&#39;s use of color as a rhetorical device serving a propagandist message. Remember that this section presents an antipathetic view of the Martian way of life and political system: a uniform, unhappy populace who are dependent on inefficient technology and transportation while being required to observe total obedience to a totalitarian overlord. The film connects this negative experience to a relatively dull color palette of reds and yellows. We should also consider the original target audience of this film, young citizens of the United States in the 1950s, and how they would have likely interpreted these images and uses of color in that historical moment, namely, in the context of increasing geopolitical tensions between the Soviet Union and the United States and its allies in Western Europe. The color red, specifically, was commonly used in print and broadcast media for describing <a href="https://en.wikipedia.org/wiki/Red_Scare">the &quot;threat&quot; of global Communism</a> during this era of world history. Additionally, the choice to render the Martian totalitarian leader with a very similar appearance to iconic Soviet leader <a href="https://en.wikipedia.org/wiki/Joseph_Stalin">Joseph Stalin</a> can be read as an explicit visual and cultural cue to the audience. As such, this depiction of Mars seems to be a thinly-veiled allegorical caricature of life under Communism as perceived by an outside observer and political/ideological opponent, a caricature that employs not only a limited color palette but one that is charged with other cultural references. The use of color both leverages the preconceived biases and associations of its audience and is inherently bound to the film&#39;s political argument that Communism is not a viable or desirable system of government.</p>
<p>Contrasting the limited use of color in our Mars excerpt, the Earth trace covers a much wider dynamic range of hue values. In this passage, the Martian emissary is learning about the wonderful and affluent lifestyle of Earthlings thanks to a capitalist system and exploitation of oil and petroleum products. The sequence emphasizes the material wealth and entrepreneurial freedom offered under a capitalist system using a much greater variety and vivacity of color than in the Mars excerpt. Commercial products and people alike are depicted using the full spectrum of the Technicolor process, creating positive associations between the outputs of the petroleum industry and the well-off lifestyle of those who benefit from it. Like the Mars excerpt, the audience is offered a one-sided caricature of a political system and way of life, but in this section the reductionist portrayal is laudable and prosperous as opposed to bleak and oppressive. As a piece of propaganda, <em>Destination Earth</em> relies on these powerful but overly simplistic distinctions between two political systems to influence public opinion and promote the consumption of petroleum products. How color is used (or not used) is an important tool in crafting and driving this message home. Further, once we are able to extract color data and visualize it using simple graphing techniques, we can see that the disparity in dynamic range provides a quantitative measure for linking the technical and aesthetic use of color in this animated film with the propagandist rhetoric put forth by its producers.</p>
<p>{% include figure.html filename=&quot;lovely_oil.png&quot; caption=&quot;Oil and American ideals of wealth and prosperity rendered in colorful splendor&quot; %}</p>
<h3 id="scaling-color-analysis-with-ffprobe">Scaling Color Analysis with FFprobe</h3>
<p>One of the limits of this methodology is that we are manually generating color reports on only one file at a time. If we wanted to take a <a href="https://distantviewing.org/background">distant viewing</a> approach more in-line with traditional DH methodologies, we could employ a Bash script to run our <code>ffprobe</code> command on all files in a given directory. This is useful if, for example, a researcher was interested in conducting similar analysis on <a href="https://archive.org/details/prelinger&amp;tab=collection?and%5B%5D=john+sutherland&amp;sin=">all the John Sutherland animated films found in the Prelinger Archives collection</a> or another set of archival video material.</p>
<p>Once you have a set of material to work with saved in one place, you can save the following <a href="https://www.shellscript.sh/loops.html">Bash for loop</a> within the directory and execute it to generate <code>.csv</code> files containing the same frame-level median hue data we extracted from our excerpts of <em>Destination Earth</em>.</p>
<pre><code class="language-bash">for file in *.m4v; do
ffprobe -f lavfi -i movie=&quot;$file&quot;,signalstats -show_entries frame=pkt_pts_time:frame_tags=lavfi.signalstats.HUEMED -print_format csv &gt; &quot;${file%.m4v}.csv&quot;;
done
</code></pre>
<ul>
<li><p><code>for file in *.m4v; do</code> = initiates the for loop. This first line basically tells FFmpeg: &quot;for all files in this directory with the extension <code>.m4v</code>, perform the following command.&quot;</p>
<ul>
<li>The <code>*</code> is a Bash <a href="http://tldp.org/LDP/GNU-Linux-Tools-Summary/html/x11655.htm">wildcard</a> attached to a given file-type and specifies them as the input files.</li>
<li>The word <code>file</code> is an arbitrary <a href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-5.html">variable</a> which will represent each file as it runs through the loop.</li>
</ul>
</li>
<li><p><code>ffprobe -f lavfi -i movie=&quot;$file&quot;,signalstats -show_entries frame=pkt_pts_time:frame_tags=lavfi.signalstats.HUEMED -print_format csv &gt; &quot;${file%.m4v}.csv&quot;; done</code> = the same color metadata extraction command we ran on our two excerpts of <em>Destination Earth</em>, with some slight alterations to the syntax to account for its use across multiple files in a directory:</p>
<ul>
<li><code>&quot;$file&quot;</code> recalls each variable. The enclosing quotation marks ensures that the original filename is retained.</li>
<li><code>&gt; &quot;${file%.m4v}.csv&quot;;</code> retains the original filename when writing the output <code>.csv</code> files. This will ensure the names of the original video files will match their corresponding <code>.csv</code> reports.</li>
<li><code>done</code> = terminates the script once all files in the directory have been looped</li>
</ul>
</li>
</ul>
<div class="alert alert-warning">
You can also use <code>signalstats</code> to pull other valuable information related to color. Refer to the filter's <a href="https://www.ffmpeg.org/ffprobe-all.html#signalstats-1">documentation</a> for a complete list of visual metrics available.
</div>

<p>Once you run this script, you will see each video file in the directory now has a corresponding <code>.csv</code> file containing the specified dataset.</p>
<h1 id="wrap-up">Wrap Up</h1>
<p>In this tutorial, we have learned:</p>
<ul>
<li>To install FFmpeg on different operating systems and how to access the framework in the web-browser</li>
<li>The basic syntax and structure of FFmpeg commands</li>
<li>To view basic technical metadata of an audiovisual file</li>
<li>To transform an audiovisual file through transcoding and re-wrapping</li>
<li>To parse and edit that audiovisual file by demuxing it and creating excerpts</li>
<li>To playback audiovisual files using <code>ffplay</code></li>
<li>To create new video files with embedded vectorscopes</li>
<li>To export tabular data related to color from a video stream using <code>ffprobe</code></li>
<li>To craft a Bash for loop to extract color data information from multiple video files with one command</li>
</ul>
<p>At a broader level, this tutorial aspires to provide an informed and enticing introduction to how audiovisual tools and methodologies can be incorporated in Digital Humanities projects and practices. With open and powerful tools like FFmpeg, there is vast potential for expanding the scope of the field to include more rich and complex types of media and analysis than ever before.</p>
<h2 id="further-resources">Further Resources</h2>
<p>FFmpeg has a large and well-supported community of users across the globe. As such, there are many open-source and free resources for discovering new commands and techniques for working with audio-visual media. Please contact the author with any additions to this list, especially educational resources in Spanish for learning FFmpeg.</p>
<ul>
<li>The Official <a href="https://www.ffmpeg.org/ffmpeg.html">FFmpeg Documentation</a></li>
<li><a href="https://trac.ffmpeg.org/wiki/WikiStart">FFmpeg Wiki</a></li>
<li><a href="https://amiaopensource.github.io/ffmprovisr/">ffmprovisr</a> from the <a href="https://amianet.org/">Association of Moving Image Archivists</a></li>
<li>Ashley Blewer&#39;s <a href="https://training.ashleyblewer.com/">Audiovisual Preservation Training</a></li>
<li>Andrew Weaver&#39;s <a href="https://github.com/privatezero/NDSR/blob/master/Demystifying_FFmpeg_Slides.pdf">Demystifying FFmpeg</a></li>
<li>Ben Turkus&#39; <a href="https://docs.google.com/presentation/d/1NuusF948E6-gNTN04Lj0YHcVV9-30PTvkh_7mqyPPv4/present?ueb=true&amp;slide=id.g2974defaca_0_231">FFmpeg Presentation</a></li>
<li>Reto Kromer&#39;s <a href="https://avpres.net/FFmpeg/">FFmpeg Cookbook for Archivists</a></li>
</ul>
<h2 id="open-source-av-analysis-tools-using-ffmpeg">Open-Source AV Analysis Tools using FFmpeg</h2>
<ul>
<li><a href="https://mediaarea.net/en/MediaInfo">MediaInfo</a></li>
<li><a href="https://bavc.org/preserve-media/preservation-tools">QC Tools</a></li>
</ul>
<h1 id="references">References</h1>
<ul>
<li><p>Champion, E. (2017) “Digital Humanities is text heavy, visualization light, and simulation poor,” Digital Scholarship in the Humanities 32(S1), i25-i32.</p>
</li>
<li><p>Flueckiger, B. (2017). &quot;A Digital Humanities Approach to Film Colors&quot;. The Moving Image, 17(2), 71-94.</p>
</li>
<li><p>Hockey, S. (2004) “The History of Humanities Computing,” A Companion to Digital Humanities, ed. Susan Schreibman, Ray Siemens, John Unsworth. Oxford: Blackwell.</p>
</li>
</ul>
<div class="alert alert-warning">
 This tutorial was made possible with the support of the British Academy and written during the Programming Historian Workshop at La Universidad de Los Andes in Bogotá, Colombia, 31 July - 3 August, 2018.
</div>
<!-- HTML_TAG_END -->

<script type="application/json" data-type="svelte-data" data-url="introduction-to-ffmpeg/raw.json">{"status":200,"statusText":"","headers":{"content-type":"application/json; charset=utf-8"},"body":"{\"metadata\":{\"title\":\"Introduction to Audiovisual Transcoding, Editing, and Color Analysis with FFmpeg\",\"collection\":\"lessons\",\"layout\":\"lesson\",\"slug\":\"introduction-to-ffmpeg\",\"date\":\"2018-12-20T00:00:00.000Z\",\"authors\":[\"Dave Rodriguez\"],\"reviewers\":[\"Tesla Cariani\",\"Josh Romphf\"],\"editors\":[\"Brandon Walsh\"],\"review-ticket\":\"https:\u002F\u002Fgithub.com\u002Fprogramminghistorian\u002Fph-submissions\u002Fissues\u002F186\",\"difficulty\":2,\"activity\":\"analyzing\",\"topics\":[\"data-manipulation\"],\"abstract\":\"This lesson introduces the basic functions of FFmpeg, a free command-line tool used for manipulating and analyzing audiovisual materials.\",\"avatar_alt\":\"An antique camera\",\"doi\":\"10.46430\u002Fphen0077\"},\"html_body\":\"\u003Cp\u003E{% include toc.html %}\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"introduction\\\"\u003EIntroduction\u003C\u002Fh2\u003E\\n\u003Cp\u003EThe Digital Humanities, as a discipline, have historically focused almost exclusively on the analysis of textual sources through computational methods (Hockey, 2004). However, there is growing interest in the field around using computational methods for the analysis of audiovisual cultural heritage materials as indicated by the creation of the \u003Ca href=\\\"https:\u002F\u002Favindhsig.wordpress.com\u002F\\\"\u003EAlliance of Digital Humanities Organizations Special Interest Group: Audiovisual Materials in the Digital Humanities\u003C\u002Fa\u003E and \u003Ca href=\\\"https:\u002F\u002Ffigshare.com\u002Farticles\u002FAV_in_DH_State_of_the_Field\u002F5680114\\\"\u003Ethe rise in submissions related to audiovisual topics at the global ADHO conference\u003C\u002Fa\u003E over the past few years. Newer investigations, such as \u003Ca href=\\\"https:\u002F\u002Fdistantviewing.org\u002F\\\"\u003EDistant Viewing TV\u003C\u002Fa\u003E, also indicate a shift in the field toward projects concerned with using computational techniques to expand the scope of materials digital humanists can investigate. As Erik Champion states, &quot;The DH audience is not always literature-focused or interested in traditional forms of literacy,&quot; and applying digital methodologies to the study of audiovisual culture is an exciting and emerging facet of the discipline (Champion, 2017). There are many valuable, free, and open-source tools and resources available to those interested in working with audiovisual materials (for example, the Programming Historian tutorial \u003Ca href=\\\"\u002Fen\u002Flessons\u002Fediting-audio-with-audacity\\\"\u003EEditing Audio with Audacity\u003C\u002Fa\u003E), and this tutorial will introduce another: FFmpeg.\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ca href=\\\"https:\u002F\u002Fwww.ffmpeg.org\u002Fabout.html\\\"\u003EFFmpeg\u003C\u002Fa\u003E is &quot;the leading multimedia framework able to decode, encode, transcode, mux, demux, stream, filter, and play pretty much anything that humans and machines have created&quot; (FFmpeg Website - &quot;About&quot;). Many common software applications and websites use FFmpeg to handle reading and writing audiovisual files, including VLC, Google Chrome, YouTube, \u003Ca href=\\\"https:\u002F\u002Ftrac.ffmpeg.org\u002Fwiki\u002FProjects\\\"\u003Eand many more.\u003C\u002Fa\u003E In addition to being a software and web-developer tool, FFmpeg can be used at the command-line to perform many common, complex, and important tasks related to audiovisual file management, alteration, and analysis. These kinds of processes, such as editing,  transcoding (re-encoding), or extracting metadata from files, usually require access to other software (such as a non-linear video editor like Adobe Premiere or Final Cut Pro), but FFmpeg allows a user to operate on audiovisual files directly without the use of third-party software or interfaces. As such, knowledge of the framework empowers users to manipulate audiovisual materials to meet their needs with a free, open-source solution that carries much of the functionality of expensive audio and video editing software. This tutorial will provide an introduction to reading and writing FFmpeg commands and walk through a use-case for how the framework can be used in Digital Humanities scholarship (specifically, how FFmpeg can be used to extract and analyze color data from an archival video source).\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"learning-objectives\\\"\u003ELearning Objectives\u003C\u002Fh2\u003E\\n\u003Cul\u003E\\n\u003Cli\u003EInstall FFmpeg on your computer or use a demo version in your web browser\u003C\u002Fli\u003E\\n\u003Cli\u003EUnderstand the basic structure and syntax of FFmpeg commands\u003C\u002Fli\u003E\\n\u003Cli\u003EExecute several useful commands such as:\u003Cul\u003E\\n\u003Cli\u003ERe-wrapping (change file container) &amp; Transcoding (re-encode files)\u003C\u002Fli\u003E\\n\u003Cli\u003EDemuxing (separating audio and video tracks)\u003C\u002Fli\u003E\\n\u003Cli\u003ETrimming\u002FEditing files\u003C\u002Fli\u003E\\n\u003Cli\u003EFile playback with FFplay\u003C\u002Fli\u003E\\n\u003Cli\u003ECreating vectorscopes for color data visualization\u003C\u002Fli\u003E\\n\u003Cli\u003EGenerating color data reports with FFprobe\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003EIntroduce outside resources for further exploration and experimentation\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Ch2 id=\\\"prerequisites\\\"\u003EPrerequisites\u003C\u002Fh2\u003E\\n\u003Cp\u003EBefore starting this tutorial, you should be comfortable with locating and using your computer&#39;s \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FTerminal_(macOS)\\\"\u003ETerminal\u003C\u002Fa\u003E or other command-line interface, as this is where you will be entering and executing FFmpeg commands. If you need instruction on how to access and work at the command-line, I recommend the Program Historian&#39;s \u003Ca href=\\\"\u002Fen\u002Flessons\u002Fintro-to-bash\\\"\u003EBash tutorial\u003C\u002Fa\u003E for Mac and Linux users or the \u003Ca href=\\\"\u002Fen\u002Flessons\u002Fintro-to-powershell#quick-reference\\\"\u003EWindows PowerShell tutorial\u003C\u002Fa\u003E. Additionally, a basic understanding of audiovisual \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FCodec\\\"\u003Ecodecs\u003C\u002Fa\u003E and \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FDigital_container_format\\\"\u003Econtainers\u003C\u002Fa\u003E will also be useful to understanding what FFmpeg does and how it works. We will provide some additional information and discuss codecs and containers in a bit more detail in the Preliminary Command Examples section of this tutorial.\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"installing-ffmpeg\\\"\u003EInstalling FFmpeg\u003C\u002Fh1\u003E\\n\u003Cp\u003EInstalling FFmpeg can be the most difficult part of using FFmpeg. Thankfully, there are some helpful guides and resources available for installing the framework based on your operating system.\u003C\u002Fp\u003E\\n\u003Cdiv class=\\\"alert alert-warning\\\"\u003E\\nNew versions of FFmpeg are released approximately every 6 months. To keep track of these updates, follow FFmpeg on \u003Ca href=\\\"https:\u002F\u002Ftwitter.com\u002FFFmpeg\\\"\u003ETwitter\u003C\u002Fa\u003E or through its website. New versions of FFmpeg usually contain features such as new and updated filters, codec compatibilities, and bug fixes. The syntax of FFmpeg does not change with these updates and old capabilities are rarely removed. To get an idea of what kinds of features come with these updates, you can scroll through previous update announcements in the \u003Ca href=\\\"https:\u002F\u002Fwww.ffmpeg.org\u002Findex.html#news\\\"\u003ENews\u003C\u002Fa\u003E section of the FFmpeg website.\\n\u003C\u002Fdiv\u003E\\n\\n\u003Ch2 id=\\\"for-mac-os-users\\\"\u003EFor Mac OS Users\u003C\u002Fh2\u003E\\n\u003Cp\u003EThe simplest option is to use a package manager such as \u003Ca href=\\\"https:\u002F\u002Fbrew.sh\u002F\\\"\u003EHomebrew\u003C\u002Fa\u003E\\nto install FFmpeg and ensure it remains in the most up-to-date version. Homebrew is also useful in ensuring that your computer has the necessary dependencies installed to ensure FFMpeg runs properly. To complete this kind of installation, follow these steps:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Cp\u003EInstall Homebrew following the instructions in the above link\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003EYou can then run \u003Ccode\u003Ebrew install ffmpeg\u003C\u002Fcode\u003E in your Terminal to initiate a basic installation.\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Cstrong\u003ENote\u003C\u002Fstrong\u003E: Generally, it is recommended to install FFMpeg with additional features than what is included in the basic installation. Including additional options will provide access to more of FFmpeg&#39;s tools and functionalities. Reto Kromer&#39;s \u003Ca href=\\\"https:\u002F\u002Favpres.net\u002FFFmpeg\u002Finstall_Apple.html\\\"\u003EApple installation guide\u003C\u002Fa\u003E provides a good set of additional options:\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Ebrew install ffmpeg --with-sdl2 --with-freetype --with-openjpeg --with-x265 --with-rubberband --with-tesseract\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cul\u003E\\n\u003Cli\u003EFor an explanation of these additional options, refer to \u003Ca href=\\\"https:\u002F\u002Ftraining.ashleyblewer.com\u002Fpresentations\u002Fffmpeg.html#10\\\"\u003EAshley Blewer&#39;s FFmpeg guide\u003C\u002Fa\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003EAdditionally, you can run \u003Ccode\u003Ebrew options ffmpeg\u003C\u002Fcode\u003E to see what features are or have become available with the current FFmpeg release\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003EAfter installing, it is best practice to update Homebrew and FFmpeg to ensure all dependencies and features are most up-to-date by running:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Ebrew update &amp;&amp; brew upgrade ffmpeg\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003EFor more installation options for Mac OS, see the \u003Ca href=\\\"https:\u002F\u002Ftrac.ffmpeg.org\u002Fwiki\u002FCompilationGuide\u002FmacOS\\\"\u003EMac OS FFmpeg Compilation Guide\u003C\u002Fa\u003E\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Ch2 id=\\\"for-windows-users\\\"\u003EFor Windows Users\u003C\u002Fh2\u003E\\n\u003Cp\u003EWindows users can use the package manager \u003Ca href=\\\"https:\u002F\u002Fchocolatey.org\u002F\\\"\u003EChocolately\u003C\u002Fa\u003E to install and maintain FFmpeg. Reto Kromer&#39;s \u003Ca href=\\\"https:\u002F\u002Favpres.net\u002FFFmpeg\u002Finstall_Windows.html\\\"\u003EWindows installation guide\u003C\u002Fa\u003E provides all the necessary information to use Chocolately or to install the software from a build.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"for-linux-users\\\"\u003EFor Linux Users\u003C\u002Fh2\u003E\\n\u003Cp\u003E\u003Ca href=\\\"http:\u002F\u002Flinuxbrew.sh\u002F\\\"\u003ELinuxbrew\u003C\u002Fa\u003E, a program similar to Homebrew, can be used to\\ninstall and maintain FFmpeg in Linux. Reto Kromer also provides a helpful \u003Ca href=\\\"https:\u002F\u002Favpres.net\u002FFFmpeg\u002Finstall_Linux.html\\\"\u003ELinux installation guide\u003C\u002Fa\u003E\\nthat closely resembles the Mac OS installation. Your distribution of Linux may also have its \u003Ca href=\\\"https:\u002F\u002Fwww.linode.com\u002Fdocs\u002Ftools-reference\u002Flinux-package-management\u002F\\\"\u003Eown package manager\u003C\u002Fa\u003E already installed that include FFmpeg packages available. Depending on your distribution of Linux (Ubuntu, Fedora, Arch Linux, etc.) these builds can vary, so using Linuxbrew could be useful to ensure that the build is the same regardless of which type of Linux you are using.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"other-installation-resources\\\"\u003EOther Installation Resources\u003C\u002Fh2\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Ca href=\\\"https:\u002F\u002Fwww.ffmpeg.org\u002Fdownload.html\\\"\u003EDownload Packages\u003C\u002Fa\u003E\u003Cul\u003E\\n\u003Cli\u003EFFmpeg allows access to binary files, source code, and static builds for Mac, Windows, and Linux directly through its website, enabling users to build the framework without a package manager. It is likely that only advanced users will want to follow this option.\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ca href=\\\"https:\u002F\u002Ftrac.ffmpeg.org\u002Fwiki\u002FCompilationGuide\\\"\u003EFFmpeg Compilation Guide\u003C\u002Fa\u003E\u003Cul\u003E\\n\u003Cli\u003EThe FFmpeg Wiki page also provides a compendium of guides and strategies for building FFmpeg on your computer.\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Ch2 id=\\\"testing-the-installation\\\"\u003ETesting the Installation\u003C\u002Fh2\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Cp\u003ETo ensure FFmpeg is installed properly, run:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Effmpeg -version\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003EIf you see a long output of information, the installation was successful! It should look similar to this:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Effmpeg version 4.0.1 Copyright (c) 2000-2018 the FFmpeg developers\\nbuilt with Apple LLVM version 9.1.0 (clang-902.0.39.1)\\nconfiguration: --prefix=\u002Fusr\u002Flocal\u002FCellar\u002Fffmpeg\u002F4.0.1 --enable-shared --enable-pthreads --enable-version3 --enable-hardcoded-tables --enable-avresample --cc=clang --host-cflags= --host-ldflags= --enable-gpl --enable-ffplay --enable-libfreetype --enable-libmp3lame --enable-librubberband --enable-libtesseract --enable-libx264 --enable-libx265 --enable-libxvid --enable-opencl --enable-videotoolbox --disable-lzma --enable-libopenjpeg --disable-decoder=jpeg2000 --extra-cflags=-I\u002Fusr\u002Flocal\u002FCellar\u002Fopenjpeg\u002F2.3.0\u002Finclude\u002Fopenjpeg-2.3\\nlibavcodec     58. 18.100 \u002F 58. 18.100\\nlibavformat    58. 12.100 \u002F 58. 12.100\\nlibavdevice    58.  3.100 \u002F 58.  3.100\\nlibavfilter     7. 16.100 \u002F  7. 16.100\\nlibavresample   4.  0.  0 \u002F  4.  0.  0\\nlibswscale      5.  1.100 \u002F  5.  1.100\\nlibswresample   3.  1.100 \u002F  3.  1.100\\nlibpostproc    55.  1.100 \u002F 55.  1.100\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003EIf you see something like \u003Ccode\u003E-bash: ffmpeg: command not found\u003C\u002Fcode\u003E then something has\\ngone wrong.\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003ENote: If you are using a package manager it is unlikely that you will encounter this error message. However, if there is a problem after installing with a package manager, it is likely the issue is with the package manager itself as opposed to FFmpeg. Consult the Troubleshooting sections for \u003Ca href=\\\"https:\u002F\u002Fdocs.brew.sh\u002FTroubleshooting\\\"\u003EHomebrew\u003C\u002Fa\u003E, \u003Ca href=\\\"https:\u002F\u002Fchocolatey.org\u002Fdocs\u002Ftroubleshooting\\\"\u003EChocolatey\u003C\u002Fa\u003E, or \u003Ca href=\\\"http:\u002F\u002Flinuxbrew.sh\u002F\\\"\u003ELinuxbrew\u003C\u002Fa\u003E to ensure the package manager is functioning properly on your computer. If you are attempting to install without a package manager and see this error message, cross-reference your method with the FFmpeg Compilation Guide provided above.\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Ch2 id=\\\"using-ffmpeg-in-a-web-browser-without-installing\\\"\u003EUsing FFmpeg in a web browser (without installing)\u003C\u002Fh2\u003E\\n\u003Cp\u003EIf you do not want to install FFmpeg on your computer but would like to become familiar with using it at the command-line, Brian Grinstead&#39;s \u003Ca href=\\\"https:\u002F\u002Fbgrins.github.io\u002Fvideoconverter.js\u002Fdemo\u002F\\\"\u003Evideoconverter.js\u003C\u002Fa\u003E provides a way to run FFmpeg commands and learn its basic functions in the web-browser of your choice.\\n  \u003Cdiv class=\\\"alert alert-warning\\\"\u003E\\n  This browser-based interface does not have the functionality to complete the entirety of this tutorial but is useful for learning the basics of FFmpeg commands. Additionally, this resource runs on an older version of FFmpeg and may not contain all the features of the most recent version.\u003C\u002Fp\u003E\\n\u003C\u002Fdiv\u003E\\n# Basic Structure and Syntax of FFmpeg commands\\nBasic FFmepg commands consist of four elements:\\n\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003E[Command Prompt] [Input File] [Flags\u002FActions] [Output File]\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cul\u003E\\n\u003Cli\u003EA command prompt will begin every FFmpeg command. Depending on the use, this prompt will either be \u003Ccode\u003Effmpeg\u003C\u002Fcode\u003E (changing files), \u003Ccode\u003Effprobe\u003C\u002Fcode\u003E (gathering metadata from files), or \u003Ccode\u003Effplay\u003C\u002Fcode\u003E (playback of files).\u003C\u002Fli\u003E\\n\u003Cli\u003EInput files are the files being read, edited, or examined.\u003C\u002Fli\u003E\\n\u003Cli\u003EFlags and actions are the things you are telling FFmpeg to do the input files. Most commands will contain multiple flags and actions of various complexity.\u003C\u002Fli\u003E\\n\u003Cli\u003EThe output file is the new file created by the command or the report generated by an \u003Ccode\u003Effprobe\u003C\u002Fcode\u003E command.\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003EWritten generically, a basic FFmpeg command looks like this:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Effmpeg -i \u002Ffilepath\u002Finput_file.ext -flag some_action \u002Ffilepath\u002Foutput_file.ext\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cdiv class=\\\"alert alert-warning\\\"\u003EAs with any command-line interface, you will need to write out the filepath of the input and output files depending on location of your working directories. In the examples given in this tutorial, filepaths will not be fully written out and it is assumed that a user has navigated to the working directory containing the input files to execute the commands.\u003C\u002Fdiv\u003E\\n\\n\u003Cp\u003ENext, we will look at some examples of several different commands that use this structure and syntax. These commands will also demonstrate some of FFmpeg&#39;s most basic, useful functions and allow us to become more familiar with how digital audiovisual files are constructed.\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"getting-started\\\"\u003EGetting Started\u003C\u002Fh1\u003E\\n\u003Cp\u003EFor this tutorial, we will be taking an archival film called \u003Ca href=\\\"https:\u002F\u002Farchive.org\u002Fdetails\u002F4050_Destination_Earth_01_47_33_28\\\"\u003E\u003Cem\u003EDestination Earth\u003C\u002Fem\u003E\u003C\u002Fa\u003E as our object of study. This film has been made available by the \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FPrelinger_Archives\\\"\u003EPrelinger Archives\u003C\u002Fa\u003E collection on the \u003Ca href=\\\"https:\u002F\u002Farchive.org\u002F\\\"\u003EInternet Archive\u003C\u002Fa\u003E. Released in 1956, this film is a prime example of Cold War-era propaganda produced by the \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FAmerican_Petroleum_Institute\\\"\u003EAmerican Petroleum Institute\u003C\u002Fa\u003E and \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FJohn_Sutherland_(producer)\\\"\u003EJohn Sutherland Productions\u003C\u002Fa\u003E that extols the virtues of capitalism and the American way of life. Utilizing the \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FTechnicolor\\\"\u003ETechnicolor\u003C\u002Fa\u003E process, this science-fiction animated short tells a story of a Martian society living under an oppressive government and their efforts to improve their industrial methods. They send an emissary to Earth who discovers the key to this is oil refining and free-enterprise. We will be using this video to introduce some of the basic functionalities of FFmpeg and analyzing its color properties in relation to its propagandist rhetoric.\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;destEarth_titlecard.png&quot; caption=&quot;Destination Earth (1956)&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EFor this tutorial, you will need to:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003ENavigate to the \u003Ca href=\\\"https:\u002F\u002Farchive.org\u002Fdetails\u002F4050_Destination_Earth_01_47_33_28\\\"\u003E\u003Cem\u003EDestination Earth\u003C\u002Fem\u003E\u003C\u002Fa\u003E page on IA\u003C\u002Fli\u003E\\n\u003Cli\u003EDownload two video files: the &quot;MPEG4&quot; (file extension \u003Ccode\u003E.m4v\u003C\u002Fcode\u003E) and &quot;OGG&quot; (file extension \u003Ccode\u003E.ogv\u003C\u002Fcode\u003E) versions of the film\u003C\u002Fli\u003E\\n\u003Cli\u003ESave these two video files in the same folder somewhere on your computer. Save them with the file names \u003Ccode\u003EdestEarth\u003C\u002Fcode\u003E followed by its extension\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003ETake a few minutes to watch the video and get a sense of its structure, message, and visual motifs before moving on with the next commands.\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"preliminary-command-examples\\\"\u003EPreliminary Command Examples\u003C\u002Fh1\u003E\\n\u003Ch2 id=\\\"viewing-basic-metadata-with-ffprobe\\\"\u003EViewing Basic Metadata with FFprobe\u003C\u002Fh2\u003E\\n\u003Cp\u003EBefore we begin manipulating our \u003Ccode\u003EdestEarth\u003C\u002Fcode\u003E files, let&#39;s use FFmpeg to examine some basic information about the file itself using a simple \u003Ccode\u003Effprobe\u003C\u002Fcode\u003E command. This will help illuminate how digital audiovisual files are constructed and provide a foundation for the rest of the tutorial. Navigate to the file&#39;s directory and execute:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Effprobe destEarth.ogv\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EYou will see the file&#39;s basic technical metadata printed in the \u003Ccode\u003Estdout\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;ffprobe_ogg.png&quot; caption=&quot;The output of a basic \u003Ccode\u003Effprobe\u003C\u002Fcode\u003E command with destEarth.ogv&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EThe \u003Ccode\u003EInput #0\u003C\u002Fcode\u003E line of the reports identifies the \u003Cstrong\u003Econtainer\u003C\u002Fstrong\u003E as \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FOgg\\\"\u003Eogg\u003C\u002Fa\u003E. Containers (also called &quot;wrappers&quot;) provide the file with structure for its various streams. Different containers (other common ones include \u003Ccode\u003E.mkv\u003C\u002Fcode\u003E, \u003Ccode\u003E.avi\u003C\u002Fcode\u003E, and \u003Ccode\u003E.flv\u003C\u002Fcode\u003E) have different features and compatibilities with various software. We will examine how and why you might want to change a file&#39;s container in the next command.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe lines \u003Ccode\u003EStream #0:0\u003C\u002Fcode\u003E and \u003Ccode\u003EStream #0:1\u003C\u002Fcode\u003E provide information about the file&#39;s streams (i.e. the content you see on screen and hear through your speakers) and identify the \u003Cstrong\u003Ecodec\u003C\u002Fstrong\u003E of each stream as well. Codecs specify how information is encoded\u002Fcompressed (written and stored) and decoded\u002Fdecompressed (played back). Our \u003Ccode\u003E.ogv\u003C\u002Fcode\u003E file&#39;s video stream (\u003Ccode\u003EStream #0:0\u003C\u002Fcode\u003E) uses the \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FTheora\\\"\u003Etheora\u003C\u002Fa\u003E codec while the audio stream (\u003Ccode\u003EStream #0:1\u003C\u002Fcode\u003E) uses the \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FVorbis\\\"\u003Evorbis\u003C\u002Fa\u003E codec. These lines also provide important information related to the video stream&#39;s colorspace (\u003Ccode\u003Eyuv420p\u003C\u002Fcode\u003E), resolution (\u003Ccode\u003E400x300\u003C\u002Fcode\u003E), and frame-rate (\u003Ccode\u003E29.97 fps\u003C\u002Fcode\u003E), in addition to audio information such as sample-rate (\u003Ccode\u003E44100 Hz\u003C\u002Fcode\u003E) and bit-rate (\u003Ccode\u003E128 kb\u002Fs\u003C\u002Fcode\u003E).\u003C\u002Fp\u003E\\n\u003Cp\u003ECodecs, to a much greater extent than containers, determine an audiovisual file&#39;s quality and compatibility with different software and platforms (other common codecs include \u003Ccode\u003EDNxHD\u003C\u002Fcode\u003E and \u003Ccode\u003EProRes\u003C\u002Fcode\u003E for video and \u003Ccode\u003Emp3\u003C\u002Fcode\u003E and \u003Ccode\u003EFLAC\u003C\u002Fcode\u003E for audio). We will examine how and why you might want to change a file&#39;s codec in the next command as well.\u003C\u002Fp\u003E\\n\u003Cp\u003ERun another \u003Ccode\u003Effprobe\u003C\u002Fcode\u003E command, this time with the \u003Ccode\u003E.m4v\u003C\u002Fcode\u003E file:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Effprobe destEarth.m4v\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EAgain you&#39;ll see the basic technical metadata printed to the \u003Ccode\u003Estdout\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;ffprobe_mp4.png&quot; caption=&quot;The output of a basic \u003Ccode\u003Effprobe\u003C\u002Fcode\u003E command with destEarth.m4v&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EYou&#39;ll also notice that the report for the \u003Ccode\u003E.m4v\u003C\u002Fcode\u003E file contains multiple containers on the \u003Ccode\u003EInput #0\u003C\u002Fcode\u003E line like \u003Ccode\u003Emov\u003C\u002Fcode\u003E and \u003Ccode\u003Em4a\u003C\u002Fcode\u003E. It isn&#39;t necessary to get too far into the details for the purposes of this tutorial, but be aware that the \u003Ccode\u003Emp4\u003C\u002Fcode\u003E and  \u003Ccode\u003Emov\u003C\u002Fcode\u003E containers come in many &quot;flavors&quot; and different file extensions. However, they are all very similar in their technical construction, and as such you may see them grouped together in technical metadata. Similarly, the \u003Ccode\u003Eogg\u003C\u002Fcode\u003E file has the extension \u003Ccode\u003E.ogv\u003C\u002Fcode\u003E, a &quot;flavor&quot; or variant of the \u003Ccode\u003Eogg\u003C\u002Fcode\u003E format.\u003C\u002Fp\u003E\\n\u003Cp\u003EJust as in our previous command, the lines \u003Ccode\u003EStream #0:0\u003C\u002Fcode\u003E and \u003Ccode\u003EStream #0:1\u003C\u002Fcode\u003E  identify the codec of each stream. We can see our \u003Ccode\u003E.m4v\u003C\u002Fcode\u003E file uses the \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FH.264\u002FMPEG-4_AVC\\\"\u003EH.264\u003C\u002Fa\u003E video codec while the audio stream uses the \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FAdvanced_Audio_Coding\\\"\u003Eaac\u003C\u002Fa\u003E codec. Notice that we are given similar metadata to our \u003Ccode\u003E.ogv\u003C\u002Fcode\u003E file but some important features related to visual analysis (such as the resolution) are significantly different. Our \u003Ccode\u003E.m4v\u003C\u002Fcode\u003E has a much higher resolution (\u003Ccode\u003E640x480\u003C\u002Fcode\u003E) and we will therefore use this version of \u003Cem\u003EDestination Earth\u003C\u002Fem\u003E as our source video.\u003C\u002Fp\u003E\\n\u003Cp\u003ENow that we know more about the technical make-up of our file, we can begin exploring the transformative features and functionalities of FFmpeg (we will use \u003Ccode\u003Effprobe\u003C\u002Fcode\u003E again later in the tutorial to conduct more advanced color metadata extraction).\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"changing-containers-and-codecs-re-wrap-and-transcode\\\"\u003EChanging Containers and Codecs (Re-Wrap and Transcode)\u003C\u002Fh2\u003E\\n\u003Cp\u003EDepending on your operating system, you may have one or more media players installed. For the purposes of demonstration, let&#39;s see what happens if you try to open \u003Ccode\u003EdestEarth.ogv\u003C\u002Fcode\u003E using the QuickTime media player that comes with Mac OSX:\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;QT_fail.png&quot; caption=&quot;Proprietary media players such as QuickTime are often limited in the kinds of files they can work with.&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EOne option when faced with such a message is to simply use another media player. \u003Ca href=\\\"https:\u002F\u002Fwww.videolan.org\u002Fvlc\u002Findex.html\\\"\u003EVLC\u003C\u002Fa\u003E, which is built with FFmpeg, is an excellent open-source alternative, but simply &quot;using another software&quot; may not always be a viable solution (and you may not always have another version of a file to work with, either). Many popular video editors such as Adobe Premiere, Final Cut Pro, and DaVinci Resolve all have their own limitations on the kinds of formats they are compatible with. Further, different web-platforms and hosting\u002Fstreaming sites such as Vimeo have \u003Ca href=\\\"https:\u002F\u002Fvimeo.com\u002Fhelp\u002Fcompression\\\"\u003Etheir own requirements as well.\u003C\u002Fa\u003E As such, it is important to be able to re-wrap and transcode your files to meet the various specifications for playback, editing, digital publication, and conforming files to standards required by digital preservation or archiving platforms.\u003C\u002Fp\u003E\\n\u003Cdiv class=\\\"alert alert-warning\\\"\u003E\\nFor a complete list of codecs and containers supported by your installation of FFmpeg, run \u003Ccode\u003Effmpeg -codecs\u003C\u002Fcode\u003E and \u003Ccode\u003Effmpeg -formats\u003C\u002Fcode\u003E, respectively, to see the list printed to your \u003Ccode\u003Estdout\u003C\u002Fcode\u003E.\\n\u003C\u002Fdiv\u003E\\n\\n\u003Cp\u003EAs an exercise in learning basic FFmpeg syntax and learning how to transcode between formats, we will begin with our \u003Ccode\u003EdestEarth.ogv\u003C\u002Fcode\u003E file and write a new file with video encoded to \u003Ccode\u003EH.264\u003C\u002Fcode\u003E, audio to \u003Ccode\u003EAAC\u003C\u002Fcode\u003E, and wrapped in an \u003Ccode\u003E.mp4\u003C\u002Fcode\u003E container, a very common and highly-portable combination of codecs and container that is practically identical to the \u003Ccode\u003E.m4v\u003C\u002Fcode\u003E file we originally downloaded. Here is the command you will execute along with an explanation of each part of the syntax:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Effmpeg -i destEarth.ogv -c:v libx264 -c:a aac destEarth_transcoded.mp4\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Ccode\u003Effmpeg\u003C\u002Fcode\u003E = starts the command\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E-i destEarth.ogv\u003C\u002Fcode\u003E = specifies the input file\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E-c:v libx264\u003C\u002Fcode\u003E = transcodes the video stream to the H.264 codec\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E-c:a aac\u003C\u002Fcode\u003E = transcodes the audio stream to the AAC codec\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003EdestEarth_transcoded.mp4\u003C\u002Fcode\u003E = specifies the output file. Note this is where the new container type is specified.\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003EIf you execute this command as it is written and in the same directory as \u003Ccode\u003EdestEarth.ogv\u003C\u002Fcode\u003E, you will see a new file called \u003Ccode\u003EdestEarth_transcoded.mp4\u003C\u002Fcode\u003E appear in the directory. If you are operating in Mac OSX, you will also be able to play this new file with QuickTime. A full exploration of codecs, containers, compatibility, and file extension conventions is beyond the scope of this tutorial, however this preliminary set of examples should give those less familiar with how digital audiovisual files are constructed a baseline set of knowledge that will enable them to complete the rest of the tutorial.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"creating-excerpts--demuxing-audio--video\\\"\u003ECreating Excerpts &amp; Demuxing Audio &amp; Video\u003C\u002Fh2\u003E\\n\u003Cp\u003ENow that we have a better understanding of streams, codecs, and containers, let&#39;s look at ways FFmpeg can help us work with video materials at a more granular level. For this tutorial, we will examine two discrete sections of \u003Cem\u003EDestination Earth\u003C\u002Fem\u003E to compare how color is used in relation to the film&#39;s propagandist rhetoric. We will create and prepare these excerpts for analysis using a command that performs two different functions simultaneously:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003EFirst, the command will create two excerpts from \u003Ccode\u003EdestEarth.m4v\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\\n\u003Cli\u003ESecond, the command will remove (&quot;demux&quot;) the audio components (\u003Ccode\u003EStream #0:1\u003C\u002Fcode\u003E) from these excerpts.\u003Cdiv class=\\\"alert alert-warning\\\"\u003E\\n  We are removing the audio in the interest of promoting good practice in saving storage space (the audio information is not necessary for color analysis). This will likely be useful if you hope to use this kind of analysis at larger scales. More on scaling color analysis will be provided near the end of the tutorial.\\n\u003C\u002Fdiv\u003E\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003EThe first excerpt we will be making is a sequence near the beginning of the film depicting the difficult conditions and downtrodden life of the Martian society. The following command specifies start and end points of the excerpt, tells FFmpeg to retain all information in the video stream without transcoding anything, and to write our new file without the audio stream:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Effmpeg -i destEarth.m4v -ss 00:01:00 -to 00:04:35 -c:v copy -an destEarth_Mars_video.mp4\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Ccode\u003Effmpeg\u003C\u002Fcode\u003E = starts the command\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E-i destEarth.m4v\u003C\u002Fcode\u003E = specifies the input file\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E-ss 00:01:00\u003C\u002Fcode\u003E = sets start point at 1 minute from start of file\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E-to 00:04:45\u003C\u002Fcode\u003E = sets end point to 4 minutes and 45 seconds from start of file\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E-c:v copy\u003C\u002Fcode\u003E = copy the video stream directly, without transcoding\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E-an\u003C\u002Fcode\u003E = tells FFmpeg to ignore audio stream when writing the output file.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003EdestEarth_Mars_video.mp4\u003C\u002Fcode\u003E = specifies the output file\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;Mars_screenshot.png&quot; caption=&quot;Life on Mars&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EWe will now run a similar command to create an &quot;Earth&quot; excerpt. This portion of the film has a similar sequence depicting the wonders of life on Earth and the richness of its society thanks to free-enterprise capitalism and the use of oil and petroleum products:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Effmpeg -i destEarth.m4v -ss 00:07:30 -to 00:11:05 -c:v copy -an destEarth_Earth_video.mp4\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;Earth_screenshot.png&quot; caption=&quot;Bounty of Earth&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EYou should now have two new files in your directory called \u003Ccode\u003EdestEarth_Mars_video.mp4\u003C\u002Fcode\u003E and \u003Ccode\u003EdestEarth_Earth_video.mp4\u003C\u002Fcode\u003E. You can test one or both files (or any of the other files in the directory) using the \u003Ccode\u003Effplay\u003C\u002Fcode\u003E feature of FFmpeg as well. Simply run:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Effplay destEarth_Mars_video.mp4\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003Eand\u002For\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Effplay destEarth_Earth_video.mp4\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EYou will see a window open and the video will begin at the specified start point, play through once, and then close (in addition, you&#39;ll notice there is no sound in your video). You will also notice that \u003Ccode\u003Effplay\u003C\u002Fcode\u003E commands do not require an \u003Ccode\u003E-i\u003C\u002Fcode\u003E or an output to be specified because the playback itself is the output.\u003C\u002Fp\u003E\\n\u003Cdiv class=\\\"alert alert-warning\\\"\u003E\\n\u003Ccode\u003EFFplay\u003C\u002Fcode\u003E is a very versatile media player that comes with a number of \u003Ca href=\\\"https:\u002F\u002Fffmpeg.org\u002Fffplay.html#Options\\\"\u003Eoptions\u003C\u002Fa\u003E for customizing playback. For example, adding `-loop 0` to the command will loop playback indefinitely.\u003C\u002Fdiv\u003E\\n\\n\u003Cp\u003EWe have now created our two excerpts for analysis. If we watch these clips discretely, there appear to be significant, meaningful differences in the way color and color variety are used. In the next part of the tutorial, we will examine and extract data from the video files to quantify and support this hypothesis.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"color-data-analysis\\\"\u003EColor Data Analysis\u003C\u002Fh2\u003E\\n\u003Cp\u003EThe use of \u003Ca href=\\\"https:\u002F\u002Fweb.archive.org\u002Fweb\u002F20180317223950\u002Fhttps:\u002F\u002Ffilmcolors.org\u002F2018\u002F03\u002F08\u002Fvian\u002F\\\"\u003Edigital tools to analyze color information\u003C\u002Fa\u003E in motion pictures is another emerging facet of DH scholarship that overlaps with traditional film studies. The \u003Ca href=\\\"https:\u002F\u002Ffilmcolors.org\u002F\\\"\u003EFilmColors\u003C\u002Fa\u003E project, in particular, at the University of Zurich, interrogates the critical intersection of film&#39;s &quot;formal aesthetic features to [the] semantic, historical, and technological aspects&quot; of its production, reception, and dissemination through the use of digital analysis and annotation tools (Flueckiger, 2017). Although there is no standardized method for this kind of investigation at the time of this writing, the \u003Ccode\u003Effprobe\u003C\u002Fcode\u003E command offered below is a powerful tool for extracting information related to color that can be used in computational analysis. First, let&#39;s look at another standardized way of representing color information that informs this quantitative, data-driven approach to color analysis.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"vectorscopes\\\"\u003EVectorscopes\u003C\u002Fh3\u003E\\n\u003Cp\u003EFor years, video professionals have relied on \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FVectorscope#Video\\\"\u003Evectorscopes\u003C\u002Fa\u003E to view color information in a standardized and easily legible way. A vectorscope plots color information on a circular graticle, and the position of a given plot corresponds to the particular \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FHue\\\"\u003Ehues\u003C\u002Fa\u003E found in a video signal. Other factors, like saturation, determine the size of a given plot as well. Below is an example of a vectorscope displaying the color values of SMPTE Bars, which are also pictured.\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;vectorscope.png&quot; caption=&quot;A vectorscope read-out representing standard NTSC SMPTE Bars. Source: Wikimedia Commons&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;smpte_bars.png&quot; caption=&quot;NTSC SMPTE Bars. Source: Wikimedia Commons&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EFFmpeg can be used to playback and create video files with vectorscopes embedded in them so as to provide a real-time reference for the video&#39;s color information. The following \u003Ccode\u003Effplay\u003C\u002Fcode\u003E commands will embed a vectorscope in the lower-right corner of the frame. As the video plays, you will notice the vectorscope plot shift as the on-screen color shifts:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Effplay destEarth_Mars_video.mp4 -vf &quot;split=2[m][v], [v]vectorscope=b=0.7:m=color3:g=green[v],[m][v]overlay=x=W-w:y=H-h&quot;\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Ccode\u003Effplay\u003C\u002Fcode\u003E = starts the command\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003EdestEarth_Mars_video.mp4\u003C\u002Fcode\u003E = specifies the input file\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E-vf\u003C\u002Fcode\u003E = creates a \u003Ca href=\\\"https:\u002F\u002Ftrac.ffmpeg.org\u002Fwiki\u002FFilteringGuide\\\"\u003Efilter-graph\u003C\u002Fa\u003E to use for the streams\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E&quot;\u003C\u002Fcode\u003E = quotation mark to start the filter-graph. Information inside the quotation marks will specify the parameters of the vectorscope&#39;s appearance and position.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003Esplit=2[m][v]\u003C\u002Fcode\u003E = splits the input into two identical outputs called \u003Ccode\u003E[m]\u003C\u002Fcode\u003E and \u003Ccode\u003E[v]\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E,\u003C\u002Fcode\u003E = comma signifies another parameter is coming\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E[v]vectorscope=b=0.7:m=color3:g=green[v]\u003C\u002Fcode\u003E = assigns the \u003Ccode\u003E[v]\u003C\u002Fcode\u003E output the vectorscope filter. The \u003Ccode\u003Eb\u003C\u002Fcode\u003E flag specifies the vectorscope&#39;s background opacity, the \u003Ccode\u003Em\u003C\u002Fcode\u003E flag the vectorscope mode, and the \u003Ccode\u003Eg\u003C\u002Fcode\u003E flag the color of the graticle.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E[m][v]overlay=x=W-w:y=H-h\u003C\u002Fcode\u003E = overlays the vectorscope on top of the video image (the \u003Ccode\u003E[m]\u003C\u002Fcode\u003E output) in a certain location determined by x:y coordinates. In this case, the vectorscope will be justified to the lower right corner of the frame.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E&quot;\u003C\u002Fcode\u003E = ends the filter-graph\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cdiv class=\\\"alert alert-warning\\\"\u003E\\nFor more information on the various options for creating vectorscopes, see \u003Ca href=\\\"https:\u002F\u002Fffmpeg.org\u002Fffmpeg-filters.html#vectorscope\\\"\u003Ethe official Documentation\u003C\u002Fa\u003E and the \u003Ca href=\\\"https:\u002F\u002Ftrac.ffmpeg.org\u002Fwiki\u002FVectorscope\\\"\u003EFFmpeg Vectorscope Wiki Page\u003C\u002Fa\u003E. Additionally, more information on how to position overlays can be found in the \u003Ca href=\\\"https:\u002F\u002Fffmpeg.org\u002Fffmpeg-filters.html#overlay-1\\\"\u003EFFmpeg overlay filter Documentation\u003C\u002Fa\u003E.\\n\u003C\u002Fdiv\u003E\\n\\n\u003Cp\u003E{% include figure.html filename=&quot;Mars_screenshot_vector.png&quot; caption=&quot;Screenshot of FFplay window with embedded vectorscope&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EAnd for the &quot;Earth&quot; excerpt:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Effplay destEarth_Earth_video.mp4 -vf &quot;split=2[m][v], [v]vectorscope=b=0.7:m=color3:g=green[v],[m][v]overlay=x=W-w:y=H-h&quot;\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;Earth_screenshot_vector.png&quot; caption=&quot;Screenshot of FFplay window with embedded vectorscope&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EWe can also adjust this command to write new video files with vectorscopes as well:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Effmpeg -i destEarth_Mars_video.mp4 -vf &quot;split=2[m][v], [v]vectorscope=b=0.7:m=color3:g=green[v],[m][v]overlay=x=W-w:y=H-h&quot; -c:v libx264 destEarth_Mars_vectorscope.mp4\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Effmpeg -i destEarth_Earth_video.mp4 -vf &quot;split=2[m][v], [v]vectorscope=b=0.7:m=color3:g=green[v],[m][v]overlay=x=W-w:y=H-h&quot; -c:v libx264 destEarth_Earth_vectorscope.mp4\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ENote the slight but important changes in syntax:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003EWe have added an \u003Ccode\u003E-i\u003C\u002Fcode\u003E flag because it is an \u003Ccode\u003Effmpeg\u003C\u002Fcode\u003E command.\u003C\u002Fli\u003E\\n\u003Cli\u003EWe have specified the output video codec as \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FH.264\u002FMPEG-4_AVC\\\"\u003EH.264\u003C\u002Fa\u003E with the flag \u003Ccode\u003E-c:v libx264\u003C\u002Fcode\u003E and have left out an option for audio. Although you could add \u003Ccode\u003E-c:a copy\u003C\u002Fcode\u003E to copy the audio stream (if there is one in the input file) without transcoding or specify another audio codec here if necessary.\u003C\u002Fli\u003E\\n\u003Cli\u003EWe have specified the name of the output file.\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003ETake a few minutes to watch these videos with the vectorscopes embedded in them. Notice how dynamic (or not) the changes are between the &quot;Mars&quot; and &quot;Earth&quot; excerpts. Compare what you see in the vectorscope to your own impressions of the video itself. We might use observations from these vectorscopes to make determinations about which shades of color appear more regularly or intensely in a given source video, or we may compare different formats side-by-side to see how color gets encoded or represented differently based on different codecs, resolutions, etc.\u003C\u002Fp\u003E\\n\u003Cp\u003EAlthough vectorscopes provide a useful, real-time representation of color information, we may want to also access the raw data beneath them. We can then use this data to develop more flexible visualizations that are not dependent on viewing the video file simultaneously and that offer a more quantitative approach to color analysis. In our next commands, we will use \u003Ccode\u003Effprobe\u003C\u002Fcode\u003E to produce a tabular dataset that can be used to create a graph of color data.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"color-data-extraction-with-ffprobe\\\"\u003EColor Data Extraction with FFprobe\u003C\u002Fh3\u003E\\n\u003Cp\u003EAt the beginning of this tutorial, we used an \u003Ccode\u003Effprobe\u003C\u002Fcode\u003E command to view our file&#39;s basic metadata printed to the \u003Ccode\u003Estdout\u003C\u002Fcode\u003E. In these next examples, we&#39;ll use \u003Ccode\u003Effprobe\u003C\u002Fcode\u003E to extract color data from our video excerpts and output this information to \u003Ccode\u003E.csv\u003C\u002Fcode\u003E files. Within our \u003Ccode\u003Effprobe\u003C\u002Fcode\u003E command, we are going to use the \u003Ccode\u003Esignalstats\u003C\u002Fcode\u003E filter to create \u003Ccode\u003E.csv\u003C\u002Fcode\u003E reports of median color \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FHue\\\"\u003Ehue\u003C\u002Fa\u003E information for each frame in the video stream of \u003Ccode\u003EdestEarth_Mars_video.mp4\u003C\u002Fcode\u003E and \u003Ccode\u003EdestEarth_Earth_video.mp4\u003C\u002Fcode\u003E, respectively.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Effprobe -f lavfi -i movie=destEarth_Mars_video.mp4,signalstats -show_entries frame=pkt_pts_time:frame_tags=lavfi.signalstats.HUEMED -print_format csv &gt; destEarth_Mars_hue.csv\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Ccode\u003Effprobe\u003C\u002Fcode\u003E = starts the command\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E-f lavfi\u003C\u002Fcode\u003E = specifies the \u003Ca href=\\\"https:\u002F\u002Fffmpeg.org\u002Fffmpeg-devices.html#lavfi\\\"\u003Elibavfilter\u003C\u002Fa\u003E virtual input device as the chosen format. This is necessary when using \u003Ccode\u003Esignalstats\u003C\u002Fcode\u003E and many filters in more complex FFmpeg commands.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E-i movie=destEarth_Mars_video.mp4\u003C\u002Fcode\u003E = name of input file\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E,signalstats\u003C\u002Fcode\u003E = specifies use of the \u003Ccode\u003Esignalstats\u003C\u002Fcode\u003E filter with the input file\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E-show_entries\u003C\u002Fcode\u003E = sets list of entries that will be shown in the report. These are specified by the next options.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003Eframe=pkt_pts_time\u003C\u002Fcode\u003E = specifies showing each frame with its corresponding \u003Ccode\u003Epkt_pts_time\u003C\u002Fcode\u003E, creating a unique entry for each frame of video\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E:frame_tags=lavfi.signalstats.HUEMED\u003C\u002Fcode\u003E = creates a tag for each frame that contains the median hue value\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E-print_format csv\u003C\u002Fcode\u003E = specifies the format of the metadata report\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E&gt; destEarth_Mars_hue.csv\u003C\u002Fcode\u003E = writes a new \u003Ccode\u003E.csv\u003C\u002Fcode\u003E file containing the metadata report using \u003Ccode\u003E&gt;\u003C\u002Fcode\u003E, a Bash \u003Ca href=\\\"https:\u002F\u002Fwww.gnu.org\u002Fsoftware\u002Fbash\u002Fmanual\u002Fhtml_node\u002FRedirections.html\\\"\u003Eredirection operator\u003C\u002Fa\u003E. Simply, this operator takes the command the precedes it and &quot;redirects&quot; the output to another location. In this instance, it is writing the output to a new \u003Ccode\u003E.csv\u003C\u002Fcode\u003E file. The file extension provided here should also match the format specified by the \u003Ccode\u003Eprint_format\u003C\u002Fcode\u003E flag\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003ENext, run the same command for the &quot;Earth&quot; excerpt:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Effprobe -f lavfi -i movie=destEarth_Earth_video.mp4,signalstats -show_entries frame=pkt_pts_time:frame_tags=lavfi.signalstats.HUEMED -print_format csv &gt; destEarth_Earth_hue.csv\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cdiv class=\\\"alert alert-warning\\\"\u003E\\nFor more information about the \u003Ccode\u003Esignalstats\u003C\u002Fcode\u003E filter and the various metrics that can be extracted from video streams, refer to the FFmpeg's \u003Ca href=\\\"https:\u002F\u002Fffmpeg.org\u002Fffmpeg-filters.html#signalstats-1\\\"\u003EFilters Documentation\u003C\u002Fa\u003E.\\n\u003C\u002Fdiv\u003E\\n\\n\u003Cp\u003EYou should now have two \u003Ccode\u003E.csv\u003C\u002Fcode\u003E files in your directory. If you open these in a text editor or spreadsheet program, you will see three columns of data:\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;csv_head.png&quot; caption=&quot;The first several rows of our Earth excerpt color report in .csv format&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EGoing from left to right, the first two columns give us information about where we are in the video. The decimal numbers represent fractions of a second that also roughly correspond to the video&#39;s time-base of 30fps. As such, each row in our \u003Ccode\u003E.csv\u003C\u002Fcode\u003E corresponds to one frame of video. The third column carries a whole number between 0-360, and this value represents the median hue for that frame of video. These numbers are the underlying quantitative data of the vectorscope&#39;s plot and correspond to its position (in radians) on the circular graticle. Referencing our vectorscope image from earlier, you can see that starting at the bottom of the circle (0 degrees) and moving left, &quot;greens&quot; are around 38 degrees, &quot;yellows&quot; at 99 degrees, &quot;reds&quot; at 161 degrees, &quot;magentas&quot; at 218 degrees, &quot;blues&quot; at 279 degrees, and &quot;cyans&quot; at 341 degrees. Once you understand these &quot;ranges&quot; of hue, you can get an idea of what the median hue value for a given video frame is just by looking at this numerical value.\u003C\u002Fp\u003E\\n\u003Cp\u003EAdditionally, It is worth noting that this value extracted by the \u003Ccode\u003Esignalstats\u003C\u002Fcode\u003E filter is not an absolute or complete measure of an image&#39;s color qualities, but simply a meaningful point of reference from which we can explore a data-driven approach to color analysis. Color perception and color theory are \u003Ca href=\\\"https:\u002F\u002Fcolourturn.net\u002F\\\"\u003Ecomplex, evolving areas of scholarly investigation\u003C\u002Fa\u003E that incorporate many different approaches from the humanities, social sciences, and cognitive sciences. As such, we should be mindful that any analytical approach should be taken within the context of these larger discourses and with a collaborative and generative spirit.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"graphing-color-data\\\"\u003EGraphing Color Data\u003C\u002Fh3\u003E\\n\u003Cp\u003EThe two \u003Ccode\u003E.csv\u003C\u002Fcode\u003E files we created with the previous commands can now be used to create graphs visualizing the data. There are a number of platforms (both proprietary and open-source) that can be used to achieve this such as \u003Ca href=\\\"https:\u002F\u002Fwww.wikihow.com\u002FCreate-a-Graph-in-Excel\\\"\u003EMicrosoft Excel\u003C\u002Fa\u003E, \u003Ca href=\\\"https:\u002F\u002Frawgraphs.io\u002F\\\"\u003ERAWGraphs\u003C\u002Fa\u003E, and\u002For \u003Ca href=\\\"https:\u002F\u002Fplot.ly\u002F\\\"\u003Eplot.ly\u003C\u002Fa\u003E. An in-depth discussion of how to use any of these platforms is outside the scope of this tutorial, however, the final visualization of the previous commands (below) was created by uploading the \u003Ccode\u003E.csv\u003C\u002Fcode\u003E files to plot.ly, an open-source, browser-based service that offers a number of \u003Ca href=\\\"https:\u002F\u002Fhelp.plot.ly\u002Ftutorials\u002F\\\"\u003Etutorials\u003C\u002Fa\u003E on how to use their platform.\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;Final_Graph_plotly.png&quot; caption=&quot;Graph including median hue data from both video excerpts&quot; %}\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"conclusions\\\"\u003EConclusions\u003C\u002Fh3\u003E\\n\u003Cp\u003EFrom looking at the graph, we can see that the Mars and Earth traces have very different dynamic ranges in their median hue values. The Mars trace is very limited and keeps within the red and yellow ranges (roughly between 100 - 160) throughout the majority of the excerpt. This suggests something about the film&#39;s use of color as a rhetorical device serving a propagandist message. Remember that this section presents an antipathetic view of the Martian way of life and political system: a uniform, unhappy populace who are dependent on inefficient technology and transportation while being required to observe total obedience to a totalitarian overlord. The film connects this negative experience to a relatively dull color palette of reds and yellows. We should also consider the original target audience of this film, young citizens of the United States in the 1950s, and how they would have likely interpreted these images and uses of color in that historical moment, namely, in the context of increasing geopolitical tensions between the Soviet Union and the United States and its allies in Western Europe. The color red, specifically, was commonly used in print and broadcast media for describing \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FRed_Scare\\\"\u003Ethe &quot;threat&quot; of global Communism\u003C\u002Fa\u003E during this era of world history. Additionally, the choice to render the Martian totalitarian leader with a very similar appearance to iconic Soviet leader \u003Ca href=\\\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FJoseph_Stalin\\\"\u003EJoseph Stalin\u003C\u002Fa\u003E can be read as an explicit visual and cultural cue to the audience. As such, this depiction of Mars seems to be a thinly-veiled allegorical caricature of life under Communism as perceived by an outside observer and political\u002Fideological opponent, a caricature that employs not only a limited color palette but one that is charged with other cultural references. The use of color both leverages the preconceived biases and associations of its audience and is inherently bound to the film&#39;s political argument that Communism is not a viable or desirable system of government.\u003C\u002Fp\u003E\\n\u003Cp\u003EContrasting the limited use of color in our Mars excerpt, the Earth trace covers a much wider dynamic range of hue values. In this passage, the Martian emissary is learning about the wonderful and affluent lifestyle of Earthlings thanks to a capitalist system and exploitation of oil and petroleum products. The sequence emphasizes the material wealth and entrepreneurial freedom offered under a capitalist system using a much greater variety and vivacity of color than in the Mars excerpt. Commercial products and people alike are depicted using the full spectrum of the Technicolor process, creating positive associations between the outputs of the petroleum industry and the well-off lifestyle of those who benefit from it. Like the Mars excerpt, the audience is offered a one-sided caricature of a political system and way of life, but in this section the reductionist portrayal is laudable and prosperous as opposed to bleak and oppressive. As a piece of propaganda, \u003Cem\u003EDestination Earth\u003C\u002Fem\u003E relies on these powerful but overly simplistic distinctions between two political systems to influence public opinion and promote the consumption of petroleum products. How color is used (or not used) is an important tool in crafting and driving this message home. Further, once we are able to extract color data and visualize it using simple graphing techniques, we can see that the disparity in dynamic range provides a quantitative measure for linking the technical and aesthetic use of color in this animated film with the propagandist rhetoric put forth by its producers.\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;lovely_oil.png&quot; caption=&quot;Oil and American ideals of wealth and prosperity rendered in colorful splendor&quot; %}\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"scaling-color-analysis-with-ffprobe\\\"\u003EScaling Color Analysis with FFprobe\u003C\u002Fh3\u003E\\n\u003Cp\u003EOne of the limits of this methodology is that we are manually generating color reports on only one file at a time. If we wanted to take a \u003Ca href=\\\"https:\u002F\u002Fdistantviewing.org\u002Fbackground\\\"\u003Edistant viewing\u003C\u002Fa\u003E approach more in-line with traditional DH methodologies, we could employ a Bash script to run our \u003Ccode\u003Effprobe\u003C\u002Fcode\u003E command on all files in a given directory. This is useful if, for example, a researcher was interested in conducting similar analysis on \u003Ca href=\\\"https:\u002F\u002Farchive.org\u002Fdetails\u002Fprelinger&amp;tab=collection?and%5B%5D=john+sutherland&amp;sin=\\\"\u003Eall the John Sutherland animated films found in the Prelinger Archives collection\u003C\u002Fa\u003E or another set of archival video material.\u003C\u002Fp\u003E\\n\u003Cp\u003EOnce you have a set of material to work with saved in one place, you can save the following \u003Ca href=\\\"https:\u002F\u002Fwww.shellscript.sh\u002Floops.html\\\"\u003EBash for loop\u003C\u002Fa\u003E within the directory and execute it to generate \u003Ccode\u003E.csv\u003C\u002Fcode\u003E files containing the same frame-level median hue data we extracted from our excerpts of \u003Cem\u003EDestination Earth\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-bash\\\"\u003Efor file in *.m4v; do\\nffprobe -f lavfi -i movie=&quot;$file&quot;,signalstats -show_entries frame=pkt_pts_time:frame_tags=lavfi.signalstats.HUEMED -print_format csv &gt; &quot;${file%.m4v}.csv&quot;;\\ndone\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Efor file in *.m4v; do\u003C\u002Fcode\u003E = initiates the for loop. This first line basically tells FFmpeg: &quot;for all files in this directory with the extension \u003Ccode\u003E.m4v\u003C\u002Fcode\u003E, perform the following command.&quot;\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003EThe \u003Ccode\u003E*\u003C\u002Fcode\u003E is a Bash \u003Ca href=\\\"http:\u002F\u002Ftldp.org\u002FLDP\u002FGNU-Linux-Tools-Summary\u002Fhtml\u002Fx11655.htm\\\"\u003Ewildcard\u003C\u002Fa\u003E attached to a given file-type and specifies them as the input files.\u003C\u002Fli\u003E\\n\u003Cli\u003EThe word \u003Ccode\u003Efile\u003C\u002Fcode\u003E is an arbitrary \u003Ca href=\\\"http:\u002F\u002Ftldp.org\u002FHOWTO\u002FBash-Prog-Intro-HOWTO-5.html\\\"\u003Evariable\u003C\u002Fa\u003E which will represent each file as it runs through the loop.\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Effprobe -f lavfi -i movie=&quot;$file&quot;,signalstats -show_entries frame=pkt_pts_time:frame_tags=lavfi.signalstats.HUEMED -print_format csv &gt; &quot;${file%.m4v}.csv&quot;; done\u003C\u002Fcode\u003E = the same color metadata extraction command we ran on our two excerpts of \u003Cem\u003EDestination Earth\u003C\u002Fem\u003E, with some slight alterations to the syntax to account for its use across multiple files in a directory:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Ccode\u003E&quot;$file&quot;\u003C\u002Fcode\u003E recalls each variable. The enclosing quotation marks ensures that the original filename is retained.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003E&gt; &quot;${file%.m4v}.csv&quot;;\u003C\u002Fcode\u003E retains the original filename when writing the output \u003Ccode\u003E.csv\u003C\u002Fcode\u003E files. This will ensure the names of the original video files will match their corresponding \u003Ccode\u003E.csv\u003C\u002Fcode\u003E reports.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ccode\u003Edone\u003C\u002Fcode\u003E = terminates the script once all files in the directory have been looped\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cdiv class=\\\"alert alert-warning\\\"\u003E\\nYou can also use \u003Ccode\u003Esignalstats\u003C\u002Fcode\u003E to pull other valuable information related to color. Refer to the filter's \u003Ca href=\\\"https:\u002F\u002Fwww.ffmpeg.org\u002Fffprobe-all.html#signalstats-1\\\"\u003Edocumentation\u003C\u002Fa\u003E for a complete list of visual metrics available.\\n\u003C\u002Fdiv\u003E\\n\\n\u003Cp\u003EOnce you run this script, you will see each video file in the directory now has a corresponding \u003Ccode\u003E.csv\u003C\u002Fcode\u003E file containing the specified dataset.\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"wrap-up\\\"\u003EWrap Up\u003C\u002Fh1\u003E\\n\u003Cp\u003EIn this tutorial, we have learned:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003ETo install FFmpeg on different operating systems and how to access the framework in the web-browser\u003C\u002Fli\u003E\\n\u003Cli\u003EThe basic syntax and structure of FFmpeg commands\u003C\u002Fli\u003E\\n\u003Cli\u003ETo view basic technical metadata of an audiovisual file\u003C\u002Fli\u003E\\n\u003Cli\u003ETo transform an audiovisual file through transcoding and re-wrapping\u003C\u002Fli\u003E\\n\u003Cli\u003ETo parse and edit that audiovisual file by demuxing it and creating excerpts\u003C\u002Fli\u003E\\n\u003Cli\u003ETo playback audiovisual files using \u003Ccode\u003Effplay\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003ETo create new video files with embedded vectorscopes\u003C\u002Fli\u003E\\n\u003Cli\u003ETo export tabular data related to color from a video stream using \u003Ccode\u003Effprobe\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003ETo craft a Bash for loop to extract color data information from multiple video files with one command\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003EAt a broader level, this tutorial aspires to provide an informed and enticing introduction to how audiovisual tools and methodologies can be incorporated in Digital Humanities projects and practices. With open and powerful tools like FFmpeg, there is vast potential for expanding the scope of the field to include more rich and complex types of media and analysis than ever before.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"further-resources\\\"\u003EFurther Resources\u003C\u002Fh2\u003E\\n\u003Cp\u003EFFmpeg has a large and well-supported community of users across the globe. As such, there are many open-source and free resources for discovering new commands and techniques for working with audio-visual media. Please contact the author with any additions to this list, especially educational resources in Spanish for learning FFmpeg.\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003EThe Official \u003Ca href=\\\"https:\u002F\u002Fwww.ffmpeg.org\u002Fffmpeg.html\\\"\u003EFFmpeg Documentation\u003C\u002Fa\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ca href=\\\"https:\u002F\u002Ftrac.ffmpeg.org\u002Fwiki\u002FWikiStart\\\"\u003EFFmpeg Wiki\u003C\u002Fa\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ca href=\\\"https:\u002F\u002Famiaopensource.github.io\u002Fffmprovisr\u002F\\\"\u003Effmprovisr\u003C\u002Fa\u003E from the \u003Ca href=\\\"https:\u002F\u002Famianet.org\u002F\\\"\u003EAssociation of Moving Image Archivists\u003C\u002Fa\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003EAshley Blewer&#39;s \u003Ca href=\\\"https:\u002F\u002Ftraining.ashleyblewer.com\u002F\\\"\u003EAudiovisual Preservation Training\u003C\u002Fa\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003EAndrew Weaver&#39;s \u003Ca href=\\\"https:\u002F\u002Fgithub.com\u002Fprivatezero\u002FNDSR\u002Fblob\u002Fmaster\u002FDemystifying_FFmpeg_Slides.pdf\\\"\u003EDemystifying FFmpeg\u003C\u002Fa\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003EBen Turkus&#39; \u003Ca href=\\\"https:\u002F\u002Fdocs.google.com\u002Fpresentation\u002Fd\u002F1NuusF948E6-gNTN04Lj0YHcVV9-30PTvkh_7mqyPPv4\u002Fpresent?ueb=true&amp;slide=id.g2974defaca_0_231\\\"\u003EFFmpeg Presentation\u003C\u002Fa\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003EReto Kromer&#39;s \u003Ca href=\\\"https:\u002F\u002Favpres.net\u002FFFmpeg\u002F\\\"\u003EFFmpeg Cookbook for Archivists\u003C\u002Fa\u003E\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Ch2 id=\\\"open-source-av-analysis-tools-using-ffmpeg\\\"\u003EOpen-Source AV Analysis Tools using FFmpeg\u003C\u002Fh2\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Ca href=\\\"https:\u002F\u002Fmediaarea.net\u002Fen\u002FMediaInfo\\\"\u003EMediaInfo\u003C\u002Fa\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ca href=\\\"https:\u002F\u002Fbavc.org\u002Fpreserve-media\u002Fpreservation-tools\\\"\u003EQC Tools\u003C\u002Fa\u003E\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Ch1 id=\\\"references\\\"\u003EReferences\u003C\u002Fh1\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Cp\u003EChampion, E. (2017) “Digital Humanities is text heavy, visualization light, and simulation poor,” Digital Scholarship in the Humanities 32(S1), i25-i32.\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003EFlueckiger, B. (2017). &quot;A Digital Humanities Approach to Film Colors&quot;. The Moving Image, 17(2), 71-94.\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003EHockey, S. (2004) “The History of Humanities Computing,” A Companion to Digital Humanities, ed. Susan Schreibman, Ray Siemens, John Unsworth. Oxford: Blackwell.\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cdiv class=\\\"alert alert-warning\\\"\u003E\\n This tutorial was made possible with the support of the British Academy and written during the Programming Historian Workshop at La Universidad de Los Andes in Bogotá, Colombia, 31 July - 3 August, 2018.\\n\u003C\u002Fdiv\u003E\\n\"}"}</script></div>
	</body>
</html>
