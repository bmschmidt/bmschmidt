<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="description" content="" />
		<link rel="icon" href="/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		

		

		<link rel="stylesheet" href="/_app/assets/start-61d1577b.css">
		<link rel="modulepreload" href="/_app/start-a80c730b.js">
		<link rel="modulepreload" href="/_app/chunks/vendor-9b9d6288.js">
		<link rel="modulepreload" href="/_app/pages/__layout.svelte-de46afb2.js">
		<link rel="modulepreload" href="/_app/pages/_lang_/__layout.svelte-e75718c6.js">
		<link rel="modulepreload" href="/_app/chunks/stores-191d1505.js">
		<link rel="modulepreload" href="/_app/pages/_lang_/_lessons_/_slug_/index.svelte-efe77d76.js">

		<script type="module">
			import { start } from "/_app/start-a80c730b.js";
			start({
				target: document.querySelector("#svelte"),
				paths: {"base":"","assets":""},
				session: {},
				route: true,
				spa: false,
				trailing_slash: "never",
				hydrate: {
					status: 200,
					error: null,
					nodes: [
						import("/_app/pages/__layout.svelte-de46afb2.js"),
						import("/_app/pages/_lang_/__layout.svelte-e75718c6.js"),
						import("/_app/pages/_lang_/_lessons_/_slug_/index.svelte-efe77d76.js")
					],
					url: new URL("sveltekit://prerender/en/lessons/from-html-to-list-of-words-1"),
					params: {lang:"en",lessons:"lessons",slug:"from-html-to-list-of-words-1"}
				}
			});
		</script><script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('/service-worker.js');
			}
		</script>
	</head>
	<body>
		<div id="svelte">


The Programming Historian <a href="/en">English</a> <a href="/es">Spanish</a>
<br>
This is the en edition.

<h1>From HTML to List of Words (part 1)</h1>

<!-- HTML_TAG_START --><p>{% include toc.html %}</p>
<h2 id="lesson-goals">Lesson Goals</h2>
<p>In this two-part lesson, we will build on what you’ve learned about
<a href="/lessons/working-with-web-pages">Downloading Web Pages with Python</a>, learning how to remove the <em>HTML markup</em> from
the webpage of <a href="http://www.oldbaileyonline.org/browse.jsp?id=t17800628-33&amp;div=t17800628-33">Benjamin Bowsey’s 1780 criminal trial transcript</a>. We
will achieve this by using a variety of <em>string operators</em>, <em>string methods</em>
and close reading skills. We introduce <em>looping</em> and <em>branching</em> so that
programs can repeat tasks and test for certain conditions, making it
possible to separate the content from the HTML tags. Finally, we convert
content from a long string to a <em>list of words</em> that can later be sorted,
indexed, and counted.</p>
<h2 id="the-challenge">The Challenge</h2>
<p>To get a clearer picture of the task ahead, open the
<em>obo-t17800628-33.html</em> file that you created in <a href="/lessons/working-with-web-pages">Downloading Web Pages with Python</a> (or [download and save the trial]
<a href="/assets/obo-t17800628-33.html">obo-t17800628-33.html</a> if you do not already have a
copy), then look at the HTML source by clicking on
<em>Tools -&gt; Web Developer -&gt; Page Source</em>. As you scroll through the
source code you’ll notice that there are HTML tags mixed in with
the text. If HTML is new to you, we recommend that you take the W3 Schools <a href="http://www.w3schools.com/html/">HTML</a> tutorial
to familiarize yourself with HTML markup. If your work often requires
that you remove HTML markup, it will certainly help to be able to
understand it when you see it.</p>
<h3 id="files-needed-for-this-lesson">Files Needed For This Lesson</h3>
<ul>
<li><em><a href="/assets/obo-t17800628-33.html">obo-t17800628-33.html</a></em></li>
</ul>
<h2 id="devising-an-algorithm">Devising an Algorithm</h2>
<p>Since the goal is to get rid of the HTML, the first step is to create an
<em>algorithm</em> that returns only the text (minus the HTML tags) of the
article. An algorithm is a procedure that has been specified in enough
detail that it can be implemented on a computer. It helps to write your
algorithms first in plain English; it&#39;s a great way to outline exactly
what you want to do before diving into code. To construct this algorithm
you are going to use your close reading skills to figure out a way to
capture only the textual content of the biography.</p>
<p>Looking at the source code of <em>obo-t17800628-33.html</em> you will notice
the actual transcript does not start right away. Instead there are a
number of HTML tags and some citation information. In this case the content does
not even start until quite far along line 81!</p>
<pre><code class="language-xml">&lt;p&gt;324.                                  &lt;a class=&quot;invisible&quot; name=&quot;t17800628-33-defend448&quot;&gt; &lt;/a&gt;                     BENJAMIN                      BOWSEY                                                                                                          (a blackmoor                  ) was indicted for                                                          that he together with five hundred other persons and more, did, unlawfully, riotously, and tumultuously assemble on the 6th of June
</code></pre>
<p>We are only interested in the transcript itself, not the extra metadata
contained in the tags. However, you will notice that the end of the
metadata corresponds with the start of the transcript. This makes the
location of the metadata a potentially useful marker for isolating the
transcript text.</p>
<p>At a glance, we can see that the trial transcript itself starts with an HTML tag:
<code>&lt;p&gt;</code>, which stands for &#39;paragraph&#39;. This happens to be the first paragraph tag in the document.
We might be able to use this to find the starting point
of our transcript text. We are lucky in this case because it turns out
that this tag is a reliable way to find the start of transcript text
in the trial (if you want, take a look at a few other trials to check).</p>
<p>The trial text ends on line 82 with another HTML tag: <code>&lt;br/&gt;</code>, which stands for line break.
This happens to be the LAST line break in the document. These two tags (first paragraph tag and last linebreak)
thus provide a way to isolate our desired text. Well-formatted websites will almost always have some
unique way of signalling the end of the content. You often just need to
look closely.</p>
<p>The next thing that you want to do is strip out all of the HTML markup
that remains mixed in with the content. Since you know HTML tags are
always found between matching pairs of angle brackets, it’s probably a
safe bet that if you remove everything between angle brackets, you will
remove the HTML and be left only with the transcript. Note that we are
making the assumption that the transcript will not contain the
mathematical symbols for “less than” or “greater than.” If Bowsey was a
mathematician, this assumption would not be as safe.</p>
<p>The following describes our algorithm in words.</p>
<p>To isolate the content:</p>
<ul>
<li>Download the transcript text</li>
<li>Search the HTML for and store the location of the first <code>&lt;p&gt;</code> tag</li>
<li>Search the HTML for and store the location of the last <code>&lt;br/&gt;</code> tag</li>
<li>Save everything after the <code>&lt;p&gt;</code> tag and before the <code>&lt;br/&gt;</code> tag to a string:
<em>pageContents</em></li>
</ul>
<p>At this point we have the trial transcript text, plus HTML markup. Next:</p>
<ul>
<li>Look at every character in the <em>pageContents</em> string, one character at
a time</li>
<li>If the character is a left angle bracket (&lt;) we are now inside a
tag so ignore each following character</li>
<li>If the character is a right angle bracket (&gt;) we are now leaving
the tag; ignore the current character, but look at each following
character</li>
<li>If we’re not inside a tag, append the current character to a new
variable: <em>text</em></li>
</ul>
<p>Finally:</p>
<ul>
<li>Split the text string into a list of individual words that can later
be manipulated further.</li>
</ul>
<h2 id="isolating-desired-content">Isolating Desired Content</h2>
<p>The following step uses Python commands introduced in the <a href="/lessons/manipulating-strings-in-python">Manipulating
Strings in Python</a> lesson to implement the first half of the
algorithm: removing all content before the <code>&lt;p&gt;</code> tag and after the <code>&lt;br/&gt;</code> tag. To recap,
the algorithm was as follows:</p>
<ul>
<li>Download the transcript text</li>
<li>Search the HTML for and store the location of the first <code>&lt;p&gt;</code> tag</li>
<li>Search the HTML for and store the location of the last <code>&lt;br/&gt;</code> tag</li>
<li>Save everything after the <code>&lt;p&gt;</code> tag and before the <code>&lt;br/&gt;</code> tag to a string:
<em>pageContents</em></li>
</ul>
<p>To achieve this, you will use the &#39;find&#39; string method and .rfind() method
(which finds the last match of something) and create a new
substring containing only the desired content between those index positions.</p>
<p>As you work, you will be developing separate files to contain your code.
One of these will be called <em>obo.py</em> (for “Old Bailey Online”). This
file is going to contain all of the code that you will want to re-use;
in other words, <em>obo.py</em> is a module. We discussed the idea of modules
in <a href="/lessons/code-reuse-and-modularity">Code Reuse and Modularity</a> when we saved our functions to
<em>greet.py</em>.</p>
<p>Create a new file named <em>obo.py</em> and save it to your
<em>programming-historian</em> directory. We are going to use this file to keep
copies of the functions needed to process The Old Bailey Online. Type or
copy the following code into your file.</p>
<pre><code class="language-python"># obo.py

def stripTags(pageContents):
    pageContents = str(pageContents)
    startLoc = pageContents.find(&quot;&lt;p&gt;&quot;)
    endLoc = pageContents.rfind(&quot;&lt;br/&gt;&quot;)

    pageContents = pageContents[startLoc:endLoc]
    return pageContents
</code></pre>
<p>Create a second file, <em>trial-content.py</em>, and save the program shown
below.</p>
<pre><code class="language-python"># trial-content.py

import urllib.request, urllib.error, urllib.parse, obo

url = &#39;http://www.oldbaileyonline.org/browse.jsp?id=t17800628-33&amp;div=t17800628-33&#39;

response = urllib.request.urlopen(url)
HTML = response.read().decode(&#39;UTF-8&#39;)

print((obo.stripTags(HTML)))
</code></pre>
<p>When you run <em>trial-content.py</em> it will get the web page for Bowsey’s
trial transcript, then look in the <em>obo.py</em> module for the <em>stripTags</em>
function. It will use that function to extract the stuff after the first
<code>&lt;p&gt;</code> tag and before the last <code>&lt;br/&gt;</code> tag. With any luck, this should be the textual content of
the Bowsey transcript, along with some of HTML markup. Don’t worry if
your Command Output screen ends in a thick black line. Komodo Edit’s
output screen has a maximum number of characters it will display, after
which characters start literally writing over one another on the screen,
giving the appearance of a black blob. Don’t worry, the text is in there
even though you cannot read it; you can cut and paste it to a text file
to double check.</p>
<p>Let’s take a moment to make sure we understand how <em>trial-contents.py</em>
is able to use the functions stored in <em>obo.py</em>. The <em>stripTags</em> function
that we saved to <em>obo.py</em> requires one argument. In other words, to run
properly it needs one piece of information to be supplied. Recall the
trained dog example from a previous lesson. In order to bark, the dog
needs two things: air and a delicious treat. The <em>stripTags</em> function in
<em>obo.py</em> needs one thing: a string called <em>pageContents</em>. But you’ll
notice that when we call <em>stripTags</em> in the final program
(<em>trialcontents.py</em>) there’s no mention of “<em>pageContents</em>“. Instead the
function is given HTML as an argument. This can be confusing to many
people when they first start programming. Once a function has been
declared, we no longer need to use the same variable name when we call
the function. As long as we provide the right type of argument,
everything should work fine, no matter what we call it. In this case we
wanted <em>pageContents</em> to use the contents of our HTML variable. You could
have passed it any string, including one you input directly between the
parentheses. Try rerunning <em>trial-content.py</em>, changing the <em>stripTags</em>
argument to “I am quite fond of dogs” and see what happens. Note that
depending on how you define your function (and what it does) your
argument may need to be something other than a string: an <em>integer</em> for
example.</p>
<h2 id="suggested-reading">Suggested Reading</h2>
<ul>
<li>Lutz, <em>Learning Python</em><ul>
<li>Ch. 7: Strings</li>
<li>Ch. 8: Lists and Dictionaries</li>
<li>Ch. 10: Introducing Python Statements</li>
<li>Ch. 15: Function Basics</li>
</ul>
</li>
</ul>
<h2 id="code-syncing">Code Syncing</h2>
<p>To follow along with future lessons it is important that you have the
right files and programs in your programming-historian directory. At the
end of each chapter you can download the programming-historian zip file
to make sure you have the correct code. Note we have removed unneeded
files from earlier lessons. Your directory may contain more files and
that’s ok!</p>
<ul>
<li>programming-historian-2 (<a href="/assets/python-lessons2.zip">zip</a>)</li>
</ul>
<!-- HTML_TAG_END -->

<script type="application/json" data-type="svelte-data" data-url="from-html-to-list-of-words-1/raw.json">{"status":200,"statusText":"","headers":{"content-type":"application/json; charset=utf-8"},"body":"{\"metadata\":{\"title\":\"From HTML to List of Words (part 1)\",\"layout\":\"lesson\",\"date\":\"2012-07-17T00:00:00.000Z\",\"authors\":[\"William J. Turkel\",\"Adam Crymble\"],\"reviewers\":[\"Jim Clifford\",\"Frederik Elwert\"],\"editors\":[\"Miriam Posner\"],\"difficulty\":2,\"exclude_from_check\":[\"review-ticket\"],\"activity\":\"transforming\",\"topics\":[\"python\"],\"abstract\":\"In this two-part lesson, we will build on what you’ve learned about Downloading Web Pages with Python, learning how to remove the HTML markup from the webpage of Benjamin Bowsey’s 1780 criminal trial transcript. We will achieve this by using a variety of string operators, string methods, and close reading skills. We introduce looping and branching so that programs can repeat tasks and test for certain conditions, making it possible to separate the content from the HTML tags. Finally, we convert content from a long string to a list of words that can later be sorted, indexed, and counted.\",\"next\":\"from-html-to-list-of-words-2\",\"previous\":\"manipulating-strings-in-python\",\"series_total\":\"15 lessons\",\"sequence\":7,\"python_warning\":false,\"redirect_from\":\"\u002Flessons\u002Ffrom-html-to-list-of-words-1\",\"avatar_alt\":\"A giraffe being mimicked by a human\",\"doi\":\"10.46430\u002Fphen0006\"},\"html_body\":\"\u003Cp\u003E{% include toc.html %}\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"lesson-goals\\\"\u003ELesson Goals\u003C\u002Fh2\u003E\\n\u003Cp\u003EIn this two-part lesson, we will build on what you’ve learned about\\n\u003Ca href=\\\"\u002Flessons\u002Fworking-with-web-pages\\\"\u003EDownloading Web Pages with Python\u003C\u002Fa\u003E, learning how to remove the \u003Cem\u003EHTML markup\u003C\u002Fem\u003E from\\nthe webpage of \u003Ca href=\\\"http:\u002F\u002Fwww.oldbaileyonline.org\u002Fbrowse.jsp?id=t17800628-33&amp;div=t17800628-33\\\"\u003EBenjamin Bowsey’s 1780 criminal trial transcript\u003C\u002Fa\u003E. We\\nwill achieve this by using a variety of \u003Cem\u003Estring operators\u003C\u002Fem\u003E, \u003Cem\u003Estring methods\u003C\u002Fem\u003E\\nand close reading skills. We introduce \u003Cem\u003Elooping\u003C\u002Fem\u003E and \u003Cem\u003Ebranching\u003C\u002Fem\u003E so that\\nprograms can repeat tasks and test for certain conditions, making it\\npossible to separate the content from the HTML tags. Finally, we convert\\ncontent from a long string to a \u003Cem\u003Elist of words\u003C\u002Fem\u003E that can later be sorted,\\nindexed, and counted.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"the-challenge\\\"\u003EThe Challenge\u003C\u002Fh2\u003E\\n\u003Cp\u003ETo get a clearer picture of the task ahead, open the\\n\u003Cem\u003Eobo-t17800628-33.html\u003C\u002Fem\u003E file that you created in \u003Ca href=\\\"\u002Flessons\u002Fworking-with-web-pages\\\"\u003EDownloading Web Pages with Python\u003C\u002Fa\u003E (or [download and save the trial]\\n\u003Ca href=\\\"\u002Fassets\u002Fobo-t17800628-33.html\\\"\u003Eobo-t17800628-33.html\u003C\u002Fa\u003E if you do not already have a\\ncopy), then look at the HTML source by clicking on\\n\u003Cem\u003ETools -&gt; Web Developer -&gt; Page Source\u003C\u002Fem\u003E. As you scroll through the\\nsource code you’ll notice that there are HTML tags mixed in with\\nthe text. If HTML is new to you, we recommend that you take the W3 Schools \u003Ca href=\\\"http:\u002F\u002Fwww.w3schools.com\u002Fhtml\u002F\\\"\u003EHTML\u003C\u002Fa\u003E tutorial\\nto familiarize yourself with HTML markup. If your work often requires\\nthat you remove HTML markup, it will certainly help to be able to\\nunderstand it when you see it.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"files-needed-for-this-lesson\\\"\u003EFiles Needed For This Lesson\u003C\u002Fh3\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Cem\u003E\u003Ca href=\\\"\u002Fassets\u002Fobo-t17800628-33.html\\\"\u003Eobo-t17800628-33.html\u003C\u002Fa\u003E\u003C\u002Fem\u003E\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Ch2 id=\\\"devising-an-algorithm\\\"\u003EDevising an Algorithm\u003C\u002Fh2\u003E\\n\u003Cp\u003ESince the goal is to get rid of the HTML, the first step is to create an\\n\u003Cem\u003Ealgorithm\u003C\u002Fem\u003E that returns only the text (minus the HTML tags) of the\\narticle. An algorithm is a procedure that has been specified in enough\\ndetail that it can be implemented on a computer. It helps to write your\\nalgorithms first in plain English; it&#39;s a great way to outline exactly\\nwhat you want to do before diving into code. To construct this algorithm\\nyou are going to use your close reading skills to figure out a way to\\ncapture only the textual content of the biography.\u003C\u002Fp\u003E\\n\u003Cp\u003ELooking at the source code of \u003Cem\u003Eobo-t17800628-33.html\u003C\u002Fem\u003E you will notice\\nthe actual transcript does not start right away. Instead there are a\\nnumber of HTML tags and some citation information. In this case the content does\\nnot even start until quite far along line 81!\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-xml\\\"\u003E&lt;p&gt;324.                                  &lt;a class=&quot;invisible&quot; name=&quot;t17800628-33-defend448&quot;&gt; &lt;\u002Fa&gt;                     BENJAMIN                      BOWSEY                                                                                                          (a blackmoor                  ) was indicted for                                                          that he together with five hundred other persons and more, did, unlawfully, riotously, and tumultuously assemble on the 6th of June\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EWe are only interested in the transcript itself, not the extra metadata\\ncontained in the tags. However, you will notice that the end of the\\nmetadata corresponds with the start of the transcript. This makes the\\nlocation of the metadata a potentially useful marker for isolating the\\ntranscript text.\u003C\u002Fp\u003E\\n\u003Cp\u003EAt a glance, we can see that the trial transcript itself starts with an HTML tag:\\n\u003Ccode\u003E&lt;p&gt;\u003C\u002Fcode\u003E, which stands for &#39;paragraph&#39;. This happens to be the first paragraph tag in the document.\\nWe might be able to use this to find the starting point\\nof our transcript text. We are lucky in this case because it turns out\\nthat this tag is a reliable way to find the start of transcript text\\nin the trial (if you want, take a look at a few other trials to check).\u003C\u002Fp\u003E\\n\u003Cp\u003EThe trial text ends on line 82 with another HTML tag: \u003Ccode\u003E&lt;br\u002F&gt;\u003C\u002Fcode\u003E, which stands for line break.\\nThis happens to be the LAST line break in the document. These two tags (first paragraph tag and last linebreak)\\nthus provide a way to isolate our desired text. Well-formatted websites will almost always have some\\nunique way of signalling the end of the content. You often just need to\\nlook closely.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe next thing that you want to do is strip out all of the HTML markup\\nthat remains mixed in with the content. Since you know HTML tags are\\nalways found between matching pairs of angle brackets, it’s probably a\\nsafe bet that if you remove everything between angle brackets, you will\\nremove the HTML and be left only with the transcript. Note that we are\\nmaking the assumption that the transcript will not contain the\\nmathematical symbols for “less than” or “greater than.” If Bowsey was a\\nmathematician, this assumption would not be as safe.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe following describes our algorithm in words.\u003C\u002Fp\u003E\\n\u003Cp\u003ETo isolate the content:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003EDownload the transcript text\u003C\u002Fli\u003E\\n\u003Cli\u003ESearch the HTML for and store the location of the first \u003Ccode\u003E&lt;p&gt;\u003C\u002Fcode\u003E tag\u003C\u002Fli\u003E\\n\u003Cli\u003ESearch the HTML for and store the location of the last \u003Ccode\u003E&lt;br\u002F&gt;\u003C\u002Fcode\u003E tag\u003C\u002Fli\u003E\\n\u003Cli\u003ESave everything after the \u003Ccode\u003E&lt;p&gt;\u003C\u002Fcode\u003E tag and before the \u003Ccode\u003E&lt;br\u002F&gt;\u003C\u002Fcode\u003E tag to a string:\\n\u003Cem\u003EpageContents\u003C\u002Fem\u003E\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003EAt this point we have the trial transcript text, plus HTML markup. Next:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003ELook at every character in the \u003Cem\u003EpageContents\u003C\u002Fem\u003E string, one character at\\na time\u003C\u002Fli\u003E\\n\u003Cli\u003EIf the character is a left angle bracket (&lt;) we are now inside a\\ntag so ignore each following character\u003C\u002Fli\u003E\\n\u003Cli\u003EIf the character is a right angle bracket (&gt;) we are now leaving\\nthe tag; ignore the current character, but look at each following\\ncharacter\u003C\u002Fli\u003E\\n\u003Cli\u003EIf we’re not inside a tag, append the current character to a new\\nvariable: \u003Cem\u003Etext\u003C\u002Fem\u003E\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003EFinally:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003ESplit the text string into a list of individual words that can later\\nbe manipulated further.\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Ch2 id=\\\"isolating-desired-content\\\"\u003EIsolating Desired Content\u003C\u002Fh2\u003E\\n\u003Cp\u003EThe following step uses Python commands introduced in the \u003Ca href=\\\"\u002Flessons\u002Fmanipulating-strings-in-python\\\"\u003EManipulating\\nStrings in Python\u003C\u002Fa\u003E lesson to implement the first half of the\\nalgorithm: removing all content before the \u003Ccode\u003E&lt;p&gt;\u003C\u002Fcode\u003E tag and after the \u003Ccode\u003E&lt;br\u002F&gt;\u003C\u002Fcode\u003E tag. To recap,\\nthe algorithm was as follows:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003EDownload the transcript text\u003C\u002Fli\u003E\\n\u003Cli\u003ESearch the HTML for and store the location of the first \u003Ccode\u003E&lt;p&gt;\u003C\u002Fcode\u003E tag\u003C\u002Fli\u003E\\n\u003Cli\u003ESearch the HTML for and store the location of the last \u003Ccode\u003E&lt;br\u002F&gt;\u003C\u002Fcode\u003E tag\u003C\u002Fli\u003E\\n\u003Cli\u003ESave everything after the \u003Ccode\u003E&lt;p&gt;\u003C\u002Fcode\u003E tag and before the \u003Ccode\u003E&lt;br\u002F&gt;\u003C\u002Fcode\u003E tag to a string:\\n\u003Cem\u003EpageContents\u003C\u002Fem\u003E\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003ETo achieve this, you will use the &#39;find&#39; string method and .rfind() method\\n(which finds the last match of something) and create a new\\nsubstring containing only the desired content between those index positions.\u003C\u002Fp\u003E\\n\u003Cp\u003EAs you work, you will be developing separate files to contain your code.\\nOne of these will be called \u003Cem\u003Eobo.py\u003C\u002Fem\u003E (for “Old Bailey Online”). This\\nfile is going to contain all of the code that you will want to re-use;\\nin other words, \u003Cem\u003Eobo.py\u003C\u002Fem\u003E is a module. We discussed the idea of modules\\nin \u003Ca href=\\\"\u002Flessons\u002Fcode-reuse-and-modularity\\\"\u003ECode Reuse and Modularity\u003C\u002Fa\u003E when we saved our functions to\\n\u003Cem\u003Egreet.py\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003ECreate a new file named \u003Cem\u003Eobo.py\u003C\u002Fem\u003E and save it to your\\n\u003Cem\u003Eprogramming-historian\u003C\u002Fem\u003E directory. We are going to use this file to keep\\ncopies of the functions needed to process The Old Bailey Online. Type or\\ncopy the following code into your file.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E# obo.py\\n\\ndef stripTags(pageContents):\\n    pageContents = str(pageContents)\\n    startLoc = pageContents.find(&quot;&lt;p&gt;&quot;)\\n    endLoc = pageContents.rfind(&quot;&lt;br\u002F&gt;&quot;)\\n\\n    pageContents = pageContents[startLoc:endLoc]\\n    return pageContents\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ECreate a second file, \u003Cem\u003Etrial-content.py\u003C\u002Fem\u003E, and save the program shown\\nbelow.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E# trial-content.py\\n\\nimport urllib.request, urllib.error, urllib.parse, obo\\n\\nurl = &#39;http:\u002F\u002Fwww.oldbaileyonline.org\u002Fbrowse.jsp?id=t17800628-33&amp;div=t17800628-33&#39;\\n\\nresponse = urllib.request.urlopen(url)\\nHTML = response.read().decode(&#39;UTF-8&#39;)\\n\\nprint((obo.stripTags(HTML)))\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EWhen you run \u003Cem\u003Etrial-content.py\u003C\u002Fem\u003E it will get the web page for Bowsey’s\\ntrial transcript, then look in the \u003Cem\u003Eobo.py\u003C\u002Fem\u003E module for the \u003Cem\u003EstripTags\u003C\u002Fem\u003E\\nfunction. It will use that function to extract the stuff after the first\\n\u003Ccode\u003E&lt;p&gt;\u003C\u002Fcode\u003E tag and before the last \u003Ccode\u003E&lt;br\u002F&gt;\u003C\u002Fcode\u003E tag. With any luck, this should be the textual content of\\nthe Bowsey transcript, along with some of HTML markup. Don’t worry if\\nyour Command Output screen ends in a thick black line. Komodo Edit’s\\noutput screen has a maximum number of characters it will display, after\\nwhich characters start literally writing over one another on the screen,\\ngiving the appearance of a black blob. Don’t worry, the text is in there\\neven though you cannot read it; you can cut and paste it to a text file\\nto double check.\u003C\u002Fp\u003E\\n\u003Cp\u003ELet’s take a moment to make sure we understand how \u003Cem\u003Etrial-contents.py\u003C\u002Fem\u003E\\nis able to use the functions stored in \u003Cem\u003Eobo.py\u003C\u002Fem\u003E. The \u003Cem\u003EstripTags\u003C\u002Fem\u003E function\\nthat we saved to \u003Cem\u003Eobo.py\u003C\u002Fem\u003E requires one argument. In other words, to run\\nproperly it needs one piece of information to be supplied. Recall the\\ntrained dog example from a previous lesson. In order to bark, the dog\\nneeds two things: air and a delicious treat. The \u003Cem\u003EstripTags\u003C\u002Fem\u003E function in\\n\u003Cem\u003Eobo.py\u003C\u002Fem\u003E needs one thing: a string called \u003Cem\u003EpageContents\u003C\u002Fem\u003E. But you’ll\\nnotice that when we call \u003Cem\u003EstripTags\u003C\u002Fem\u003E in the final program\\n(\u003Cem\u003Etrialcontents.py\u003C\u002Fem\u003E) there’s no mention of “\u003Cem\u003EpageContents\u003C\u002Fem\u003E“. Instead the\\nfunction is given HTML as an argument. This can be confusing to many\\npeople when they first start programming. Once a function has been\\ndeclared, we no longer need to use the same variable name when we call\\nthe function. As long as we provide the right type of argument,\\neverything should work fine, no matter what we call it. In this case we\\nwanted \u003Cem\u003EpageContents\u003C\u002Fem\u003E to use the contents of our HTML variable. You could\\nhave passed it any string, including one you input directly between the\\nparentheses. Try rerunning \u003Cem\u003Etrial-content.py\u003C\u002Fem\u003E, changing the \u003Cem\u003EstripTags\u003C\u002Fem\u003E\\nargument to “I am quite fond of dogs” and see what happens. Note that\\ndepending on how you define your function (and what it does) your\\nargument may need to be something other than a string: an \u003Cem\u003Einteger\u003C\u002Fem\u003E for\\nexample.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"suggested-reading\\\"\u003ESuggested Reading\u003C\u002Fh2\u003E\\n\u003Cul\u003E\\n\u003Cli\u003ELutz, \u003Cem\u003ELearning Python\u003C\u002Fem\u003E\u003Cul\u003E\\n\u003Cli\u003ECh. 7: Strings\u003C\u002Fli\u003E\\n\u003Cli\u003ECh. 8: Lists and Dictionaries\u003C\u002Fli\u003E\\n\u003Cli\u003ECh. 10: Introducing Python Statements\u003C\u002Fli\u003E\\n\u003Cli\u003ECh. 15: Function Basics\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Ch2 id=\\\"code-syncing\\\"\u003ECode Syncing\u003C\u002Fh2\u003E\\n\u003Cp\u003ETo follow along with future lessons it is important that you have the\\nright files and programs in your programming-historian directory. At the\\nend of each chapter you can download the programming-historian zip file\\nto make sure you have the correct code. Note we have removed unneeded\\nfiles from earlier lessons. Your directory may contain more files and\\nthat’s ok!\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003Eprogramming-historian-2 (\u003Ca href=\\\"\u002Fassets\u002Fpython-lessons2.zip\\\"\u003Ezip\u003C\u002Fa\u003E)\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\"}"}</script></div>
	</body>
</html>
