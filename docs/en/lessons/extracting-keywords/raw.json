{"metadata":{"title":"Using Gazetteers to Extract Sets of Keywords from Free-Flowing Texts","layout":"lesson","date":"2015-12-01T00:00:00.000Z","authors":["Adam Crymble"],"reviewers":["Guy McClellan","Amanda Morton","Frederik Elwert"],"editors":["Fred Gibbs"],"difficulty":2,"exclude_from_check":["review-ticket"],"activity":"acquiring","topics":["data-manipulation"],"abstract":"This lesson will teach you how to use Python to extract a set of keywords very quickly and systematically from a set of texts.","python_warning":false,"redirect_from":"/lessons/extracting-keywords","avatar_alt":"Woman churning butter or milk","doi":"10.46430/phen0045"},"html_body":"<p>{% include toc.html %}</p>\n<h2 id=\"lesson-goals\">Lesson Goals</h2>\n<p>If you have a copy of a text in electronic format stored on your computer, it is relatively easy to keyword search for a single term. Often you can do this by using the built-in search features in your favourite text editor. However, scholars are increasingly needing to find instances of many terms within a text or texts. For example, a scholar may want to use a <a href=\"http://en.wikipedia.org/wiki/Gazetteer\">gazetteer</a> to extract all mentions of English placenames within a collection of texts so that those places can later be plotted on a map. Alternatively, they may want to extract all male given names, all pronouns, <a href=\"http://en.wikipedia.org/wiki/Stop_words\">stop words</a>, or any other set of words. Using those same built-in search features to achieve this more complex goal is time consuming and clunky. This lesson will teach you how to use Python to extract a set of keywords very quickly and systematically from a set of texts.</p>\n<p>It is expected that once you have completed this lesson, you will be able to generalise the skills to extract custom sets of keywords from any set of locally saved files.</p>\n<h2 id=\"for-whom-is-this-useful\">For Whom is this Useful?</h2>\n<p>This lesson is useful for anyone who works with historical sources that are stored locally on their own computer, and that are transcribed into mutable electronic text (eg, .txt, .xml, .rtf, .md). It is particularly useful for people interested in identifying subsets of documents containing one or more of a fairly large number of keywords. This might be useful for identifying a relevant subset for closer reading, or for extracting and structuring the keywords in a format that can be used in another tool: as input for a mapping exercise, for example.</p>\n<p>The present tutorial will show users how to extract all mentions of English and Welsh county names from a series of 6,692 mini-biographies of individuals who began their studies at the University of Oxford during the reign of James I of England (1603-1625). These records were transcribed by <a href=\"http://www.british-history.ac.uk/alumni-oxon/1500-1714\">British History Online</a>, from the printed version of <em>Alumni Oxonienses, 1500-1714</em>. These biographies contain information about each graduate, which includes the date of their studies and the college(s) they attended. Often entries contain additional information when known, including date or birth and death, the name or occupation of their father, where they originated, and what they went on to do in later life. The biographies are a rich resource, providing reasonably comparable data about a large number of similar individuals (rich men who went to Oxford). The 6,692 entries have been pre-processed by the author and saved to a <a href=\"http://en.wikipedia.org/wiki/Comma-separated_values\">CSV file</a> with one entry per row.</p>\n<p>In this tutorial, the dataset involves geographical keywords. Once extracted, these placenames could be geo-referenced to their place on the globe and then mapped using digital mapping. This might make it possible to discern which colleges attracted students from what parts of the country, or to determine if these patterns changed over time. For a practical tutorial on taking this next step, see the lesson by Fred Gibbs mentioned at the end of this lesson. Readers may also be interested in <a href=\"/lessons/georeferencing-qgis\">georeferencing in QGIS 2.0</a>, also available from the <em>Programming Historian</em>.</p>\n<p>This approach is not limited to geographical keywords, however. It could also be used to extract given names, prepositions, food words, or any other set of terms defined by the user. This process could therefore be useful for someone seeking to isolate individual entries containing any of these keywords, or for someone looking to calculate the frequency of their keywords within a corpus of texts. This tutorial provides pathways into textual or geospatial analyses, rather than research answers in its own right.</p>\n<p>Data management skills are increasingly crucial for historians and textual scholars, and anyone working with particularly messy or difficult texts might consider looking into <a href=\"/lessons/cleaning-data-with-openrefine\">Cleaning Data with OpenRefine</a> by Seth van Hooland et al. The approach outlined in this tutorial is not optimised for working with poorly transcribed texts such as text converted through <a href=\"https://en.wikipedia.org/wiki/Optical_character_recognition\">Optical Character Recognition</a> if the software has a high error rate. Readers working with early modern texts with non-standardised spelling may also find this approach challenging, as the gazetteer one uses must contain exact matches of the words sought. However, with a good enough gazetteer, this approach could prove quite useful for early modernites, and may exceed what&#39;s practical with traditional keyword searching by making <a href=\"https://en.wikipedia.org/wiki/Approximate_string_matching\">fuzzy searching</a> possible.</p>\n<p>This tutorial assumes that you have already installed Python version 3 on your computer. The lesson will use the Command Line to run Python, as this is more flexible and makes it possible for use in classrooms or computer labs in which students do not have the ability to download and install interactive development environments (IDEs) like Komodo Edit. Readers who would prefer to use an IDE might like to first read  <a href=\"/lessons/introduction-and-installation\">Python Introduction and Installation</a>, but this is optional. The tutorial also makes some basic assumptions about your Python skills. It assumes you know what the following Python data structures are (though not knowing will not prevent the code from working should you follow all of the steps in the tutorial):</p>\n<ul>\n<li><a href=\"https://docs.python.org/3/tutorial/datastructures.html\">List</a></li>\n<li><a href=\"https://docs.python.org/3/tutorial/controlflow.html\">For Loop</a></li>\n<li><a href=\"https://docs.python.org/3/library/string.html\">String</a></li>\n</ul>\n<p>The lesson touches on Regular Expressions, so some readers may find it handy to have the relevant Programming Historian lessons by <a href=\"/lessons/understanding-regular-expressions\">Doug Knox</a> or <a href=\"/lessons/cleaning-ocrd-text-with-regular-expressions\">Laura Turner O&#39;Hara</a> open to consult as needed.</p>\n<h2 id=\"familiarising-yourself-with-the-data\">Familiarising yourself with the data</h2>\n<p>The first step of this process is to take a look at the data that we will be using in the lesson. As mentioned, the data includes biographical details of approximately 6,692 graduates who began study at the University of Oxford in the early seventeenth century.</p>\n<p><a href=\"/assets/The_Dataset_-_Alumni_Oxonienses-Jas1.csv\">The_Dataset_-_Alumni_Oxonienses-Jas1.csv</a> (1.4MB)</p>\n<p>{% include figure.html filename=&quot;extracting-keywords-1.png&quot; caption=&quot;Screenshot of the first forty entries in the dataset&quot; %}</p>\n<p>Download the dataset and spend a couple of minutes looking at the types of information available. You should notice three columns of information. The first, &#39;Name&#39;, contains the name of the graduate. The second: &#39;Details&#39;, contains the biographical information known about that person. The final column, &#39;Matriculation Year&#39;, contains the year in which the person matriculated (began their studies). This final column was extracted from the details column in the pre-processing stage of this tutorial. The first two columns are as you would find them on the British History Online version of the <em>Alumni Oxonienses</em>. If you notice more than three columns then your spreadsheet programme has incorrectly set the <a href=\"https://en.wikipedia.org/wiki/Delimiter\">delimiter</a> between columns. It should be set to &quot;,&quot; (double quotes, comma). How you do this depends on your spreadsheet programme, but you should be able to find the solution online.</p>\n<p>Most (but not all) of these bibliographic entries contain enough information to tell us what county the graduate came from. Notice that a large number of entries contain placenames that correspond to either major cities (&#39;of London&#39;, in the first entry) or English counties (&#39;of Middlesex&#39; in entry 5 or &#39;of Wilts&#39; - short for Wiltshire in entry 6). If you are not British you may not be familiar with these county names. You can find a list of <a href=\"http://en.wikipedia.org/wiki/Historic_counties_of_England\">historic counties of England</a> on Wikipedia.</p>\n<p>Unfortunately, the information is not always available in the same format. Sometimes it&#39;s the first thing mentioned in an entry. Sometimes it&#39;s in the middle. Our challenge is to extract those counties of origin from within this messy text, and store it in a new column next to that person&#39;s entry.</p>\n<h2 id=\"build-your-gazetteer\">Build your gazetteer</h2>\n<p>In order to extract the relevant place names, we first have to decide what they are. We need a list of places, often called a gazetteer. Many of the place names mentioned in the records are shortforms, such as &#39;Wilts&#39; instead of &#39;Wiltshire&#39;, or &#39;Salop&#39; instead of &#39;Shropshire&#39;. Getting all of these variations may be tricky. For a start, let&#39;s build a basic gazetteer of English counties.</p>\n<p>Make a new directory (folder) on your computer where you will save all of your work. Create a text file called <code>gazetteer.txt</code> and using the entries listed on the Wikipedia page listed above, add each county to a new line on the text file. It should look something like this:</p>\n<pre><code class=\"language-text\">Bedfordshire\nBerkshire\nBuckinghamshire\nCambridgeshire\nCheshire\nCornwall\nCumberland\nDerbyshire\nDevon\nDorset\nDurham\nEssex\nGloucestershire\nHampshire\nHerefordshire\nHertfordshire\nHuntingdonshire\nKent\nLancashire\nLeicestershire\nLincolnshire\nMiddlesex\nNorfolk\nNorthamptonshire\nNorthumberland\nNottinghamshire\nOxfordshire\nRutland\nShropshire\nSomerset\nStaffordshire\nSuffolk\nSurrey\nSussex\nWarwickshire\nWestmorland\nWiltshire\nWorcestershire\nYorkshire\n</code></pre>\n<p>Make sure that there are no blank lines in the gazetteer file. If there are, your program will think all spaces are a matching keyword. Some text editing programs (particularly in Linux) will want to add a blank line at the end of your file. If this is the case, try another text editor. It&#39;s best to use software that puts you in control. For more on this problem, see <a href=\"http://stackoverflow.com/questions/3056740/gedit-adds-line-at-end-of-file\">the explanation on Stack Overflow</a> - with thanks to John Levin for the link.</p>\n<p>If you ever need to add to this set of keywords, you can open this file in your text editor and add new words, each on their own line. Komodo Edit is a good text editor for this task, especially if you have set it up to run with Python, but you can also use any plain text editor as long as it is <em>not</em> a <a href=\"http://en.wikipedia.org/wiki/Word_processor\">word processor</a> such as Microsoft Word or Open Office. Word processors are inappropriate for writing code because of how they stylise apostrophes and quotes, causing havoc for your code.</p>\n<h2 id=\"loading-your-texts\">Loading your texts</h2>\n<p>The next step is to put the texts that you want to search into another text file, with one entry per line. The easiest way to do that is to open the spreadsheet and select all of the second (details) column, then paste the contents into a .txt file. Call the file <code>texts.txt</code> and save it to the same directory as your <code>gazetteer.txt</code> file. Your directory should look something like this:</p>\n<p>{% include figure.html filename=&quot;extracting-keywords-2.png&quot; caption=&quot;Contents of your working directory&quot; %}</p>\n<p>The reason we do this is to keep the original data (the .CSV file) away from the Python program we are about to write, on the off-chance that we accidentally change something without noticing. In my opinion, this approach also makes for easier to read code, which is important when learning. It is not strictly necessary to use a .txt file for this step, as Python does have ways of opening and reading CSV files. At the end of this lesson we will look at how to use the CSV reading and writing features in Python, but this is an optional advanced step.</p>\n<h2 id=\"write-your-python-program\">Write your Python program</h2>\n<p>The last step is to write a program that will check each of the texts for each of the keywords in the gazetteer, and then to provide an output that will tell us which entries in our spreadsheet contain which of those words. There are lots of ways that this could be achieved. When planning to write a program, it is always a good idea to devise an algorithm. An algorithm is a set of human-readable steps that will solve the problem. It&#39;s a list of what you are going to do, which you then convert into the appropriate programmatic instructions. The approach we will take here uses the following algorithm:</p>\n<ol>\n<li>Load the list of keywords that you&#39;ve created in <code>gazetteer.txt</code> and save them each to a Python list</li>\n<li>Load the texts from <code>texts.txt</code> and save each one to another Python list</li>\n<li>Then for each biographical entry, remove the unwanted punctuation (periods, commas, etc)</li>\n<li>Then check for the presence of one or more of the keywords from your list. If it finds a match, store it while it checks for other matches. If it finds no match, move on to the next entry</li>\n<li>Finally, output the results in a format that can be easily transferred back to the CSV file.</li>\n</ol>\n<h3 id=\"step-1-load-the-keywords\">Step 1: Load the Keywords</h3>\n<p>Using your text editor, create a new empty file, and add the following lines:</p>\n<pre><code class=\"language-python\">\n#Import the keywords\nf = open(&#39;gazetteer.txt&#39;, &#39;r&#39;)\nallKeywords = f.read().lower().split(&quot;\\n&quot;)\nf.close()\n\nprint(allKeywords)\nprint(len(allKeywords))\n</code></pre>\n<p>The first line is a comment for our own benefit, to tells us (the human) what the code does. All Python lines beginning with a # are a comment. When the code runs it will ignore the comments. They are for human use only. A well commented piece of code is easier to return to later because you will have the means of decyphering your earlier creation.</p>\n<p>The second line opens the <code>gazetteer.txt</code> file, and reads it, which is signified by the &#39;r&#39; (as opposed to &#39;w&#39; for write, or &#39;a&#39; for append). That means we will not be changing the contents of the file. Only reading it.</p>\n<p>The third line reads everything in that file, converts it to <code>lower()</code> case, and splits the contents into a Python list, using the <a href=\"http://stackoverflow.com/questions/11497376/new-line-python\">newline character</a> as the delimiter. Effectively that means each time the program comes across a new line, it stores it as a new entry. We then save that Python list containing the 39 counties into a variable that we have called <code>allKeywords</code>.</p>\n<p>The fourth line closes the open text file. The fifth line prints out the results, and the sixth line tells us how many results were found.</p>\n<p>Save this file as <code>extractKeywords.py</code>, again to the same folder as the other files, and then run it with Python. To do this from the command line, first you need to launch your command line terminal.</p>\n<p>On Windows it is called <code>Command Prompt</code>. Windows users may find it easier to launch Python by opening the folder containing your <code>extractKeywords.py</code> file, then press <code>shift</code> + <code>right-click</code> and then select &#39;open command window here&#39;. Assuming you have Python installed, you should be able to run your programme using the command beginning with &#39;python&#39; below.</p>\n<p>On Mac OS X, this is found in the <code>Applications</code> folder and is called <code>Terminal</code>. Once the Terminal window is open, you need to point your Terminal at the directory that contains all of the files you have just created. I have called my directory &#39;ExtractingKeywordSets&#39; and I have it on my computer&#39;s Desktop. To change the Terminal to this directory, I use the following command:</p>\n<pre><code class=\"language-bash\">cd Desktop/ExtractingKeywordSets\n</code></pre>\n<p>You would need to change the above to reflect the name you gave your directory, and where you put it on your machine. Note that Windows uses &#39;&#39; instead of &#39;/&#39; in file paths. If you get stuck, rename your directory to <code>ExtractingKeywordSets</code> and place it on the Desktop so that you can follow along.</p>\n<p>You can now run the program you&#39;ve written with the following command:</p>\n<pre><code class=\"language-bash\">python extractKeywords.py\n</code></pre>\n<p>Once you have run the program you should see your gazetteer printed as a Python list in the command output, along with the number of entries in your list (39). If you can, great! Move on to step 2. If the last line of your output tells you that there was 1 result, that means the code has not worked properly, since we know that there should be 39 keywords in your gazetteer. Double check your code to make sure you havn&#39;t included any typos. If you still can&#39;t solve the problem, try changing &quot;\\n&quot; to &quot;\\r&quot; on line three. Some text editors will use <a href=\"http://en.wikipedia.org/wiki/Carriage_return\">carriage returns</a> instead of &#39;newline characters&#39; when creating a new line. The \\r means &#39;carriage return&#39; and should solve your problem if you&#39;re experiencing one.</p>\n<h3 id=\"step-2-load-the-texts\">Step 2: Load the texts</h3>\n<p>The second step is very similar to the first. Except this time we will load the <code>texts.txt</code> in addition to the <code>gazetteer.txt</code> file</p>\n<p>Add the following lines to the end of your code:</p>\n<pre><code class=\"language-python\">#Import the texts you want to search\nf = open(&#39;texts.txt&#39;, &#39;r&#39;)\nallTexts = f.read().lower().split(&quot;\\n&quot;)\nf.close()\n\nprint(allTexts)\n</code></pre>\n<p>If you got step 1 to work, you should understand this bit as well. Before you run the code, make sure that you have saved your program or you may accidentally run the OLD version and will be confused with the result. Once you&#39;ve done that, rerun the code. As a shortcut, instead of writing out the command again in the Terminal, you can press the up arrow, which should display the last command you entered. If you keep pressing the up or down arrows, you can scroll through previous commands, saving yourself the time needed to retype them. Once you&#39;ve found the command for running the program, press the return key to run the code.</p>\n<p>If the code worked, you should see a big wall of text. Those are the texts we input into the program. As long as you see them, you&#39;re ok. Before moving on to the next step, delete the three lines from your code beginning with &#39;print&#39;. Now that we know they are printing the contents of these files properly we do not need to continue to check. Move on to step 3.</p>\n<h3 id=\"step-3-remove-unwanted-punctuation\">Step 3: Remove unwanted punctuation</h3>\n<p>When matching strings, you have to make sure the punctuation doesn&#39;t get in the way. Technically, &#39;London.&#39; is a different string than &#39;London&#39; or &#39;;London&#39; because of the added punctuation. These three strings which all mean the same thing to us as human readers will be viewed by the computer as distinct entities. To solve that problem, the easiest thing to do is just to remove all of the punctuation. You can do this with <a href=\"http://en.wikipedia.org/wiki/Regular_expression\">regular expressions</a>, and <a href=\"/lessons/understanding-regular-expressions\">Doug Knox</a> and <a href=\"/lessons/cleaning-ocrd-text-with-regular-expressions\">Laura Turner O&#39;Hara</a> have provided great introductions at <em>Programming Historian</em> for doing so.</p>\n<p>To keep things simple, this program will just replace the most common types of punctuation with nothing instead (effectively deleting punctuation).</p>\n<p>Add the following lines to your program:</p>\n<pre><code class=\"language-python\">for entry in allTexts:\n    #for each entry:\n    allWords = entry.split(&#39; &#39;)\n    for words in allWords:\n\n        #remove punctuation that will interfere with matching\n        words = words.replace(&#39;,&#39;, &#39;&#39;)\n        words = words.replace(&#39;.&#39;, &#39;&#39;)\n        words = words.replace(&#39;;&#39;, &#39;&#39;)\n</code></pre>\n<p>The &#39;allTexts&#39; list variable contains all of our texts. Using a for loop, we will look at each entry in turn.</p>\n<p>Since we are interested in single words, we will split the text into single words by using the .split() method, looking explicitly for spaces: <code>entry.split(&#39; &#39;)</code>. Note that there is a single space between those quotation marks. Since words are generally separated by spaces, this should work fairly well. This means we now have a Python list called &#39;allWords&#39; that contains each word in a single bibliographic entry.</p>\n<p>We use another for loop to look through each word in that list, and wherever we find a comma, period, or semi-colon, we replace it with nothing, effectively deleting it. Note that there is no space between those quotation marks in the last three lines.</p>\n<p>We now have a clean set of words that we can compare against our gazetteer entries, looking for matches.</p>\n<h3 id=\"step-4-look-for-matching-keywords\">Step 4: Look for matching keywords</h3>\n<p>As the words from our text are already in a list called &#39;allWords&#39;, and all of our keywords are in a list called &#39;allKeywords&#39;, all we have to do now is check our texts for the keywords.</p>\n<p>First, we need somewhere to store details of any matches we have. Immediately after the &#39;for entry in allTexts:&#39; line, at one level of indentation, add the following two lines of code:</p>\n<pre><code class=\"language-python\">    matches = 0\n    storedMatches = []\n</code></pre>\n<p>Indentation is important in Python. The above two lines should be indented one tab deeper than the for loop above it. That means the code is to run every time the for loop runs - it is part of the loop. If your text editor does not allow tabs, you can use spaces instead.</p>\n<p>The &#39;storedMatches&#39; variable is a blank list, where we can store our matching keywords. The &#39;matches&#39; variable is known as a &#39;flag&#39;, which we will use in the next step when we start printing the output.</p>\n<p>To do the actual matching, add the following lines of code to the bottom of your program, again minding the indentation (2 levels from the left margin), making sure you save:</p>\n<pre><code class=\"language-python\">        #if a keyword match is found, store the result.\n        if words in allKeywords:\n            if words in storedMatches:\n                continue\n            else:\n                storedMatches.append(words)\n            matches += 1\n    print(matches)\n</code></pre>\n<p>If you are worried that you have your indentation wrong, scroll ahead towards the bottom of the lesson and check the finished code.</p>\n<p>Take a look at your whole program. These lines follow immediately after the last section in which you removed the punctuation. So each time a word had its punctuation removed (if it had punctuation to remove in the first place) it was immediately checked to see if it was in the list of keywords in your gazetteer file. If it was a match, we check that we do not already have this word recorded in our &#39;storedMatches&#39; variable. If we do, we skip ahead to the next word. If it is not already recorded, we append it to the &#39;storedMatches&#39; list. This is keeping track of the matching words for us for each text. When we find a match, we also increase our &#39;matches&#39; flag by 1. This lets us know how many matches we have found for that entry.</p>\n<p>This code will automatically check each word in a text, keeping track of matches in the &#39;storedMatches&#39; list. When it gets to the end of a text, it will empty out the &#39;storedMatches&#39; variable and start again. Printing out the &#39;matches&#39; variable just lets us see how many matches we got for each text. When you run this code you should see somewhere between 0 and 2 for most entries. If it says 0 for everything then check your code again. If you only have one entry outputting then go back to step one and make sure your program is identifying the right number of keywords (39).</p>\n<p>{% include figure.html filename=&quot;extracting-keywords-3.png&quot; caption=&quot;Correct output of the code to this point&quot; %}</p>\n<p>If it looks like it worked, delete the &#39;print matches&#39; line and move to the next step.</p>\n<h3 id=\"step-5-output-results\">Step 5: Output results</h3>\n<p>If you have got to this stage, then your Python program is already finding the matching keywords from your gazetteer. All we need to do now is print them out to the command output pane in a format that&#39;s easy to work with.</p>\n<p>Add the following lines to your program, minding the indentation as always:</p>\n<pre><code class=\"language-python\">    #if there is a stored result, print it out\n    if matches == 0:\n        print(&#39; &#39;)\n    else:\n        matchString = &#39;&#39;\n        for matches in storedMatches:\n            matchString = matchString + matches + &quot;\\t&quot;\n\n        print(matchString)\n</code></pre>\n<p>This code checks if the number of matches is equal to 0. If so, then we havn&#39;t found any keywords and we don&#39;t need to print them out. However, we are going to print a blank space, because we want our output to contain the same number of lines as did our input (we want 1 line of output per line of text that we searched). This will make it easier to paste the output directly into our CSV file and have all of the entries line up properly with their corresponding text.</p>\n<p>If there IS a match, then the program creates a new variable called &#39;matchString&#39; (it could have been called just about anything. That&#39;s just the name I chose because it&#39;s a string of matches). Then for each of the matching keywords that were kept in &#39;storedMatches&#39;, it appends the keyword to &#39;matchString&#39;, along with a tab (&quot;\\t&quot;) character. The tab character is useful for CSV files because when you paste it into a spreadsheet, content separated by a tab will automatically go into an adjacent cell. This means that if a single text has more than one match, we&#39;ll be able to automatically paste one match per cell. This makes it easier to keep the keywords separate once we have them back in our CSV file.</p>\n<p>When all of the matching keywords have been added to &#39;matchString&#39;, the program prints it out to the command output before moving on to the next text.</p>\n<p>If you save your work and run the program, you should now have code that achieves all of the steps from the algorithm and outputs the results to your command output.</p>\n<p>The finished code should look like this:</p>\n<h2 id=\"finished-code\">Finished Code</h2>\n<pre><code class=\"language-python\">#Import the keywords\nf = open(&#39;gazetteer.txt&#39;, &#39;r&#39;)\nallKeywords = f.read().lower().split(&quot;\\n&quot;)\nf.close()\n\n#Import the texts you want to search\nf = open(&#39;texts.txt&#39;, &#39;r&#39;)\nallTexts = f.read().lower().split(&quot;\\n&quot;)\nf.close()\n\n#Our programme:\nfor entry in allTexts:\n    matches = 0\n    storedMatches = []\n\n    #for each entry:\n    allWords = entry.split(&#39; &#39;)\n    for words in allWords:\n\n        #remove punctuation that will interfere with matching\n        words = words.replace(&#39;,&#39;, &#39;&#39;)\n        words = words.replace(&#39;.&#39;, &#39;&#39;)\n        words = words.replace(&#39;;&#39;, &#39;&#39;)\n\n\n        #if a keyword match is found, store the result.\n        if words in allKeywords:\n            if words in storedMatches:\n                continue\n            else:\n                storedMatches.append(words)\n            matches += 1\n\n    #if there is a stored result, print it out\n    if matches == 0:\n        print(&#39; &#39;)\n    else:\n        matchString = &#39;&#39;\n        for matches in storedMatches:\n            matchString = matchString + matches + &quot;\\t&quot;\n\n        print(matchString)\n</code></pre>\n<p>If you do not like the output format, you can change it by adjusting the second last line of code. For example, you could save each entry to a new line in a .txt file rather than to the screen. To do that you would replace &#39;print matchString&#39; with the following code (make sure it is at one level of indentation, just as was the replaced line):</p>\n<pre><code class=\"language-python\">    f = open(&#39;output.txt&#39;, &#39;a&#39;)\n    f.write(matchString)\n    f.close()\n</code></pre>\n<p>Note the &#39;a&#39; instead of the &#39;r&#39; we used earlier. This &#39;appends&#39; the text to the file called <code>output.txt</code>, which will be saved in your working directory. You will have to take care, because running the program several times will continue to append all of the outputs to this file, creating a very long file. There are ways around this, which we will cover in a moment, and you might consider looking into how the &#39;w&#39; (write) feature works, and experimenting with output formats. There is more information related to these features in <a href=\"/lessons/working-with-text-files\">&#39;Working with Text Files in Python&#39;</a>.</p>\n<h2 id=\"refining-the-gazetteer\">Refining the Gazetteer</h2>\n<p>You can copy and paste that output directly into your spreadsheet next to the first entry. Check that the matches lined up properly. Your last entry of your spreadsheet should correspond to the correctly extracted keywords. In this case, the last entry should be blank, but the second last one should read &#39;dorset&#39;.</p>\n<p>{% include figure.html filename=&quot;extracting-keywords-4.png&quot; caption=&quot;The output pasted back into the CSV file&quot; %}</p>\n<p>At this point, you might like to refine the gazetteer, as a lot of place names have been missed. Many of them are shortforms, or archaic spellings (Wilts, Salop, Sarum, Northants, etc). You could go through looking at all the empty cells and seeing if you can find keywords that you&#39;ve missed. It may help to know that you can find the next empty cell in a column in Excel by pressing CTRL + down arrow (CMD + down arrow on Mac).</p>\n<p>One of the easiest ways to find all of the missing entries is to sort your spreadsheet by the new columns you&#39;ve just added. If you sort the matches alphabetically for each of the new columns, then the entries at the bottom of the spreadsheet will all be unclassified. You can do this by selecting the whole spreadsheet and clicking on the Data -&gt; Sort menu item. You can then sort a-z for each of the new columns.</p>\n<p>Before you sort a spreadsheet, it&#39;s often a good idea to add an &#39;original order&#39; column in case you want to sort them back. To do this, add a new column, and in the first 3 rows, type 1, 2, and 3 respectively. Then highlight the three cells and put your cursor over the bottom right corner. If you are using Microsoft Excel your cursor will change into a black cross. When you see this, click and hold the mouse button and drag the cursor down until you reach the bottom of the spreadsheet (down to the last entry) before you let go. This should automatically number the rows consecutively so that you can always re-sort your entries back to the original order.</p>\n<p>{% include figure.html filename=&quot;extracting-keywords-5.png&quot; caption=&quot;Adding an original order column and sorting the entries&quot; %}</p>\n<p>Now you can sort the data and read some of the entries for which no match was found. If you find there is a place name in there, add it to your &#39;gazetteer.txt&#39; file, one entry per line. You don&#39;t have to be exhaustive at this stage. You could add a handful more entries and then try the code again to see what impact they had on the result.</p>\n<p>{% include figure.html filename=&quot;extracting-keywords-6.png&quot; caption=&quot;Missed place name words highlighted in yellow&quot; %}</p>\n<p>Before you re-run your Python code, you&#39;ll have to update your <code>texts.txt</code> file so that the program runs on the texts in the correct order. Since the code will output the matches in the same order that it receives the files in <code>texts.txt</code>, it&#39;s important not to get this jumbled up if you&#39;ve been sorting your spreadsheet where you intend to store your outputs. You can either re-sort the spreadsheet back to the original order before you run the program, or you can copy all of the cells in the &#39;details&#39; column again and paste and save them into the <code>texts.txt</code> file.</p>\n<p>I&#39;d challenge you to make a few refinements to your gazetteer before moving ahead, just to make sure you have the hang of it.</p>\n<p>Once you are happy with that, you can snag my <a href=\"/assets/extracting-keywords-final-gazetteer.txt\">completed list of English and Welsh counties, shortforms, and various other cities (London, Bristol etc) and places (Jersey, Ireland, etc)</a>. My completed list contains 157 entries, and should get you all of the entries that can be extracted from the texts in this collection.</p>\n<p>At this point you could stop, as you&#39;ve achieved what you set out to do. This lesson taught you how to use a short Python program to search a fairly large number of texts for a set of keywords defined by you.</p>\n<p>With the outputs from this lesson, you could fairly quickly map these entries by geolocating the place names. This might reveal new insights into spatial patterns of Oxford alumni.</p>\n<p>Having the ability to search for large numbers of keywords at the same time opens up flexibility for your research process, and makes it feasible to do work that might otherwise just have seemed like it would take too long. You could try a completely different set of words, or use this technique on another set of texts entirely. The research questions are of course, endless.</p>\n<p>If you would like to refine the program further, we can use Python to read directly from the CSV file and to print the results to a new CSV file so that everything happens automatically from the Terminal window without the need for cutting and pasting.</p>\n<h2 id=\"printing-the-results-back-to-the-csv-file-using-python\">Printing the Results Back to the CSV File Using Python</h2>\n<p>Python has a built in code library that can handle working with CSV files, called <code>csv</code></p>\n<p>To use it and its features, you first have to import it. At the top of your <code>extractKeywords.py</code> program, add the following line:</p>\n<pre><code class=\"language-python\">    import csv\n</code></pre>\n<p>Now we are going to make some changes to our original program. Instead of cutting all of the texts into a <code>texts.txt</code> file, we&#39;ll use Python to read the data directly into our &#39;allTexts&#39; variable. Replace:</p>\n<pre><code class=\"language-python\">#Import the texts you want to search\nf = open(&#39;texts.txt&#39;, &#39;r&#39;)\nallTexts = f.read().lower().split(&quot;\\n&quot;)\nf.close()\n</code></pre>\n<p>With this:</p>\n<pre><code class=\"language-python\">\n#Import the &#39;Details&#39; column from the CSV file\nallTexts = []\nfullRow = []\nwith open(&#39;The_Dataset_-_Alumni_Oxonienses-Jas1.csv&#39;) as csvfile:\n    reader = csv.DictReader(csvfile)\n    for row in reader:\n        #the full row for each entry, which will be used to recreate the improved CSV file in a moment\n        fullRow.append((row[&#39;Name&#39;], row[&#39;Details&#39;], row[&#39;Matriculation Year&#39;]))\n\n        #the column we want to parse for our keywords\n        row = row[&#39;Details&#39;].lower()\n        allTexts.append(row)\n</code></pre>\n<p>As this is an advanced option, I won&#39;t explain what every line does in detail, but you can take a look at the comments in the code to get an idea. Effectively this uses Python to read the CSV file and stores all of the information in the &#39;Details&#39; column in the same &#39;allTexts&#39; variable that we had it in previously, in exactly the same format as before. This code also stores each row of the CSV file into another list called &#39;fullRow&#39;, which will be used for writing a new CSV file containing our program&#39;s outputs.</p>\n<p>There are a few extra lines of code here, but you didn&#39;t need to cut and paste anything into the <code>texts.txt</code> file, and there&#39;s no risk here of your sorting of your spreadsheet causing any issues about the order of inputs and outputs. This is therefore a more robust option. You can print out either of these variables using the &#39;print&#39; feature, to make sure they contain what you&#39;d expect of them.</p>\n<hr>\n<p><strong>TROUBLESHOOTING</strong>: If you get the following error when you attempt to read your CSV file using Python, the CSV file may have been saved on a Mac, and the Python CSV library is only able to read Windows-compatible CSV files</p>\n<pre><code class=\"language-text\">(Error: new-line character seen in unquoted field - do you need to open the file in universal-newline mode?).\n</code></pre>\n<p>To solve this problem, open your CSV file in a spreadsheet program (eg., Excel) and &#39;Save As&#39; and under format chose &#39;Windows Comma Separated (csv)&#39;. This should solve the problem. To read more on this issue, see <a href=\"http://stackoverflow.com/questions/17315635/csv-new-line-character-seen-in-unquoted-field-error\">Stack Overflow</a></p>\n<hr>\n<h2 id=\"creating-a-new-csv-file\">Creating a new CSV file</h2>\n<p>Next we need to create a new CSV file where the results of the analysis can be stored. It&#39;s always a good idea to make a new file rather than try to append it to your only copy of the original data. It&#39;s also a good idea to append the current date and time to the filename for your new file. That way you can run the code lots of times as you refine everything and it will always be clear which file contains your most recent ouputs.</p>\n<p>To do this, import the &#39;time&#39; library just below where you imported the &#39;csv&#39; library.</p>\n<pre><code class=\"language-python\">\nimport time\n</code></pre>\n<p>And then add the following two lines of code right below where you were just working with the new CSV code:</p>\n<pre><code class=\"language-python\">\n#use the current date and time to create a unique output filename\ntimestr = time.strftime(&quot;%Y-%m-%d-(%H-%M-%S)&quot;)\nfilename = &#39;output-&#39; + str(timestr) + &#39;.csv&#39;\n</code></pre>\n<p>This will create a variable called &#39;filename&#39;, which we&#39;ll use when we make the new output file.</p>\n<p>The rest of the process involves creating that new output file, putting in the correct headers, pasting in the original data, and then pasting in our new outputs from our gazetteer matching. That involves quite a few tweaks to the original code, so to keep everything as clear as possible, I&#39;ve included the finished code below. I have appended &#39;NEW!&#39;, &#39;OLD!&#39; and &#39;CHANGED!&#39; in the comments for each section so that you can see at a glance which bits have changed:</p>\n<pre><code class=\"language-python\">\n#NEW!\nimport csv\nimport time\n\n#OLD! Import the keywords\nf = open(&#39;gazetteer.txt&#39;, &#39;r&#39;)\nallKeywords = f.read().lower().split(&quot;\\n&quot;)\nf.close()\n\n\n#CHANGED! Import the &#39;Details&#39; column from the CSV file\nallTexts = []\nfullRow = []\nwith open(&#39;The_Dataset_-_Alumni_Oxonienses-Jas1.csv&#39;) as csvfile:\n    reader = csv.DictReader(csvfile)\n    for row in reader:\n        #the full row for each entry, which will be used to recreate the improved CSV file in a moment\n        fullRow.append((row[&#39;Name&#39;], row[&#39;Details&#39;], row[&#39;Matriculation Year&#39;]))\n\n        #the column we want to parse for our keywords\n        row = row[&#39;Details&#39;].lower()\n        allTexts.append(row)\n\n#NEW! a flag used to keep track of which row is being printed to the CSV file\ncounter = 0\n\n#NEW! use the current date and time to create a unique output filename\ntimestr = time.strftime(&quot;%Y-%m-%d-(%H-%M-%S)&quot;)\nfilename = &#39;output-&#39; + str(timestr) + &#39;.csv&#39;\n\n#NEW! Open the new output CSV file to append (&#39;a&#39;) rows one at a time.\nwith open(filename, &#39;a&#39;) as csvfile:\n\n    #NEW! define the column headers and write them to the new file\n    fieldnames = [&#39;Name&#39;, &#39;Details&#39;, &#39;Matriculation Year&#39;, &#39;Placename&#39;]\n    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n    writer.writeheader()\n\n    #NEW! define the output for each row and then print to the output csv file\n    writer = csv.writer(csvfile)\n\n    #OLD! this is the same as before, for currentRow in fullRow:\n    for entry in allTexts:\n\n        matches = 0\n        storedMatches = []\n\n        #for each entry:\n        allWords = entry.split(&#39; &#39;)\n        for words in allWords:\n\n            #remove punctuation that will interfere with matching\n            words = words.replace(&#39;,&#39;, &#39;&#39;)\n            words = words.replace(&#39;.&#39;, &#39;&#39;)\n            words = words.replace(&#39;;&#39;, &#39;&#39;)\n\n            #if a keyword match is found, store the result.\n            if words in allKeywords:\n                if words in storedMatches:\n                    continue\n                else:\n                    storedMatches.append(words)\n                matches += 1\n\n        #CHANGED! send any matches to a new row of the csv file.\n        if matches == 0:\n            newRow = fullRow[counter]\n        else:\n            matchTuple = tuple(storedMatches)\n            newRow = fullRow[counter] + matchTuple\n\n        #NEW! write the result of each row to the csv file\n        writer.writerows([newRow])\n        counter += 1\n</code></pre>\n<p>The code is heavily commented so if you spend some time, you should be able to figure it out. Save this code and rerun it using Python and you should get a file called <code>output.csv</code> appearing in your working directory, which if you open it should contain all of the same information as you had before, but without the need to do any cutting or pasting.</p>\n<p>To give a brief outline of what has been changed from the original version:</p>\n<ol>\n<li>The texts were extracted automatically from the original datafile instead of having to paste them into a <code>texts.txt</code> file.</li>\n<li>Using the &#39;time&#39; library, we used the current date and time to create a unique and easily decypherable filename for our output file.</li>\n<li>Using the &#39;csv&#39; library we created a new .csv file using that filename, and put in the column headers we wanted to use.</li>\n<li>We then ran the same matching code as before, checking &#39;allTexts&#39; against &#39;allWords&#39; and storing the results.</li>\n<li>Instead of printing the results to the screen, we stored each row&#39;s original data (Name, Details, Matriculation Year) + the matches to a <a href=\"https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences\">tuple</a> called &#39;newRow&#39;.</li>\n<li>Using the &#39;csv&#39; library we wrote the &#39;newRow&#39; data to the new CSV file, one row at a time.</li>\n</ol>\n<p>This approach created longer and more complex code, but the result is a powerful program that reads from a CSV file, matches the texts against the contents of a gazetteer, and then automatically writes the output to a clean new CSV file with no intermediary steps for you the user. You didn&#39;t have to go that extra mile, but hopefully you can see the advantages if you made it all the way through.</p>\n<h2 id=\"suggested-further-reading\">Suggested Further Reading</h2>\n<p>Readers who have completed this lesson might be interested in then geo-referencing the output using the Google API and mapping the results. You can learn more about this process from Fred Gibbs&#39;s tutorial, <a href=\"http://fredgibbs.net/tutorials/extract-geocode-placenames-from-text-file.html\">Extract and Geocode Placenames from a Text File</a>. This will let you visualise the practical outputs of this tutorial. Alternatively, readers may be interested in <a href=\"/lessons/georeferencing-qgis\">Jim Clifford et. al&#39;s tutorial on georeferencing in QGIS 2.0</a>, an open source <a href=\"https://en.wikipedia.org/wiki/Geographic_information_system\">GIS</a> program.</p>\n"}