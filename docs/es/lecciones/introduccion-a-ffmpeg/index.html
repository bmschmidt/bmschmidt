<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="description" content="" />
		<link rel="icon" href="/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		

		

		<link rel="stylesheet" href="/_app/assets/start-61d1577b.css">
		<link rel="stylesheet" href="/_app/assets/pages/__layout.svelte-18e41d87.css">
		<link rel="modulepreload" href="/_app/start-95fbef14.js">
		<link rel="modulepreload" href="/_app/chunks/vendor-8de6a194.js">
		<link rel="modulepreload" href="/_app/pages/__layout.svelte-a3da538f.js">
		<link rel="modulepreload" href="/_app/chunks/stores-55c0c2f0.js">
		<link rel="modulepreload" href="/_app/chunks/translate-48f5a27b.js">
		<link rel="modulepreload" href="/_app/pages/_lang_/_lessons_/_slug_/index.svelte-f85508fc.js">
		<link rel="modulepreload" href="/_app/chunks/markdown-a73b7c4d.js">

		<script type="module">
			import { start } from "/_app/start-95fbef14.js";
			start({
				target: document.querySelector("#svelte"),
				paths: {"base":"","assets":""},
				session: {},
				route: true,
				spa: false,
				trailing_slash: "never",
				hydrate: {
					status: 200,
					error: null,
					nodes: [
						import("/_app/pages/__layout.svelte-a3da538f.js"),
						import("/_app/pages/_lang_/_lessons_/_slug_/index.svelte-f85508fc.js")
					],
					url: new URL("sveltekit://prerender/es/lecciones/introduccion-a-ffmpeg"),
					params: {lang:"es",lessons:"lecciones",slug:"introduccion-a-ffmpeg"}
				}
			});
		</script><script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('/service-worker.js');
			}
		</script>
	</head>
	<body>
		<div id="svelte">


<div class="collapse navbar-collapse" style="display:flex" id="navbarNavDropdown"><h2>Programming Historian en español</h2>
	<a class="nav-link" href="/es/lecciones">Lecciones</a><a class="nav-link" href="/es/acerca-de">Acerca</a><a class="nav-link" href="/es/investigacion">Investigación</a><a class="nav-link" href="/es/apoyanos">Apóyanos</a>
<div class="btn-group" role="menuitem" aria-label="Language selector"><a class="btn btn-secondary nav-link" role="button" href="/en">en</a><a class="btn btn-secondary nav-link active" role="button" href="/es">es</a><a class="btn btn-secondary nav-link" role="button" href="/fr">fr</a><a class="btn btn-secondary nav-link" role="button" href="/pt">pt</a></div></div>


<br>
<h1>Introducción a la transcodificación, edición y visualización de datos audiovisuales con FFmpeg</h1>

<!-- HTML_TAG_START --><p>{% include toc.html %}</p>
<h1>Introducción</h1>
<p>Historicamente, las Humanidades Digitales se han enfocado casi exclusivamente en el analisis de fuentes textuales a través de métodos computacionales (Hockey, 2004). Sin embargo, hay un interés creciente en el campo de la utilización de métodos computacionales para el análisis de materiales audiovisuales de patrimonio cultural, como refleja la creación de la <a href="https://avindhsig.wordpress.com/">Alianza de Organizaciones de Humanidades Digitales Grupo de Interés Especial: Materiales audiovisuales en Humanidades Digitales</a> y <a href="https://figshare.com/articles/AV_in_DH_State_of_the_Field/5680114">el aumento de las presentaciones relacionadas con temas audiovisuales en la conferencia global de AOHD</a> en los años anteriores. Investigaciones recientes, tal como <a href="https://distantviewing.org">Distant Viewing TV</a>, indican un cambio en el campo hacia proyectos relacionados con el uso de técnicas computacionales para ampliar el alcance de los materiales que los y las humanistas digitales pueden explorar. Como afirma Erik Champion, &quot;la audiencia de Humanidades Digitales no siempre está enfocada en la literatura o está interesada en las formas tradicionales de alfabetización&quot; y la aplicación de metodologías digitales para estudiar cultura audiovisual es una faceta emergente y emocionante de las humanidades digitales (Champion, 2017, traducido por el autor). Hay muchas herramientas valiosas, gratuitas y de código abierto disponibles para aquellos interesados en trabajar con materiales audiovisuales (por ejemplo, el tutorial de <em>Programming Historian</em> <a href="/es/lecciones/editar-audio-con-audacity">Editar Audio con Audacity</a>). Este tutorial presentará otra: FFmpeg.</p>
<p><a href="https://www.ffmpeg.org/about.html">FFmpeg</a> es el <em>framework</em> multimedia de código abierto líder para transcodificar, editar, filtrar y reproducir casi cualquier tipo de formato audiovisual digital (sitio web de FFmpeg - &quot;About&quot;). Muchos programas comunes y sitios web usan FFmpeg para leer y escribir archivos audiovisuales, por ejemplo, VLC, Google Chrome, YouTube y <a href="https://trac.ffmpeg.org/wiki/Projects">muchos más</a>. Además de ser una herramienta de programa y de desarrollo web, FFmpeg se puede usar en la interfaz de la línea de comandos para realizar muchas tareas comunes, complejas e importantes, relacionadas con la gestión, modificación y análisis de archivos audiovisuales. Estos tipos de procesos, tales como editar, transcodificar o extraer los metadatos de archivos, generalmente requieren acceso a otro programa (tal como editores de vídeo no lineal, como Adobe Premiere o Final Cut Pro); sin embargo, FFmpeg permite a un usuario operar directamente en archivos audiovisuales sin el uso de interfaces o programa de terceros. Como tal, el conocimiento del <em>framework</em> permite a los usuarios manipular materiales audiovisuales para satisfacer sus necesidades con una solución de código abierto y gratuita, que ofrece gran parte de la funcionalidad de un costoso programa de audio y vídeo. Este tutorial ofrece una introducción a la lectura y escritura de comandos de FFmpeg y una guía paso a paso a partir de un caso práctico para aprender a utilizar el <em>framework</em> en un trabajo específico para los humanistas digitales. Específicamente, se mostrará cómo FFmpeg puede ser utilizado para extraer y analizar datos de color en un video archivístico.</p>
<h2>Objetivos de aprendizaje</h2>
<ul>
<li>Instalar FFmpeg en tu computadora o usar una versión &quot;demo&quot; en el navegador web</li>
<li>Comprender la estructura básica y la sintaxis de los comandos de FFmpeg</li>
<li>Aprender varios comandos útiles, tales como:
<ul>
<li>&quot;Re-wrap&quot; (cambiar el contenedor) y transcodificar (recodificar archivos)</li>
<li>&quot;Demux&quot; de archivos (separar audio y vídeo)</li>
<li>Recortar/Editar archivos</li>
<li>Usar FFplay para reproducir archivos</li>
<li>Crear vectorscopios para visualizar los datos de color</li>
<li>Usar FFprobe para generar informes de los datos de color</li>
</ul>
</li>
<li>Introducir recursos para mayor exploración y experimentación</li>
</ul>
<h2>Requisitos previos</h2>
<p>Antes de comenzar con este tutorial, es necesario que localices la <a href="https://es.wikipedia.org/wiki/Terminal_(macOS)">Terminal</a> de tu computadora u otra interfaz de línea de comandos, ya que ahí es donde ingresarás y ejecutarás los comandos de FFmpeg. Si necesitas instrucción para acceder y usar la interfaz de línea de comandos, te recomendamos la lección de <em>Programming Historian</em> <a href="/es/lecciones/introduccion-a-bash">Introducción a la línea de comandos en Bash</a> para usarios de Mac y Linux o, para usarios de Windows, <a href="/es/lecciones/introduccion-a-powershell">Introducción a la línea de comandos de Windows con PowerShell</a>. Adicionalmente, será de utilidad tener conocimientos básicos de <a href="https://es.wikipedia.org/wiki/C%C3%B3dec">códecs</a> y <a href="https://es.wikipedia.org/wiki/Formato_contenedor">contenedores</a> audiovisuales para entender con mayor detalle el funcionamiento de FFmpeg. Proporcionaremos información adicional y revisaremos con mayor detalle sobre códecs y contenedores en la sección sobre ejemplos de comandos preliminares de este tutorial.</p>
<h1>Cómo instalar FFmpeg</h1>
<p>La instalación de FFmpeg es posiblemente la parte más difícil de usar esta herramienta. Afortunadamente, existen algunas guías y recursos disponibles para instalar el <em>framework</em> para cada sistema operativo.</p>
<div class="alert alert-warning">
Nuevas versiones de FFmpeg son lanzadas aproximadamente cada seis meses. Para mantenerse al tanto de ellas, es recomendable seguir a FFmpeg en <a href="https://twitter.com/FFmpeg">Twitter</a> o en su sitio web. Las nuevas versiones de FFmpeg generalmente contienen características tales como filtros nuevos y actualizados, compatibilidades de códecs y corrección de errores. La sintaxis de FFmpeg no cambia con estas actualizaciones y las capacidades antiguas rara vez se eliminan. Puedes aprender más sobre estas actualizaciones consultando los anuncios de actualizaciones anteriores en la sección de <a href="https://www.ffmpeg.org/index.html#news">News</a> en el sitio web de FFmpeg.
</div>
<h2>Para usuarios de Mac OS</h2>
<p>La opción más simple es usar un administrador de paquetes como <a href="https://brew.sh/">Homebrew</a> para instalar FFmpeg y asegurar que permanezca en la versión más reciente. Para completar este tipo de instalación, sigue estos pasos:</p>
<ul>
<li>
<p>Instala Homebrew de acuerdo a las instrucctiones en el enlace de arriba</p>
</li>
<li>
<p>Para comenzar con una instalación básica, ejecuta <code>brew install ffmpeg</code> en tu Terminal para comenzar una instalación básica
<strong>Nota</strong>: generalmente se recomienda instalar FFmpeg con opciones adicionales a la incluidas en la instalación básica; esto proporcionará acceso a más herramientas y funciones. <a href="https://avpres.net/FFmpeg/install_Apple.html">La Guía de Instalación de Apple de Reto Kromer</a> proporciona un buen conjunto de opciones adicionales:</p>
<pre><code class="language-bash">brew install ffmpeg --with-freetype --with-openjpeg --with-x265 --with-rubberband --with-tesseract
</code></pre>
<ul>
<li>
<p>Para una explicación de estas opciones adicionales, revisa <a href="https://training.ashleyblewer.com/presentations/ffmpeg.html#10">La Guía FFmpeg de Ashley Blewer</a>.</p>
</li>
<li>
<p>Además, puedes ejecutar <code>brew options ffmpeg</code> para ver qué características están o han estado disponibles en la versión actual de FFmpeg</p>
</li>
<li>
<p>Para actualizar tu instalación a la versión más reciente, ejecuta:</p>
<pre><code class="language-bash">brew update &amp;&amp; brew upgrade ffmpeg
</code></pre>
</li>
</ul>
</li>
<li>
<p>Para más opciones de instalación para Mac OS, revisa <a href="https://trac.ffmpeg.org/wiki/CompilationGuide/macOS">La Guía de Compilación de FFmpeg para Mac OS</a> (la guía solo está disponible en inglés).</p>
</li>
</ul>
<h2>Para usuarios de Windows</h2>
<p>Los usarios de Windows pueden usar el adminstratdor de paquetes <a href="https://chocolatey.org/">Chocolately</a> para instalar y mantener FFmpeg. <a href="https://avpres.net/FFmpeg/install_Windows.html">La Guía de Instalación de Windows de Reto Kromer</a> proporciona toda la información necesaria para usar Chocolately o construir el <em>framework</em> a partir del código fuente (la guía solo está disponible en inglés).</p>
<h2>Para usuarios de Linux</h2>
<p><a href="ttp://linuxbrew.sh/">Linuxbrew</a> es un programa similar a Homebrew que se puede utilizar para instalar y mantener FFmepg en Linux. Reto Kromer también proporciona una guía útil, <a href="https://avpres.net/FFmpeg/install_Linux.html">la Guía de Instalación de Linux</a>, que es similar a la instalación en Mac OS. Tu distribución de Linux puede tener su <a href="https://www.linode.com/docs/tools-reference/linux-package-management/">propio administrador de paquetes</a> que incluye paquetes FFmpeg (la guía solo está disponible en inglés). Dependiendo de tu distribución de Linux (Ubuntu, Fedora, Arch Linux, etc.) estas versiones pueden variar, así que usar Linuxbrew podría ser útil para asegurar que la versión es la misma independientemente del tipo de Linux que utilices.</p>
<h2>Otros recursos de instalación</h2>
<ul>
<li><a href="https://www.ffmpeg.org/download.html">Descarga de paquetes</a>
<ul>
<li>FFmpeg permite el accesso a archivos binarios, código fuente y versiones estáticas para Mac, Windows y Linux directamente en su sitio web. Los usuarios pueden construir el <em>framework</em> sin un administrador de paquetes con estos recursos. Es probable que solo los usuarios avanzados quieran usar esta opción.</li>
</ul>
</li>
<li><a href="https://trac.ffmpeg.org/wiki/CompilationGuide">La Guía de Compilación de FFmpeg</a>
<ul>
<li>La página Wiki de FFmpeg también proporciona un compendio de guías y estrategias para instalar FFmpeg en tu computadora (la guía solo está disponible en inglés).</li>
</ul>
</li>
</ul>
<h2>Probando la instalación</h2>
<ul>
<li>
<p>Para asegurarte de que FFmpeg se haya instalado correctamente, ejecuta:</p>
<pre><code class="language-bash">ffmpeg -version
</code></pre>
</li>
<li>
<p>Si ves una lista larga con información, ¡la instalación fue exitosa! Debe ser similar a lo siguiente:</p>
</li>
</ul>
<pre><code class="language-bash">ffmpeg version 4.0.1 Copyright (c) 2000-2018 the FFmpeg developers
built with Apple LLVM version 9.1.0 (clang-902.0.39.1)
configuration: --prefix=/usr/local/Cellar/ffmpeg/4.0.1 --enable-shared --enable-pthreads --enable-version3 --enable-hardcoded-tables --enable-avresample --cc=clang --host-cflags= --host-ldflags= --enable-gpl --enable-ffplay --enable-libfreetype --enable-libmp3lame --enable-librubberband --enable-libtesseract --enable-libx264 --enable-libx265 --enable-libxvid --enable-opencl --enable-videotoolbox --disable-lzma --enable-libopenjpeg --disable-decoder=jpeg2000 --extra-cflags=-I/usr/local/Cellar/openjpeg/2.3.0/include/openjpeg-2.3
libavcodec     58. 18.100 / 58. 18.100
libavformat    58. 12.100 / 58. 12.100
libavdevice    58.  3.100 / 58.  3.100
libavfilter     7. 16.100 /  7. 16.100
libavresample   4.  0.  0 /  4.  0.  0
libswscale      5.  1.100 /  5.  1.100
libswresample   3.  1.100 /  3.  1.100
libpostproc    55.  1.100 / 55.  1.100
</code></pre>
<ul>
<li>Si el sistema arroja <code>-bash: ffmpeg: command not found</code>, algo ha ido mal.
<ul>
<li>Nota: Si estás usando un administrador de paquetes, es improbable que encuentres este mensaje de error. Sin embargo, si hay un problema después de instalar con un administrador de paquetes, es probable que haya un problema con el administrador de paquetes y no con FFmpeg. Consulta la solución de problemas en <a href="https://docs.brew.sh/Troubleshooting">Homebrew</a>, <a href="https://chocolatey.org/docs/troubleshooting">Chocolatey</a>, o <a href="http://linuxbrew.sh/">Linuxbrew</a> para asegurar que el administrador de paquetes está funcionando correctamente en tu computadora (las guías solo está disponible en inglés). Si estás intentando instalar sin un administrador de paquetes y ves este mensaje de error, haz una referencia cruzada de tu método con la La Guía de Compilación de FFmpeg anterior.</li>
</ul>
</li>
</ul>
<h2>Usando FFmpeg en el navegador</h2>
<p>Si no quieres instalar FFmepg en tu computadora pero te gustaría familiarizarte con el <em>framework</em> y usarlo en la interfaz de línea de comandos, <a href="https://bgrins.github.io/videoconverter.js/demo/">videoconverter.js</a> de Brian Grinstead proporciona un método para ejecutar los comandos FFmpeg en tu navegador (la interfaz está en inglés).</p>
  <div class="alert alert-warning">
  Esta interfaz del navegador no tiene las funcionalidades como para completar todo este tutorial, pero es útil para aprender los comandos esenciales de FFmpeg. Adicionalmente, este recurso opera en una versión anterior de FFmpeg y posiblemente no tenga todas las características de la versión más reciente.
</div>
<h2>Estructura básica y sintaxis de los comandos FFmpeg</h2>
<p>El comando básico tiene cuatro partes:</p>
<pre><code class="language-bash">[Símbolo del Sistema] [Archivo de Entrada] [Banderas/Acciones] [Archivo de Salida]
</code></pre>
<ul>
<li>Cada comando comenzará con un símbolo del sistema. Dependiendo del uso, este será <code>ffmpeg</code> (cambiar archivos), <code>ffprobe</code> (generar metadatos de archivos) o <code>ffplay</code> (reproducir archivos).</li>
<li>Los archivos de entradas son los archivos que están siendo leídos, editados o examinados.</li>
<li>Las banderas y acciones son las cosas que le estás diciendo a FFmpeg que haga con los archivos de entrada. La mayoría de los comandos contendrán múltiples banderas y acciones de complejidad variable.</li>
<li>Los archivos de salida son los archivos creados por el comando o los informes creados por los commandos de <code>ffprobe</code>.</li>
</ul>
<p>Escrito genéricamente, el comando básico es parecido a lo siguiente:</p>
<pre><code class="language-bash"> ffmpeg -i /ruta_de_archivo/archivo_de_entrada.ext -bandera alguna_acción /ruta_de_archivo/archivo_de_salida.ext
</code></pre>
<div class="alert alert-warning">
Como con cualquier interfaz de línea de comandos, tendrás que escribir las rutas de los archivos de entrada y de salida dependiendo de las ubicaciones de tus directorios de trabajo. En los ejemplos proporcionados en este tutorial, las rutas de archivos no estarán escritas completamente y se supone que el usuario ha navegado al directorio de trabajo para ejecutar los comandos.</div>
<p>A continuación, examinaremos algunos ejemplos de varios comandos diferentes que usan esta estructura y sintaxis. Adicionalmente, estos comandos demostrarán algunas de las características más útiles de FFmpeg y nos permitirán familiarizarnos con la forma en que se construyen los archivos audiovisuales digitales.</p>
<h1>Para empezar</h1>
<p>Para este tutorial, utilizaremos una película archivística que se llama <a href="https://archive.org/details/4050_Destination_Earth_01_47_33_28"><em>Destination Earth</em></a> como nuestro objeto de estudio. Esta película está publicada por los <a href="https://es.wikipedia.org/wiki/Archivos_Prelinger">Archivos Prelinger</a> y en el <a href="https://archive.org/">Internet Archive</a>. Esta película, estrenada en 1956 y producida por <a href="https://es.wikipedia.org/wiki/American_Petroleum_Institute">El American Petroleum Institute</a> y <a href="https://en.wikipedia.org/wiki/John_Sutherland_(producer)">John Sutherland Productions</a>, es un excelente ejemplo de la propaganda de la época de la Guerra Fría que exalta las virtudes del capitalismo y el estilo de vida estadounidense. Utilizando el proceso de <a href="https://es.wikipedia.org/wiki/Technicolor">Technicolor</a>, este corto animado de ciencia ficción cuenta la historia de una sociedad marciana que vive bajo un gobierno opresivo y sus esfuerzos para mejorar sus métodos industriales. Envían un emisario a la Tierra que descubre que la clave para esto es la refinación de petróleo y la libre empresa. Utilizaremos el vídeo para introducir algunas de las funcionalidades básicas de FFmpeg y analizar sus propiedades de color con relación a su retórica propagandística.</p>
<p>{% include figure.html filename=&quot;destEarth_titlecard.png&quot; caption=&quot;Destination Earth (1956)&quot; %}</p>
<p>En este tutorial se llevarán a cabo los siguientes pasos:</p>
<ul>
<li>Navegar a la página de <a href="https://archive.org/details/4050_Destination_Earth_01_47_33_28"><em>Destination Earth</em></a> en el Internet Archive</li>
<li>Descargar dos archivos vídeos: las versiones &quot;MPEG4&quot; (extensión de archivo <code>.m4v</code>) y &quot;OGG&quot; (extensión de archivo <code>.ogv</code>) de la película</li>
<li>Guardar estos archivos en la misma carpeta en algún lugar de tu computadora. Guárdalos con los nombres de archivos <code>destEarth</code>, seguido por su extensión.</li>
</ul>
<p>Tómate unos minutos para ver el vídeo y tener una idea de su estructura, mensaje y motivos visuales antes de continuar con los siguientes comandos.</p>
<h1>Ejemplos de comandos preliminares</h1>
<h2>Ver metadatos básicos con FFprobe</h2>
<p>Antes de comenzar a manipular nuestros archivos <code>destEarth</code>, usemos FFmpeg para examinar información básica sobre el archivo utilizando un simple comando de <code>ffprobe</code>. Esto ayudará a comprender cómo se construyen los archivos audiovisuales digitales y proporcionará una base para el resto del tutorial. Navega hasta el directorio del archivo y ejecuta:</p>
<pre><code class="language-bash">ffprobe destEarth.ogv
</code></pre>
<p>Verás los metadatos técnicos básicos del archivo impresos en <code>stdout</code>:</p>
<p>{% include figure.html filename=&quot;ffprobe_ogg_es.png&quot; caption=&quot;El output de un comando básico <code>ffprobe</code> con destEarth.ogv&quot; %}</p>
<p>La línea <code>Input # 0</code> del informe identifica el <strong>contenedor</strong> como <a href="https://es.wikipedia.org/wiki/Ogg">ogg</a>. Los contenedores (también llamados &quot;envoltorios&quot; o &quot;wrappers&quot;, en inglés) proporcionan al archivo la estructura de sus diversas pistas. Los diferentes contenedores (otros más comunes incluyen <code>.mkv</code>, <code>.avi</code> y <code>.flv</code>) tienen diferentes características y compatibilidad con diversos programas. Examinaremos cómo y por qué es posible que desees cambiar el contenedor de un archivo en el siguiente comando.</p>
<p>Las líneas <code>Stream #0:0</code> y <code>Stream #0:1</code> proporcionan información sobre las pistas del archivo (es decir, el contenido que ves en la pantalla y escuchas a través de sus altavoces) y también identifican el <strong>códec</strong> de cada pista. Los códecs especifican cómo se codifica/comprime (se escribe y almacena) y se decodifica (se reproduce) la información. La pista vídeo (<code>Stream #0:0</code>) de nuestro archivo <code>.ogv</code> usa el códec <a href="https://es.wikipedia.org/wiki/Theora">theora</a> y la pista audio (<code>Stream #0:1</code>) usa el códec <a href="https://es.wikipedia.org/wiki/Vorbis">vorbis</a>. Estas líneas también proporcionan información importante relacionada con el espacio de color de la pista de vídeo (<code>yuv420p</code>), resolución (<code>400x300</code>) y marcos por segundo (<code>29.97 fps</code>). Adicionalmente, proporcionan información de audio como la tasa de muestreo (<code>44100 Hz</code>) y la tasa de bits (<code>128 kb/s</code>).</p>
<p>Los códecs, en mayor medida que los contenedores, determinan la calidad y la compatibilidad de un archivo audiovisual con diferentes programas y plataformas (otros códecs comunes incluyen <code>DNxHD</code> y<code> ProRes</code> para vídeo y <code>mp3</code> y<code> FLAC</code> para audio). Examinaremos cómo y por qué es posible que también desees cambiar el códec de un archivo en el siguiente comando.</p>
<p>Ejecuta otro comando de <code>ffprobe</code>, esta vez con el archivo <code>.m4v</code>:</p>
<pre><code class="language-bash">ffprobe destEarth.m4v
</code></pre>
<p>Una vez más, verás los metadatos técnicos básicos impresos en el <code>stdout</code>:</p>
<p>{% include figure.html filename=&quot;ffprobe_mp4_es.png&quot; caption=&quot;El output de un comando básico <code>ffprobe</code> con destEarth.m4v&quot; %}</p>
<p>También notarás que el informe para el archivo <code>.m4v</code> contiene múltiples contenedores en la línea <code>Input # 0</code> como <code>mov</code> y <code>m4a</code>. No es necesario profundizar en los detalles para los fines de este tutorial, pero ten en cuenta que los contenedores <code>mp4</code> y<code> mov</code> se presentan en múltiples &quot;sabores&quot; y diferentes extensiones de archivo. Sin embargo, todos son muy similares en su construcción técnica y, como tal, pueden verse agrupados en metadatos técnicos. De manera similar, el archivo <code>ogg</code> tiene la extensión<code> .ogv</code>, un &quot;sabor&quot; o variante del formato <code>ogg</code>.</p>
<p>Al igual que en nuestro comando anterior, las líneas <code>Stream # 0: 0</code> y<code> Stream # 0: 1</code> identifican el códec de cada pista. Podemos ver que nuestro archivo <code>.m4v</code> usa el códec vídeo <a href="https://es.wikipedia.org/wiki/H.264/MPEG-4_AVC">H.264</a> y el códec audio <a href="https://es.wikipedia.org/wiki/Advanced_Audio_Coding">aac</a>. Ten en cuenta que se nos proporcionan metadatos similares a nuestro archivo <code>.ogv</code>, pero algunas características importantes relacionadas con el análisis visual (como la resolución) son significativamente diferentes. Nuestro <code>.m4v</code> tiene una resolución más alta (<code>640x480</code>) y, por lo tanto, utilizaremos esta versión de <em>Destination Earth</em> como nuestro vídeo de origen.</p>
<p>Ahora que sabemos más sobre la composición técnica de nuestro archivo, podemos comenzar a explorar las características y funcionalidades transformadoras de FFmpeg (volveremos a utilizar <code>ffprobe</code> más adelante en el tutorial para realizar una extracción de metadatos de color más avanzada).</p>
<h2>Cambiar el contenedor (volver a envolver, &quot;re-wrap&quot;)</h2>
<p>Dependiendo de tu sistema operativo, puedes tener uno o más reproductores de medios instalados. Para efectos de demostración veamos qué sucede si intentas abrir <code>destEarth.ogv</code> usando el reproductor de medios QuickTime que viene con Mac OSX:</p>
<p>{% include figure.html filename=&quot;QT_fail.png&quot; caption=&quot;Los reproductores multimedia patentados como Quicktime a menudo están limitados en los tipos de archivos con los que pueden trabajar&quot; %}</p>
<p>Una opción cuando te enfrentas a un mensaje de este tipo es simplemente usar otro reproductor de medios. <a href="https://www.videolan.org/vlc/index.es.html">VLC</a>, que está construido con FFmpeg, es una excelente alternativa de código abierto, pero simplemente &quot;usar otro programa&quot; puede no ser siempre una solución viable (y es posible que no siempre tengas otra versión de archivo con la que trabajar). Muchos editores de vídeo populares, como Adobe Premiere, Final Cut Pro y DaVinci Resolve, tienen sus propias limitaciones en cuanto a los tipos de formatos con los que son compatibles. Además, las diferentes plataformas web y sitios de alojamiento/transmisión, como Vimeo, <a href="https://vimeo.com/help/compression">también tienen sus propios requisitos.</a> Por lo tanto, es importante poder volver a envolver y transcodificar tus archivos para cumplir con las diversas especificaciones para la reproducción, edición, publicación digital y ajuste de archivos a los estándares requeridos por las plataformas de archivo o preservación digital.</p>
<div class="alert alert-warning">
Para obtener una lista completa de los códecs y contenedores compatibles con tu instalación de FFmpeg, ejecuta <code>ffmpeg -codecs</code> y <code>ffmpeg -formats</code>, respectivamente, para ver la lista impresa de tu <code>stdout</code>.
</div>
<p>Como un ejercicio para aprender la sintaxis básica de FFmpeg y aprender a transcodificar entre formatos, comenzaremos con nuestro archivo <code>destEarth.ogv</code> y escribiremos un nuevo archivo con vídeo codificado en<code> H.264</code>, audio en <code>AAC</code> y envuelto en un contenedor <code>.mp4</code>, una combinación muy común y altamente portátil de códecs y contenedores que es prácticamente idéntico al archivo<code> .m4v</code> que originalmente descargamos. Aquí está el comando que ejecutarás, junto con una explicación de cada parte de la sintaxis:</p>
<pre><code class="language-bash">ffmpeg -i destEarth.ogv -c:v libx264 -c:a aac destEarth_transcoded.mp4
</code></pre>
<ul>
<li><code>ffmpeg</code> = comienza el comando</li>
<li><code>-i destEarth.ogv</code> = especifica el archivo de entrada</li>
<li><code>-c:v libx264</code> = transcodifica la pista de vídeo al codec H.264</li>
<li><code>-c:a aac</code> = transcodifica la pista de audio al codec AAC</li>
<li><code>destEarth_transcoded.mp4</code> = especifica el archivo de salida. Ten en cuenta que aquí es donde se especifica el nuevo tipo de contenedor.</li>
</ul>
<p>Si ejecutas como está escrito y en el mismo directorio que <code>destEarth.ogv</code>, verás un nuevo archivo llamado<code> destEarth_transcoded.mp4</code>, que aparecerá en el directorio. Si estás operando en Mac OSX, también podrás reproducir este nuevo archivo con QuickTime. Una exploración completa de los convenios de códecs, contenedores, compatibilidad y extensión de archivos está más allá del alcance de este tutorial; sin embargo, este conjunto de ejemplos preliminares debería darles a aquellos que no estén familiarizados con la forma en que se construyen los archivos audiovisuales digitales un conjunto de conocimientos de referencia que les permitirá completar el resto del tutorial.</p>
<h2>Creación de extractos y &quot;demuxing&quot; de audio y vídeo</h2>
<p>Ahora que tenemos un mejor entendimiento de las pistas, códecs, y contenedores, veamos formas en que FFmpeg puede trabajar con materiales de vídeo a un nivel más granular. Para este tutorial, examinaremos dos secciones separadas de <em>Destination Earth</em> para comparar cómo se usa el color en relación con la retórica propagandística de la película. Crearemos y prepararemos estos extractos para el análisis utilizando un comando que realiza dos funciones diferentes simultáneamente:</p>
<ul>
<li>Primero, el comando creará dos extractos de <code>destEarth.m4v</code>.</li>
<li>Segundo, el comando eliminará (&quot;demux&quot;) los componentes de audio (<code>Stream # 0: 1</code>) de estos extractos.<div class="alert alert-warning">
Estamos eliminando el audio para ahorrar espacio de almacenamiento (la información de audio no es necesaria para el análisis de color). Esto probablemente será útil si esperas utilizar este tipo de análisis a escalas más grandes. Cerca del final del tutorial, se discutirá más información sobre la ampliación del análisis de color.
</div>
</li>
</ul>
<p>El primer extracto que haremos contiene una secuencia correspondiente al comienzo de la película que describe las difíciles condiciones y la vida oprimida de la sociedad marciana. El siguiente comando especifica los puntos de inicio y finalización del extracto, le dice a FFmpeg que retenga toda la información en la pista de vídeo sin transcodificar nada y le indica que escriba nuestro nuevo archivo sin la pista de audio:</p>
<pre><code class="language-bash">ffmpeg -i destEarth.m4v -ss 00:01:00 -to 00:04:35 -c:v copy -an destEarth_Mars_video.mp4
</code></pre>
<ul>
<li><code>ffmpeg</code> = comienza el comando</li>
<li><code>-i destEarth.m4v</code> = especifica el archivo de entrada</li>
<li><code>-ss 00:01:00</code> = establece el punto de inicio a 1 minuto del inicio del archivo</li>
<li><code>-to 00:04:45</code> = establece el punto final a 4 minutos y 45 segundos desde el inicio del archivo</li>
<li><code>-c:v copy</code> = copia la pista de vídeo directamente, sin transcodificar</li>
<li><code>-an</code> = le dice a FFmpeg que ignore la pista de audio al escribir el archivo de salida.</li>
<li><code>destEarth_Mars_video.mp4</code> = especifica el archivo de salida</li>
</ul>
<p>{% include figure.html filename=&quot;Mars_screenshot.png&quot; caption=&quot;Vida en Marte&quot; %}</p>
<p>Ahora, ejecutaremos un comando similar para crear un extracto de &quot;Tierra&quot;. Esta parte de la película tiene una secuencia similar que describe las maravillas de la vida en la Tierra y la riqueza de su sociedad gracias al capitalismo de libre empresa y al uso de petróleo y productos derivados de este:</p>
<pre><code class="language-bash">ffmpeg -i destEarth.m4v -ss 00:07:30 -to 00:11:05 -c:v copy -an destEarth_Earth_video.mp4
</code></pre>
<p>{% include figure.html filename=&quot;Earth_screenshot.png&quot; caption=&quot;La abundancia de la Tierra&quot; %}</p>
<p>Ahora deberías tener dos archivos nuevos en tu directorio llamados <code>destEarth_Mars_video.mp4</code> y<code> destEarth_Earth_video.mp4</code>. Puedes probar uno o ambos archivos (o cualquiera de los otros archivos en el directorio) usando la función <code>ffplay</code> de FFmpeg. Simplemente ejecuta:</p>
<pre><code class="language-bash">ffplay destEarth_Mars_video.mp4
</code></pre>
<p>y/o</p>
<pre><code class="language-bash">ffplay destEarth_Earth_video.mp4
</code></pre>
<p>Verás una ventana abierta y el vídeo comenzará en el punto de iniicio especificado. Se reproducirá una vez y luego la ventana se cerrará (además, notarás que no hay sonido en tu vídeo). También notarás que los comandos <code>ffplay</code> no requieren que se especifique una entrada (<code>-i</code>) o una salida porque la reproducción en sí misma es la salida.</p>
<div class="alert alert-warning">
<code>FFplay</code> es un reproductor multimedia muy versátil que viene con una serie de <a href="https://ffmpeg.org/ffplay.html#Options">opciones</a> para personalizar la reproducción. Por ejemplo, si agregas `-loop 0` al comando se reproducirá en bucle indefinidamente.</div>
<p>Ahora hemos creado nuestros dos extractos para el análisis. Si vemos estos clips por separado, parece haber diferencias significativas en la forma en que se utilizan el color y la variedad de colores. En la siguiente parte del tutorial examinaremos y extraeremos datos de los archivos de vídeo para cuantificar y apoyar esta hipótesis.</p>
<h2>Análisis de datos de color</h2>
<p>El uso de herramientas digitales para analizar la información de color en películas es otra faceta emergente de las Humanidades Digitales que se superpone con los estudios cinematográficos tradicionales. En particular, el proyecto <a href="https://filmcolors.org/">FilmColors</a> de la Universidad de Zurich cuestiona la intersección crítica de las &quot;características estéticas formales de los aspectos semánticos, históricos y tecnológicos&quot; de su producción, recepción y difusión a través del uso de herramientas de análisis y anotación digital (Flueckiger, 2017, traducido por el autor). Aunque no hay un método estandarizado para este tipo de investigación, en el momento de escribir esta lección el comando <code>ffprobe</code> que se describe a continuación es una una herramienta útil para extraer información de color que se puede usar en el análisis computacional. Primero, veamos otra manera estandarizada de representar la información de color que informa este enfoque cuantitativo, basado en datos, para el análisis de color: los vectorscopios.</p>
<h3>Vectorscopios</h3>
<p>Durante años, profesionales del vídeo han confiado en los <a href="https://es.wikipedia.org/wiki/Vectorscopio">vectorscopios</a> para ver la información del color de una manera estandarizada y fácilmente legible. Un vectorscopio grafica información de color en una gratícula circular. La posición del gráfico corresponde a los <a href="https://es.wikipedia.org/wiki/Tono_(color)">tonos</a> particulares encontrados en una señal de vídeo. Otros factores, como la saturación, determinan también el tamaño de un gráfico. A continuación se presenta un ejemplo de un vectorscopio que muestra los valores de color de las barras SMPTE.</p>
<p>{% include figure.html filename=&quot;vectorscope.png&quot; caption=&quot;Una lectura de vectorescopio que representa las barras SMPTE NTSC estándar. Fuente: Wikimedia Commons&quot; %}</p>
<p>{% include figure.html filename=&quot;smpte_bars.png&quot; caption=&quot;Las barras SMPTE. Fuente: Wikimedia Commons&quot; %}</p>
<p>FFmpeg se puede utilizar para reproducir y crear archivos de vídeo con vectorscopios integrados en ellos para proporcionar una referencia en tiempo real para la información de color del vídeo. Los siguientes comandos <code>ffplay</code> incorporarán un vectorscopio en la esquina inferior derecha del marco. A medida que se reproduce el vídeo, notarás el cambio en el gráfico del vectorscopio a medida que cambia el color en pantalla:</p>
<pre><code class="language-bash">ffplay destEarth_Mars_video.mp4 -vf &quot;split=2[m][v], [v]vectorscope=b=0.7:m=color3:g=green[v],[m][v]overlay=x=W-w:y=H-h&quot;
</code></pre>
<ul>
<li><code>ffplay</code> = comienza el comando</li>
<li><code>-i entrada_archivo.ext</code> = la ruta y el nombre del archivo de entrada</li>
<li><code>-vf</code> = crea un <a href="https://trac.ffmpeg.org/wiki/FilteringGuide"><em>filter-graph</em></a> para usar con las pistas</li>
<li><code>&quot;</code> = una comilla para comenzar el <em>filter-graph.</em> La información entre las comillas
especifica los parámetros de la apariencia y posición del vectorscopio</li>
<li><code>split=2[m][v]</code> = divide la entrada en dos salidas idénticas llamadas <code>[m]</code> y <code>[v]</code></li>
<li><code>,</code> = la coma indica que viene otro parámetro</li>
<li><code>[v]vectorscope=b=0.7:m=color3:g=green[v]</code> = asigna la salida <code>[v]</code> al filtro del vectorscopio</li>
<li><code>[m][v]overlay=x=W-w:y=H-h</code> = superpone el vectorscopio encima de la imagen de vídeo en una cierta ubicación (en este caso, en la esquina inferior derecha de la pantalla)</li>
<li><code>&quot;</code> = termina el <em>filter-graph</em></li>
</ul>
<div class="alert alert-warning">
Para obtener más información sobre las diversas opciones para crear vectorscopios, consulta <a href="https://ffmpeg.org/ffmpeg-filters.html#vectorscope"> la documentación oficial</a> y <a href="https://trac.ffmpeg.org/wiki/Vectorscope">la página Wiki FFmpeg Vectorscope</a>. Además, puedes encontrar más información sobre cómo colocar las superposiciones en <a href="https://ffmpeg.org/ffmpeg-filters.html#overlay-1">la documentación del filtro de superposición FFmpeg</a>.
</div>
<p>{% include figure.html filename=&quot;Mars_screenshot_vector.png&quot; caption=&quot;Captura de pantalla de la ventana de FFplay con vectorscopio incorporado&quot; %}</p>
<p>Y para el extracto de &quot;Tierra&quot;:</p>
<pre><code class="language-bash">ffplay destEarth_Earth_video.mp4 -vf &quot;split=2[m][v], [v]vectorscope=b=0.7:m=color3:g=green[v],[m][v]overlay=x=W-w:y=H-h&quot;
</code></pre>
<p>{% include figure.html filename=&quot;Earth_screenshot_vector.png&quot; caption=&quot;Captura de pantalla de la ventana de FFplay con vectorscopio incorporado&quot; %}</p>
<p>También podemos ajustar este comando para escribir nuevos archivos de vídeo con vectorscopios:</p>
<pre><code class="language-bash">ffmpeg -i destEarth_Mars_video.mp4 -vf &quot;split=2[m][v], [v]vectorscope=b=0.7:m=color3:g=green[v],[m][v]overlay=x=W-w:y=H-h&quot; -c:v libx264 destEarth_Mars_vectorscope.mp4
</code></pre>
<pre><code class="language-bash">ffmpeg -i destEarth_Earth_video.mp4 -vf &quot;split=2[m][v], [v]vectorscope=b=0.7:m=color3:g=green[v],[m][v]overlay=x=W-w:y=H-h&quot; -c:v libx264 destEarth_Earth_vectorscope.mp4
</code></pre>
<p>Nota los pequeños pero importantes cambios en sintaxis:</p>
<ul>
<li>Hemos agregado una bandera de <code>-i</code> porque es un comando de <code>ffmpeg</code></li>
<li>Hemos especificado el códec del vídeo del archivo de salida como <a href="https://es.wikipedia.org/wiki/H.264/MPEG-4_AVC">H.264</a> con la bandera <code>-c:v libx264</code> y no estamos recodificando el códec de audio (<code>-c:a copy</code>), aunque puedes especificar otro códec de audio si lo necesitas.</li>
<li>Hemos definido el nombre del archivo de salida</li>
</ul>
<p>Tómate unos minutos para ver estos vídeos con los vectorscopios integrados en ellos. Observa cuán dinámicos (o no) son los cambios entre los extractos de &quot;Marte&quot; y &quot;Tierra&quot;. Compara lo que ves en el vectorscopio con tus propias impresiones del vídeo mismo. Podríamos usar las observaciones de estos vectorscopios para hacer determinaciones sobre qué tonos de color aparecen de manera más regular o intensa en el vídeo, o podemos comparar diferentes formatos uno al lado del otro para ver cómo el color se codifica o representa de manera diferente en función de diferentes códecs, resoluciones, etc.</p>
<p>Aunque los vectorscopios proporcionan una representación útil y en tiempo real de la información del color, es posible que también deseemos acceder a los datos sin procesar que se encuentran debajo de ellos. Luego, podemos usar estos datos para desarrollar visualizaciones más flexibles que no dependan de ver el archivo de vídeo simultáneamente y que ofrezcan un enfoque más cuantitativo para el análisis de color. En nuestros próximos comandos, utilizaremos <code>ffprobe</code> para producir un conjunto tabular de datos que pueda usarse para crear un gráfico de datos de color.</p>
<h3>Extracción de datos de color con FFprobe</h3>
<p>Al comienzo de este tutorial, utilizamos un comando <code>ffprobe</code> para ver los metadatos básicos de nuestro archivo impresos en el <code>stdout</code>. En los siguientes ejemplos, utilizaremos <code>ffprobe</code> para extraer datos de color de nuestros extractos de vídeo y enviar esta información a archivos<code> .csv</code>. Dentro de nuestro comando <code>ffprobe</code>, vamos a utilizar el filtro<code> signalstats</code> para crear reportes <code>.csv</code> de información de tono de color medio para cada marco en la secuencia de vídeo de<code> destEarth_Mars_video.mp4</code> y <code>destEarth_Earth_video.mp4</code>, respectivamente.</p>
<pre><code class="language-bash">ffprobe -f lavfi -i movie=destEarth_Mars_video.mp4,signalstats -show_entries frame=pkt_pts_time:frame_tags=lavfi.signalstats.HUEMED -print_format csv &gt; destEarth_Mars_hue.csv
</code></pre>
<ul>
<li><code>ffprobe</code> = comienza el comando</li>
<li><code>-f lavfi</code> = especifica el dispositivo de entrada virtual <a href="https://ffmpeg.org/ffmpeg-devices.html#lavfi">libavfilter</a> como el formato elegido. Esto es necesario cuando se usa <code>signalstats</code> y muchos filtros en comandos FFmpeg más complejos.</li>
<li><code>-i movie=destEarth_Mars_video.mp4</code> = nombre del archivo de entrada</li>
<li><code>,signalstats</code> = especifica el uso del filtro <code>signalstats</code> con el archivo de entrada</li>
<li><code>-show_entries</code> = establece una lista de entradas que se mostrarán en el informe. Estos se especifican en las siguientes opciones.</li>
<li><code>frame=pkt_pts_time</code> = especifica mostrar cada marco con tu correspondiente <code>pkt_pts_time</code>, creando una entrada única para cada marco de vídeo</li>
<li><code>:frame_tags=lavfi.signalstats.HUEMED</code> = crea una etiqueta para cada marco que contiene el valor de tono medio</li>
<li><code>-print_format csv</code> = especifica el formato del informe de metadatos</li>
<li><code>&gt; destEarth_Mars_hue.csv</code> = escribe un nuevo archivo <code>.csv</code> que contiene el informe de metadatos usando<code>&gt; </code>, un <a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html">operador de redireccionamiento de Bash</a>. Este operador toma el comando que lo precede y &quot;redirige&quot; la salida a otra ubicación. En este caso, está escribiendo la salida en un nuevo archivo <code>.csv</code>. La extensión de archivo proporcionada aquí también debe coincidir con el formato especificado por el indicador <code>print_format</code>.</li>
</ul>
<p>A continuación, ejecuta el mismo comando para el extracto de &quot;Tierra&quot;:</p>
<pre><code class="language-bash">ffprobe -f lavfi -i movie=destEarth_Earth_video.mp4,signalstats -show_entries frame=pkt_pts_time:frame_tags=lavfi.signalstats.HUEMED -print_format csv &gt; destEarth_Earth_hue.csv
</code></pre>
<div class="alert alert-warning">
Para obtener más información sobre el filtro de <code>signalstats</code> y las diversas métricas que se pueden extraer de las transmisiones de vídeo, consulta <a href="https://ffmpeg.org/ffmpeg-filters.html#signalstats-1">la documentación del filtro FFmpeg</a>.
</div>
<p>Ahora deberías tener dos archivos <code>.csv</code> en tu directorio. Si los abres en un editor de texto o en un programa de hoja de cálculo, verás tres columnas de datos:</p>
<p>{% include figure.html filename=&quot;csv_head.png&quot; caption=&quot;Las primeras filas de nuestro informe de color en formato .csv&quot; %}</p>
<p>Comenzando a la izquierda y moviéndose a la derecha, las dos primeras columnas nos dan información sobre dónde estamos en el vídeo. Los números decimales representan fracciones de segundo que también corresponden aproximadamente a la base de tiempo de vídeo de 30 marcos por segundo. Cada fila en nuestro <code>.csv</code> corresponde a un marco de vídeo. La tercera columna lleva un número entero entre 0-360, valor que representa el tono medio para ese marco de vídeo. Estos números son los datos cuantitativos subyacentes del diagrama de vectorscopio y corresponden a su posición (en radianes) en la gratícula circular. Haciendo referencia a nuestra imagen de vectorescopio de antes, puedes ver que comenzando en la parte inferior del círculo (0 grados) y moviéndose a la izquierda, los &quot;verdes&quot; comienzan alrededor de los 38 grados, los &quot;amarillos&quot; en los 99 grados, los &quot;rojos&quot; en los 161 grados, los &quot;magentas&quot; en los 218 grados, los &quot;azules&quot; en los 279 grados y los &quot;cianes&quot; en los 341 grados. Una vez que comprendas estos &quot;rangos&quot; de tono, puedes hacerte una idea de cuál es el valor de tono medio para un marco de vídeo con solo mirar este valor numérico.</p>
<p>Además, ten en cuenta que este valor extraído por el filtro <code>signalstats</code> no es una medida absoluta o completa de las cualidades de color de una imagen, sino simplemente un punto de referencia significativo desde el cual podemos explorar una estrategia basada en datos para el análisis de color. La percepción del color y la teoría del color son <a href="https://colourturn.net/">áreas complejas y en evolución de la investigación académica</a> que incorporan muchas estrategias diferentes de las humanidades, las ciencias sociales y las ciencias cognitivas. Es por eso que debemos tener en cuenta que cualquier estrategia analítica debe tomarse dentro del contexto de estos discursos más amplios y con un espíritu colaborativo y generativo.</p>
<h3>Visualizando datos de color</h3>
<p>Los dos archivos <code>.csv</code> que creamos con los comandos anteriores ahora se pueden usar para crear gráficos que visualicen los datos. Hay una serie de plataformas (tanto propietarias como de código abierto) que se pueden usar para lograr esto, como <a href="https://www.wikihow.com/Create-a-Graph-in-Excel">Microsoft Excel</a>, <a href="https://rawgraphs.io/">RawGraphs</a> y/o <a href="https://plotly.com/graphing-libraries/">plotly</a>. Una discusión en profundidad sobre cómo usar cualquiera de estas plataformas está fuera del alcance de este tutorial; sin embargo, a continuación se muestra la visualización final de los comandos anteriores, que se creó con los archivos <code>.csv</code> y plotly.</p>
<p>{% include figure.html filename=&quot;Final_Graph_plotly.png&quot; caption=&quot;Gráfico que incluye datos de tono medio de ambos extractos de vídeo&quot; %}</p>
<h3>Conclusiones</h3>
<p>Al observar el gráfico, podemos ver que las trazas de Marte y la Tierra tienen rangos dinámicos muy diferentes en sus valores de tono medio. La traza de Marte es muy limitada y se mantiene dentro de los rangos rojo y amarillo (aproximadamente entre 100 y 160) en la mayoría del extracto. Esto sugiere algo sobre el uso del color en la película como un dispositivo retórico que sirve como mensaje propagandístico. Recuerda que esta sección presenta una visión antipática de la forma de vida y el sistema político marcianos: una población uniforme e infeliz, que depende de tecnología y transporte ineficientes mientras se les exige que observen la obediencia total a un gobernante supremo totalitario. La película conecta esta experiencia negativa con una paleta de tonos relativamente opacos de rojo y amarillo. También deberíamos considerar el público objetivo original de esta película, los jóvenes ciudadanos de los Estados Unidos en la década de 1950, y cómo probablemente habrían interpretado estas imágenes y usos del color en ese momento histórico. En particular, podemos considerar este uso del color en el contexto de las crecientes tensiones geopolíticas entre la Unión Soviética y los Estados Unidos y sus aliados en Europa occidental. El color rojo, específicamente, se usaba comúnmente en los medios impresos y de difusión para describir <a href="https://es.wikipedia.org/wiki/Temor_rojo">la &quot;amenaza&quot; del comunismo global</a> durante esta era de la historia mundial. Además, la elección de presentar al líder totalitario marciano con una apariencia muy similar al icónico líder soviético <a href="https://es.wikipedia.org/wiki/I%C3%B3sif_Stalin">Joseph Stalin</a> puede leerse como una señal visual y cultural explícita para la audiencia. Así, esta representación de Marte parece ser una caricatura alegórica de la vida bajo el velo del comunismo, tal como la percibe un observador externo y un oponente político/ideológico. Esta caricatura emplea no solo una paleta de colores limitada, sino una que está cargada con otras referencias culturales. El uso del color aprovecha los prejuicios y asociaciones que están presentes en el imaginario de la audiencia y, por lo tanto, está ligado estrechamente al argumento central de la película, que sostiene que el comunismo no es un sistema político viable.</p>
<p>En contraste con el uso limitado del color en nuestro extracto de Marte, la traza de la Tierra cubre un rango dinámico mucho más amplio de valores de tono. En este pasaje, el emisario marciano está aprendiendo sobre el maravilloso y rico estilo de vida de los terrícolas gracias a un sistema capitalista y a la explotación de petroleo y de productos derivados de este. La secuencia enfatiza la riqueza material y la libertad empresarial ofrecida bajo un sistema capitalista usando una variedad y vivacidad de color mucho mayor que en el extracto de Marte. Los productos comerciales y las personas se representan utilizando el espectro completo del proceso Technicolor, creando asociaciones positivas entre los resultados de la industria petrolera y el estilo de vida acomodado de quienes se benefician de él. Al igual que el extracto de Marte, a la audiencia se le ofrece una caricatura unilateral de un sistema político y una forma de vida, pero en esta sección la representación reduccionista es laudable y próspera en lugar de desoladora y opresiva.</p>
<p>Como una pieza de propaganda, <em>Destination Earth</em> se basa en estas distinciones poderosas pero demasiado simplistas entre dos sistemas políticos para influir en la opinión pública y promover el consumo de productos derivados del petróleo. La manera en que se usa (o no se usa) el color es una herramienta importante para elaborar y enfatizar este mensaje. Además, una vez que podemos extraer datos de color y visualizarlos utiliza técnicas gráficas simples, podemos ver que la disparidad en el rango dinámico proporciona una medida cuantitativa para vincular el uso técnico y estético del color en esta película animada con la retórica propagandística presentada por sus productores.</p>
<p>{% include figure.html filename=&quot;lovely_oil.png&quot; caption=&quot;El petróleo y los ideales estadounidenses de riqueza y prosperidad se expresan en esplendor colorido&quot; %}</p>
<h3>Escalando el análisis de color con FFprobe</h3>
<p>Uno de los límites de esta metodología es que estamos generando manualmente informes de color en un solo archivo a la vez. Si quisiéramos adoptar un enfoque de <a href="https://distantviewing.org/background">visión distante</a> más en línea con las metodologías tradicionales de Humanidades Digitales, podríamos emplear un script de Bash para ejecutar nuestro comando <code>ffprobe</code> en todos los archivos en un determinado directorio. Esto es útil si, por ejemplo, un(a) investigador(a) esta interesado en realizar un análisis similar en <a href="https://archive.org/details/prelinger&amp;tab=collection?and%5B%5D=john+sutherland&amp;sin=">todas las películas animadas de John Sutherland encontradas en la colección de Archivos Prelinger</a> u otro conjunto de material de vídeo de archivo.</p>
<p>Una vez que tengas un conjunto de material para trabajar guardado en un solo lugar, puedes guardar el siguiente <a href="https://www.shellscript.sh/loops.html">bucle <em>for</em> de Bash o &quot;for loop&quot;</a> dentro del directorio y ejecutarlo para generar archivos <code>.csv</code> que contengan los mismos datos de tono medio a nivel de fotograma que extrajimos de nuestros extractos de <em>Destination Earth</em>.</p>
<pre><code class="language-bash">for file in *.m4v; do
ffprobe -f lavfi -i movie=&quot;$file&quot;,signalstats -show_entries frame=pkt_pts_time:frame_tags=lavfi.signalstats.HUEMED -print_format csv &gt; &quot;${file%.m4v}.csv&quot;;
done
</code></pre>
<ul>
<li><code>for file in *.m4v; do</code> = inicia el bucle <em>for</em>. Esta primera línea le dice a FFmpeg &quot;para todos los archivos en este directorio con la extensión <code>.m4v</code>, ejecuta el siguiente comando.&quot;</li>
<li>El <code>*</code> es un <a href="http://tldp.org/LDP/GNU-Linux-Tools-Summary/html/x11655.htm">comodín de Bash</a> adjunto a un tipo de archivo dado para especificarlos como archivos de entrada.</li>
<li>La palabra <code>file</code> es una variable arbitraria que representará cada archivo a medida que se ejecuta a través del bucle.</li>
<li><code>ffprobe -f lavfi -i movie=&quot;$file&quot;,signalstats -show_entries frame=pkt_pts_time:frame_tags=lavfi.signalstats.HUEMED -print_format csv &gt; &quot;${file%.m4v}.csv&quot;; done</code> = el mismo comando de extracción de metadatos de color que ejecutamos en nuestros dos extractos de <em>Destination Earth</em>, con algunas pequeñas modificaciones en la sintaxis para explicar su uso en varios archivos en un directorio:
<ul>
<li><code>&quot;$file&quot;</code> = recuerda cada variable. Las comillas aseguran que se conserva el nombre de archivo original.</li>
<li><code>&gt; &quot;${file%.m4v}.csv&quot;;</code> = conserva el nombre de archivo original al escribir los archivos de salida <code>.csv</code>. Esto asegurará que los nombres de los archivos de vídeo originales coincidan con sus correspondientes reportes en <code>.csv</code>.</li>
<li><code>done</code> = termina el script una vez que se hayan completado todos los archivos del directorio.</li>
</ul>
</li>
</ul>
<div class="alert alert-warning">
También puedes usar <code>signalstats</code> para obtener otra información valiosa relacionada con el color. Consulta la <a href="https://www.ffmpeg.org/ffprobe-all.html#signalstats-1">documentación del filtro</a> para obtener una lista completa de las métricas visuales disponibles.
</div>
<p>Una vez que ejecutas este script, verás que cada archivo de vídeo en el directorio ahora tiene un archivo <code>.csv</code> correspondiente que contiene el conjunto de datos especificado.</p>
<h1>En resumen</h1>
<p>En este tutorial, hemos aprendido:</p>
<ul>
<li>cómo instalar FFmpeg en diferentes sistemas operativos y cómo acceder al <em>framework</em> en el navegador web</li>
<li>cuál es la sintaxis básica y la estructura de los comandos FFmpeg</li>
<li>cómo visualizar metadatos técnicos básicos de un archivo audiovisual</li>
<li>cómo transformar un archivo audiovisual a través de la transcodificación y el &quot;re-wrapping&quot;</li>
<li>cómo analizar y editar ese archivo audiovisual separando sus componentes (&quot;demux&quot;) y crear extractos</li>
<li>cómo reproducir archivos audiovisuales usando <code>ffplay</code></li>
<li>cómo crear nuevos archivos de vídeo con vectorscopios integrados</li>
<li>cómo exportar datos tabulares relacionados con el color de una pista de vídeo usando <code>ffprobe</code></li>
<li>cómo crear un bucle <em>for</em> de Bash para extraer información de datos de color de múltiples archivos de vídeo con un solo comando</li>
</ul>
<p>A un nivel más amplio, este tutorial aspira a proporcionar una introducción informada y atractiva sobre cómo se pueden incorporar las herramientas y metodologías audiovisuales en los proyectos y las prácticas de Humanidades Digitales. Con herramientas abiertas y potentes como FFmpeg, existe un gran potencial para expandir el alcance del campo para incluir tipos de medios y análisis más ricos y complejos que nunca.</p>
<h1>Más recursos</h1>
<p>FFmpeg tiene una comunidad grande y bien apoyada de usarios a través de todo el mundo. Como tal, hay muchos recursos gratuitos y de código abierto para descubir nuevos comandos y técnicas para trabajar con materiales audiovisuales. Por favor, contacta al autor con cualquier adición a esta lista, especialmente si se trata de recursos educativos en español para aprender FFmpeg.</p>
<ul>
<li><a href="https://www.ffmpeg.org/ffmpeg.html">La documentación oficial de FFmpeg</a></li>
<li><a href="https://trac.ffmpeg.org/wiki/WikiStart">FFmpeg Wiki</a></li>
<li><a href="https://amiaopensource.github.io/ffmprovisr/">ffmprovisr</a> de <a href="https://amianet.org/?lang=es">La Asociación de Archivistas de Imágenes en Movimiento</a></li>
<li><a href="https://training.ashleyblewer.com/">Entrenamiento de preservación audiovisual de Ashley Blewer</a></li>
<li><a href="https://github.com/privatezero/NDSR/blob/master/Demystifying_FFmpeg_Slides.pdf">La presentación de Andrew Weaver: &quot;Demystifying FFmpeg&quot;</a></li>
<li><a href="https://docs.google.com/presentation/d/1NuusF948E6-gNTN04Lj0YHcVV9-30PTvkh_7mqyPPv4/present?ueb=true&amp;slide=id.g2974defaca_0_231">FFmpeg: Presentación de Ben Turkus</a></li>
<li><a href="https://avpres.net/FFmpeg/">FFmpeg Cookbook for Archivists de Reto Kromer</a></li>
</ul>
<h2>Programas de código abierto de análisis audiovisual que usan FFmpeg</h2>
<ul>
<li><a href="https://mediaarea.net/en/MediaInfo">MediaInfo</a></li>
<li><a href="https://bavc.org/preserve-media/preservation-tools">QC Tools</a></li>
</ul>
<h1>Referencias</h1>
<ul>
<li>
<p>Champion, E. (2017) “Digital Humanities is text heavy, visualization light, and simulation poor,” Digital Scholarship in the Humanities 32(S1), i25-i32</p>
</li>
<li>
<p>Hockey, S. (2004) “The History of Humanities Computing,” A Companion to Digital Humanities, ed. Susan Schreibman, Ray Siemens, John Unsworth. Oxford: Blackwell</p>
</li>
</ul>
<p>Este tutorial fue posible gracias al apoyo de la Academia Británica y fue escrito durante el Taller de <em>Programming Historian</em>  desarrollado en la Universidad de Los Andes en Bogotá, Colombia, entre el 31 de julio y 3 de agosto de 2018.</p>
<!-- HTML_TAG_END -->

</div>
	</body>
</html>
