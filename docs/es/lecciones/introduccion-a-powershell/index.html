<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="description" content="" />
		<link rel="icon" href="/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		

		

		<link rel="stylesheet" href="/_app/assets/start-61d1577b.css">
		<link rel="modulepreload" href="/_app/start-a80c730b.js">
		<link rel="modulepreload" href="/_app/chunks/vendor-9b9d6288.js">
		<link rel="modulepreload" href="/_app/pages/__layout.svelte-de46afb2.js">
		<link rel="modulepreload" href="/_app/pages/_lang_/__layout.svelte-e75718c6.js">
		<link rel="modulepreload" href="/_app/chunks/stores-191d1505.js">
		<link rel="modulepreload" href="/_app/pages/_lang_/_lessons_/_slug_/index.svelte-efe77d76.js">

		<script type="module">
			import { start } from "/_app/start-a80c730b.js";
			start({
				target: document.querySelector("#svelte"),
				paths: {"base":"","assets":""},
				session: {},
				route: true,
				spa: false,
				trailing_slash: "never",
				hydrate: {
					status: 200,
					error: null,
					nodes: [
						import("/_app/pages/__layout.svelte-de46afb2.js"),
						import("/_app/pages/_lang_/__layout.svelte-e75718c6.js"),
						import("/_app/pages/_lang_/_lessons_/_slug_/index.svelte-efe77d76.js")
					],
					url: new URL("sveltekit://prerender/es/lecciones/introduccion-a-powershell"),
					params: {lang:"es",lessons:"lecciones",slug:"introduccion-a-powershell"}
				}
			});
		</script><script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('/service-worker.js');
			}
		</script>
	</head>
	<body>
		<div id="svelte">


The Programming Historian <a href="/en">English</a> <a href="/es">Spanish</a>
<br>
This is the es edition.

<h1>Introducción a la línea de comandos de Windows con PowerShell</h1>

<!-- HTML_TAG_START --><p>{% include toc.html %}</p>
<h1 id="introducción">Introducción</h1>
<p>En este tutorial aprenderás las bases de PowerShell de Windows, la interfaz de línea de comandos estándar de computadoras con Windows. Si eres usuario de Mac o Linux deberías consultar la <a href="/es/lecciones/introduccion-a-bash">Introducción a la línea de comandos en Bash</a>. Si ya estás familiarizado con el uso de Bash, es posible que puedas comenzar con PowerShell solamente con ver la <a href="#referencia-rapida">tabla al final de esta lección</a>.</p>
<p>El tutorial está dividido en dos secciones principales. En la primera sección, &quot;<a href="#para-empezar">Para empezar</a>&quot;, aprenderás a realizar tareas básicas de escritorio como crear y abrir archivos y carpetas con PowerShell. En la segunda sección, &quot;<a href="#haciendo-m%C3%A1s">Haciendo más</a>&quot;, obtendrás un vistazo de algunas de las características que hacen que el trabajo en línea de comandos sea particularmente eficiente y aprendas lo básico para poder explorar más por tu cuenta. También te prepararás para <a href="#Utilizaci%C3%B3n-de-herramientas-de-l%C3%ADnea-de-comandos-y-ejecuci%C3%B3n-de-secuencias-de-comandos-en-Python">ejecutar <em>scripts</em> de Python desde la línea de comandos</a>.</p>
<p>Este tutorial fue escrito para PowerShell 5.0. Si estás usando una versión anterior, encontrarás algunas pequeñas diferencias de sintaxis que debes ser capaz de superar con la pequeña ayuda de un buscador.</p>
<h1 id="¿qué-es-powershell-y-por-qué-es-útil">¿Qué es PowerShell y por qué es útil?</h1>
<p>Windows PowerShell es una <strong>interfaz de línea de comandos</strong> para computadoras Windows. Una interfaz de línea de comandos (CLI, por sus siglas en inglés) es un programa que te permite hacer que tu computadora ejecute tareas utilizando órdenes escritas en vez de hacer clic sobre las imágenes en el escritorio como en una <strong>interfaz gráfica de usuario</strong> (GUI, por sus siglas en inglés). Técnicamente, PowerShell es más que sólo una CLI; puedes obtener una visión general de sus características en <a href="https://es.wikipedia.org/wiki/Windows_PowerShell">Wikipedia</a>. El uso de la línea de comandos tiene muchas ventajas. Hace posible automatizar tareas y hacer muchas cosas con una orden. Lo que es más importante, una serie de herramientas de valor para los humanistas sólo se pueden ejecutar desde la línea de comandos, incluyendo muchas de las que puedes aprender en <em>The Historian</em> en español, como <a href="/en/lessons/topic-modeling-and-mallet">Mallet</a> (en inglés), <a href="/es/lecciones/escritura-sostenible-usando-pandoc-y-markdown">Pandoc</a>, o <a href="/en/lessons/automated-downloading-with-wget">Wget</a> (en inglés). La línea de comandos es también el mejor lugar para trabajar con los programas que has construido y personalizado para tu propia investigación utilizando lenguajes de programación como Python.</p>
<h1 id="para-empezar">Para empezar</h1>
<p>En primer lugar aprenderás a navegar a través de tus archivos y a realizar algunas tareas básicas que haces todos los días en la computadora.</p>
<h1 id="abrir-powershell">Abrir PowerShell</h1>
<p>Busca PowerShell en tu computadora. Probablemente tengas varias opciones, como &quot;PowerShell&quot;, &quot;PowerShell ISE&quot; y &quot;PowerShell (x86)&quot;. El ISE (entorno integrado de secuencias de órdenes -<em>integrated scripting environment</em>) es una herramienta útil que te permite escribir <em>scripts</em> al vuelo y también cuenta con una búsqueda de todos los comandos de PowerShell. En este momento es más de lo que necesitamos. El &quot;X86&quot; es compatible con versiones anteriores del sistema operativo (si has estado en el mundo de las computadoras por algún tiempo, recordarás los viejos procesadores de Intel de los años 80 y 90 llamados &quot;286&quot;, 2386&quot;, &quot;486&quot;, y así sucesivamente. Eso es lo que permite el &quot;X86&quot;, pues es una versión de 32 bits). Pero queremos 64-bits y lo más simple, así que vamos a utilizar el llamado solamente &quot;Windows PowerShell&quot;. Posiblemente quieras agregarlo a tu barra de tareas: haz clic con el botón derecho para obtener la opción. Al abrirlo, se verá así:</p>
<p>{% include figure.html filename=&quot;intro-to-powershell1.png&quot; caption=&quot;Puesta en marcha de PowerShell&quot; %}</p>
<p>Si no quieres blanco sobre azul, haz clic con el botón derecho en la barra superior, selecciona &quot;propiedades&quot; y ve a &quot;colores&quot; para cambiar las cosas. Deberás cerrar y volver a abrir PowerShell para que se vea correctamente.</p>
<h2 id="navegación">Navegación</h2>
<p>Algo bueno de PowerShell es que siempre sabrás dónde estás porque te lo dice en el prompt. En mi caso, yo veo:</p>
<p><code>C:\Users\Ted&gt;</code></p>
<p>Debes ver algo similar pero con tu nombre de usuario. En caso de que no sea así, escribe:</p>
<p><code>sl ~</code></p>
<p>Asegúrate de incluir el espacio. Esto te llevará a tu directorio personal: <code>C:\Users\TUNOMBREDEUSUARIO</code> donde &quot;TUNOMBREDEUSUARIO&quot; se reemplaza con el nombre de tu cuenta en la máquina. &quot;Directorio&quot; es sólo otra palabra para &quot;carpeta&quot;, y PowerShell considera tu carpeta de usuario como inicio -no el escritorio. El escritorio es realmente otra carpeta dentro de tu carpeta de usuario, es decir, un subdirectorio del directorio usuario. Introducir <code>sl ~</code> es como abrir la carpeta llamada &quot;usuarios&quot; y desde ahí TUNOMBREDEUSUARIO utilizando la GUI. Comencemos aprendiendo como moverte entre los directorios y ver su contenido.</p>
<h3 id="ver-contenido-del-directorio-con-get-childitem-gci-ls">Ver contenido del directorio con <code>Get-ChildItem</code> (<code>gci</code>, <code>ls</code>)</h3>
<p>Nuestra primera orden es <code>Get-ChildItem</code>. Escríbela y oprime Enter. Verás una lista de todo lo que hay en tu directorio actual. En mi caso se verá así:</p>
<p>{% include figure.html filename=&quot;intro-to-powershell2.png&quot; caption=&quot;Listado del contenido del directorio con <code>Get-ChildItem</code>&quot; %}</p>
<p>Toma en cuenta que en realdad no escribí <code>GetChildItem</code>. Solamente <code>gci</code>. Los comandos que aprenderemos son todos de la forma &quot;Verbo-Sustantivo&quot; (<em>Verb-Noun</em>). Son llamados &quot;cmdlets&quot; (pronunciado &quot;commandlets&quot;) y se supone que su forma hace más fácil recordar lo que hacen y predecir otros <em>cmdlets</em> similares. Debido a que los <em>cmdlets</em> son bastante largos, la mayoría de ellos tienen alias más elegantes que puedes utilizar en su lugar. Primero presentaré los <em>cmdlets</em> con sus nombres, pero siempre usaré los alias estándar, porque son mucho más rápidos para trabajar. Es importante tener en cuenta que muchos <em>cmdlets</em> tienen varios alias. Por ejemplo, <code>Get-ChildItem</code>,<code> gci</code>, <code>dir</code> y<code> ls</code> hacen exactamente lo mismo. Aunque no sorprende que <code>gci</code> sea la abreviatura de<code> Get-ChildItem</code>, es posible que te preguntes de dónde provienen <code>dir</code> y<code> ls</code>.</p>
<p>PowerShell es relativamente nuevo (se lanzó por primera vez en 2006), y sus diseñadores esperaban que muchas personas que lo utilizarían ya tendrían experiencia con algunas CLI existentes (interfaces de línea de comandos), específicamente con el CLI más antiguo de Microsoft llamado Símbolo de sistema (<em>command prompt</em>) o con Linux CLIs como Bash, que ahora también es estándar en OS X. Por lo tanto, muchos <em>cmdlets</em> tienen un alias que es el comando estándar en uno de estos dos sistemas (y a menudo para ambos). En el ejemplo presente, <code>dir</code> viene de Símbolo de sistema, y<code> ls</code> proviene de Bash. Utilizaré los alias de estilo &quot;PowerShell&quot; en este tutorial, ya que hace más fácil recordar los nombres reales de <em>cmdlet</em>. Sin embargo, intentaré también mencionar otros alias comunes, particularmente aquellos familiares para los usuarios de Bash. Si trabajas con mucha gente que usa OS X o Linux, puede ser bueno conocer estos nombres. La <a href="#referencia-r%C3%A1pida">tabla en la parte inferior</a> proporciona los <em>cmdlets</em> junto con sus alias estándar de PowerShell y el equivalente de Bash más cercano.</p>
<p>Sigue adelante e intenta usar <code>gci</code>,<code> dir</code> y <code>ls</code>. Obtendrás exactamente la misma lista de cosas. La mayoría de estas cosas serán directorios. Uno de ellos debe ser tu escritorio. Vamos a entrar en ese directorio.</p>
<h3 id="navegar-entre-directorios-con-set-location--sl-cd">Navegar entre directorios con <code>Set-Location</code> (<code> sl</code>, <code>cd</code>)</h3>
<p>Para desplazarte a tu escritorio, usaremos el <em>cmdlet</em> <code>Set-Location</code>. Escribe en PowerShell:</p>
<p><code>sl desktop</code></p>
<p>Esto le indica a PowerShell que se mueva al escritorio. Observa que puedes escribir &quot;desktop&quot; usando todas las letras minúsculas, aunque cuando viste el contenido del directorio <code>TUNOMBREDEUSUARIO</code>, &quot;Desktop&quot; se escribió con una &quot;D&quot; mayúscula. PowerShell no distingue entre mayúsculas y minúsculas. Ahora que has cambiado tu ubicación, puedes usar <code>gci</code> para ver una lista de todo lo que hay en tu escritorio, es decir, todo el directorio llamado<code> Desktop</code>. Si estás tan desorganizado como yo, esta será una larga lista. Podemos volver al directorio <code>TUNOMBREDEUSUARIO</code> escribiendo:</p>
<p><code>sl ..</code></p>
<p>¡No olvides el espacio! Ahora escribe de nuevo:</p>
<p><code>sl ..</code></p>
<p>Debes estar en el directorio <code>Users</code>.</p>
<p>Ahora trata de volver al escritorio y luego de nuevo a <code>Users</code>. Debe tomarte escribir cuatro comandos: <code>sl TUNOMBREDEUSUARIO</code>, <code>sl desktop</code>, <code>sl ..</code>, <code>sl ..</code>. Pero en realidad puedes hacerlo con sólo dos. Deberías estar en <code>C:\Users&gt;</code> ahora mismo. En lugar de escribir <code>sl TUNOMBREDEUSUARIO</code> y luego <code>sl desktop</code>, puedes escribir solamente:</p>
<p><code>sl TUNOMBREDEUSUARIO\desktop</code></p>
<p>¡Y llegar al escritorio con un comando! Del mismo modo, desde el escritorio, escribiendo:</p>
<p><code>sl ..\..</code></p>
<p>Puedes volver a donde comenzaste con un comando. Si no tienes la resistencia del dedo meñique para escribir <code>\</code> todo el tiempo, también puedes escribir <code>sl ../ ..</code>. No sólo PowerShell no distingue entre mayúsculas y minúsculas, sino que tampoco le importa en qué dirección va la barra. <code>Sl ../ ..</code>, <code>SL .. \ ..</code>, <code>Set-Location .. \ ..</code> y <code>set-location ../ ..</code> todos hacen exactamente lo mismo.</p>
<h3 id="creación-de-nuevos-directorios-con-mkdir">Creación de nuevos directorios con <code>mkdir</code></h3>
<p>Estamos avanzando hacia el trabajo con archivos. Antes de comenzar, hagamos un directorio donde podamos almacenar todo lo que estamos usando para esta lección. Navega de regreso a casa escribiendo:</p>
<p><code>sl ~</code></p>
<p>Haremos un nuevo directorio dentro del directorio <code>TUNOMBREDEUSUARIO</code>. Para ello, utilizaremos el comando <code>mkdir</code>. Llama a tu directorio como quieras, pero trata de no usar espacios, ya que hacen que trabajar en línea de comandos sea más complicado de lo necesario. Voy a llamar a mi directorio &quot;diversionConPowerShell&quot;. Entonces yo escribo:</p>
<p><code>mkdir diversionConPowerShell</code></p>
<p>¿Viste cómo utilizo <a href="https://es.wikipedia.org/wiki/CamelCase">CamelCase</a> para evitar los espacios?</p>
<p>Otra forma común de hacer esto es insertando guión o guión bajo, como en <code>diversion_con_power_shell</code>. Sea cual sea el nombre de tu directorio, trata de evitar el uso de espacios. Una vez que has estado trabajando con PowerShell un poco, probablemente te encontrarás nombrando a tu nuevos archivos sin espacios por defecto. Este es un buen hábito ya que simplifica el trabajo en la línea de comandos, así como al trabajar con lenguajes de programación como Python.</p>
<p>Sin embargo, es probable que tengas un montón de archivos ya existentes con espacios en sus nombres. Para abrir estos en PowerShell, sólo tienes que utilizar comillas. Intentemos esto. Muevete a tu nuevo directorio utilizando:</p>
<p><code>sl diversionConPowerShell</code></p>
<p>(O como hayas nombrado tu directorio). Escribe:</p>
<p><code>gci</code></p>
<p>Y verás que no hay nada aquí. ¡Eso es porque no has puesto nada en él! Vamos a poner un nuevo directorio dentro con <code>mkdir</code>. Llamaremos a este directorio &quot;Directorio con un nombre largo y muchos espacios&quot;. Debido a que el nombre tiene espacios en él, tendremos que usar comillas para crearlo. Tipo</p>
<p><code>mkdir &quot;Directorio con un nombre largo y muchos espacios&quot;</code></p>
<p>Presiona Enter. Ahora escribe:</p>
<p><code>gci</code></p>
<p>Y verás tu nuevo directorio. Supongamos que queremos movernos a este directorio. Tendríamos que escribir <code>sl &quot;Directorio con un nombre largo y muchos espacios&quot;</code>. No solo tomará un tiempo escribirlo sino que, si nos equivocamos, PowerShell no podrá encontrar nuestro directorio. En su lugar, escribe simplemente:</p>
<p><code>sl d</code> y entonces oprime la tecla de tabulador.</p>
<p>Voilà! ¡PowerShell completa el nombre del directorio por nosotros, incluidas las comillas! El uso del tabulador para completar automáticamente te ahorrará mucho tiempo. Notarás que cuando PowerShell completó el nombre, también puso <code>.\</code> al principio del nombre del directorio. El punto es solo una abreviatura de directorio actual. Cuando escribes órdenes, PowerShell siempre asume que hay un <code>.\</code>al principio -en otras palabras, que te estás refiriendo a algo en el directorio actual-. Por lo tanto, no es necesario que escribas esta parte, a menos que quieras que PowerShell busque en otro lugar lo que estás pidiendo que haga, en cuyo caso puedes escribir la ruta de ese directorio. Por ejemplo: <code>C:\directorio\bla\etc</code>.</p>
<p>Practiquemos un poco más con directorios antes de comenzar con archivos.</p>
<h3 id="uso-de-explorerpara-ver-directorios-en-la-gui">Uso de <code>Explorer</code>para ver directorios en la GUI</h3>
<p>Hasta ahora hemos hecho dos directorios. He mencionado anteriormente que &quot;directorio&quot; es solo otra palabra para &quot;carpeta&quot;. Puedes verlo al mirar tus nuevos directorios en la GUI. Windows llama a su GUI &quot;Explorador de archivos&quot; o simplemente &quot;Explorador&quot;. Podemos llamar al Explorador desde PowerShell utilizando el comando &quot;Explorer&quot;. Vuelve a la carpeta diversionConPowerShell con:</p>
<p><code>sl ..</code></p>
<p>Ahora escribe:</p>
<p><code>explorer .</code></p>
<p>Recuerda que el punto solamente significa &quot;este directorio&quot;, y no tienes que escribir con mayúscula &quot;explorer&quot; porque las mayúsculas no importan en PowerShell. Explorador debería haber abierto una ventana que muestra el contenido del directorio &quot;diversiónConPowerShell&quot;. Organiza tus ventanas para que puedas ver tanto la imagen en Explorador como en PowerShell. Ahora podrás ver que lo que haces en PowerShell aparece en Explorador. El comando &quot;Explorer&quot; es extremadamente útil. Básicamente, es como hacer doble clic en la GUI. De tal manera, puedes utilizarlo para abrir archivos y programas.</p>
<h3 id="eliminación-con-remove-item-rm">Eliminación con <code>Remove-Item</code> (<code>rm</code>)</h3>
<p>Ahora que puedes ver los resultados de lo que haces en PowerShell, aprendamos a borrar cosas, por ejemplo, aquel directorio con el nombre largo. Primero crearemos algunos directorios más. Nómbralos &quot;dir&quot;, &quot;dir1&quot;, y &quot;dir2&quot;. Puedes crear los tres con un solo comando escribiendo:</p>
<p><code>mkdir dir, dir1, dir2</code></p>
<p>Genial, ¿no? Deberías ver tus tres nuevos directorios en la ventana abierta de Explorador (en la GUI).</p>
<p>Ahora vamos a deshacernos de ese directorio con el nombre largo. Para ello utilizaremos el <em>cmdlet</em> <code>Remove-Item</code> o <code>rm</code>. Tienes que ser <strong>muy cuidadoso</strong> con este <em>cmdlet</em> pues no transfiere los ítems borrados a la papelera o basurero de reciclaje, sino que <strong>los elimina de manera permanente</strong>, así que lo puedes considerar borrado sin posibilidad de recuperarlo. Escribe <code>rm</code> seguido de un espacio y el nombre largo de ese directorio del que nos queremos deshacer. Quizá quieras utilizar la tecla de tabulador para completar automáticamente el nombre. Sin embargo ten en cuenta que, como ahora tenemos varios directorios que comienzan con la letra &quot;d&quot;, tendrás que escribir algo más que la primera letra para que se complete automáticamente. Escribe:</p>
<p><code>rm dire</code> y entonces presiona la tecla de tabulación.</p>
<p>De manera alternativa, puedes escribir solamente <code>rm</code> y oprimir la tecla de tabulador varias veces para desplazarte por todos tus directorios. Si fuiste más allá del que te interesa, solamente oprime la tecla de mayúscula (<em>shift</em>) con tabulador para desplazarte hacia atrás.</p>
<p>Antes de presionar la tecla <code>Enter</code>, yo observo con atención lo que escribí para asegurarme de que estoy borrando el ítem que quiero eliminar. Solo entonces hago clic en <code>Enter</code>.</p>
<p>Adelante. Borra los otros tres directorios y observa cómo desaparecen del Explorador. Igual que con <code>mkdir</code>, puedes borrar los tres directorios de una sola vez con un comando. Inténtalo.</p>
<p>Acabamos de eliminar los directorios <code>dir</code>,<code> dir1</code> y <code>dir2</code>. Pero resulta que los necesitamos para el siguiente ejemplo. Así que vamos a crearlos de nuevo. Pero ahora, en lugar de escribir la instrucción, vamos a oprimir la flecha hacia arriba del teclado un par de veces (o las que sean necesarias). En algún punto deberás ver el comando que usaste para crear los tres directorios la primera vez. Una vez que encuentres esa línea pulsa Enter y se volverán a crear. De la misma manera que usar el tabulador (<code>tab</code>) para completar automáticamente, el uso de las flechas arriba y abajo para desplazarte por los comandos recientes te ahorrará mucho tiempo. <strong>Considera que no estamos deshaciendo el borrado que hicimos con anterioridad</strong>. Por el contrario, estamos usando un &quot;acceso directo&quot; para ingresar de nuevo un comando que hemos usado recientemente.</p>
<h3 id="entender-la-estructura-de-árbol-del-sistema-de-archivos-de-tu-computadora">Entender la estructura de árbol del sistema de archivos de tu computadora</h3>
<p>Ahora debes tener tres directorios dentro de tu directorio <code>diversionConPowerShell</code>. Desplázate al interior del directorio <code>dir</code> (utiliza <code>sl dir</code>)</p>
<p>Es importante entender la manera en la que tu computadora organiza las cosas. Observa la ruta a tu directorio actual. La ruta es todo lo que escribiste después del <em>prompt</em>. En mi caso es:</p>
<p><code>C:\Users\Ted\diverionConPowerShell\dir</code></p>
<p>Tu ruta debe verse bastante similiar. Lo que representa esta ruta en realidad es una structura parecida a un árbol que sigue el ordenador para llegar al punto en el que estás. El tronco del árbol es <code>C:</code>, que es tu disco duro. En realidad, en la mayoría de las computadoras modernas <code>C:</code>es una partición de su disco duro. ¿Por qué se llama <code>C</code>? El ordenador asigna una letra a cada una de las unidades. <code>A</code>y <code>B</code>están reservados para las dos unidades de disquettes que hace mucho tiempo utilizaban con frecuencia los usuarios para interactuar con los discos duros de sus computadoras. Aunque la mayoría de los ordenadores ya no los tienen, los nombres quedaron reservados.</p>
<p>Si <code>C:</code> es el tronco del árbol, cada sección de la ruta después de <code>C:</code> es una rama, de la cual salen otras que están por encima de ella. Así, <code>Users</code> es una rama de <code>C:</code>, <code>Ted</code> es una rama más pequeña que sale de <code>Users</code> y así sucesivamente. También se puede usar la metáfora de la herencia en lugar de la de la botánica y llamar a cada rama un <code>hijo</code> del directorio por encima de ella. Este es el lenguaje más común para describir las relaciones entre los directorios (de ahí el cmdlet <code>Get-ChildItem</code>), pero nos quedaremos con la metáfora del árbol ya que, en la vida real, las relaciones de herencia pueden ser mucho más complejas que la extremadamente jerárquica estructura según la cual está organizada tu computadora.</p>
<p>Entender que la ruta funciona como un árbol es importante para poder navegar por los directorios que no están inmediatamente por encima o por debajo de tu directorio actual. Sabemos que hay un directorio llamado &quot;dir1&quot;, y que éste directorio también está en el directorio &quot;diverionConPowerShell&quot;. Ve lo que sucede si intentas usar <code>sl</code> para pasar directamente a él escribiendo:</p>
<p><code>sl dir1</code></p>
<p>¡Esto arroja error!</p>
<p>{% include figure.html filename=&quot;intro-to-powershell3.png&quot; caption=&quot;Error por intentar saltar entre ramas&quot; %}</p>
<p>El problema es que intentamos saltar de una rama a otra, y PowerShell sólo entiende nuestro movimiento si nos desplazamos a lo largo del árbol. Eso significa que primero tenemos que movernos hasta donde se encuentran las ramas de &quot;dir1&quot; y &quot;dir&quot;, y luego volver a &quot;dir1&quot;. Puedes hacerlo con un comando. Veamos si puedes imaginarlo antes de leer la siguiente línea.</p>
<p>El comando es:</p>
<p><code>sl ..\dir1</code></p>
<p>Esto le indica a PowerShell subir un directorio a <code>diversionConPowerShell</code>, y luego bajar al directorio <code>dir1</code>.</p>
<h3 id="moverse-rápido-con-push-locationpushd-y-pop-location-popd">Moverse rápido con <code>Push-Location</code>(<code>pushd</code>) y <code>Pop-Location</code> (<code>popd</code>)</h3>
<p>Antes de trabajar con archivos vamos a probar los comandos <code>push</code>y <code>popd</code>. Haz lo siguiente: ve hasta el tronco del árbol.<code>C:</code>.deben ser cuatro directorios arriba del directorio en el que estás, por lo cual podrías escribir:</p>
<p><code>sl ..\..\..\..</code></p>
<p>Entonces cambia de nuevo a <code>dir1</code>. Pero en vez de escribir <code>sl</code>antes de la ruta, escribe <code>pushd</code>. Como esto:</p>
<p><code>pushd users\TUNOMBREDEUSUARIO\diversionConPowerShell\dir1</code></p>
<p>Ahora estarás en el directorio como si hubieras escrito <code>sl</code> al principio de la ruta. Pero aquí está la parte divertida. Ahora escribe:</p>
<p><code>popd</code></p>
<p>Y pulsa Enter. Genial, ¿no? El comando <code>pushd</code> indica a PowerShell que se mueva a un directorio determinado desde tu directorio actual al que puedes ser devuelto con <code>popd</code>. En otras palabras, <code>popd</code> siempre te regresará al último directorio en el cual estuviste antes de usar <code>pushd</code>. Si quieres entender más sobre lo que está pasando, lee sobre la <a href="https://es.wikipedia.org/wiki/Pila_de_llamadas">pila de llamadas</a> en Wikipedia. El uso de <code>pushd</code> y <code>popd</code> es muy útil cuando te mueves con frecuencia entre dos directorios.</p>
<h2 id="trabajar-con-archivos">Trabajar con archivos</h2>
<p>Ahora que sabes cómo moverte a través del sistema de archivos de tu computadora desde la línea de comandos, vamos a trabajar manipulando archivos. Comenzaremos por aprender a <strong>crear</strong> nuevos archivos, <strong>copiarlos</strong> y <strong>moverlos</strong>.</p>
<h3 id="crear-archivos-con-new-item-ni">Crear archivos con <code>New-Item</code> (<code>ni</code>)</h3>
<p>Primero, necesitamos algunos archivos para trabajar con ellos. Hagamos un nuevo documento de texto plano llamado &quot;ejemplo.txt&quot;. Navega hasta el directorio <code>diversionConPowerShell</code> -utiliza el tabulador para cada nombre de directorio que escribas y acelerar el proceso-, y escribe:</p>
<p><code>ni ejemplo.txt</code></p>
<p>Presiona Enter. Después ecribe:</p>
<p><code>gci</code></p>
<p>para que confirmes, en efecto, que ahora tienes el archivo <code>ejemplo.txt</code> además de tus directorios. Necesitaremos varios archivos así que, adelante: crea <code>ejemplo1.txt</code> y <code>ejemplo2.txt</code>. No te sorprenderá saber que, incluyendo una coma, puedes hacer esto con un solo comando:</p>
<p><code>ni ejemplo1.txt, ejemplo2.txt</code></p>
<h3 id="copiar-y-mover-archivos-con-copy-itemcp-y-move-item-mv">Copiar y mover archivos con <code>Copy-Item</code>(<code>cp</code>) y <code>Move-Item</code> (<code>mv</code>)</h3>
<p>Quizá deberíamos haber puesto estos archivos en un directorio. Movámoslos. Pongamos <code>ejemplo.txt</code> en <code>dir</code> escribiendo:</p>
<p><code>mv ejemplo.txt dir</code></p>
<p>Ahora escribe <code>gci</code> y verás que <code>ejemplo.txt</code> ha desaparecido. Entra a <code>dir</code> (<code>sl dir</code>) y escribe <code>gci</code> para que compruebes que ¡ahora está ahí! También puedes hacer esto sin cambiar de directorio escribiendo <code>gci dir</code> desde el directorio <code>diversionConPowerShell</code>. Regresa a <code>diversionConPowerShell</code> y mueve <code>ejemplo1.txt</code> a <code>dir1</code> y <code>ejemplo2.txt</code> a <code>dir2</code>.</p>
<p>También podemos utilizar <code>mv</code> para <strong>renombrar</strong> ítems. Usa <code>sl</code> para moverte a <code>dir</code>. Escribe <code>gci</code> y deberás ver tu archivo <code>ejemplo.txt</code>. Es un nombre aburrido, así que llamémosle <code>benjamin.txt</code>. Escribe:</p>
<p><code>mv ejemplo.txt benjamin.txt</code></p>
<p>Utiliza <code>gci</code> de nuevo para confirmnar que tu documento ahora se llama <code>bejamin.txt</code>.</p>
<p>Te sorprenderá que el mismo <em>cmdlet</em> se utiliza tanto para mover como para renombrar archivos. De hecho, la operación es la misma. En ambos casos le estás diciendo a la computadora que cambie el &quot;nombre&quot; de la ubicación del archivo, es decir, que cambie la <strong>ruta</strong> que sigue para encontrar el archivo. En el primer ejemplo, la ruta comenzó como:</p>
<p><code>C:\Users\Ted\diversionConPowerShell\ejemplo.txt</code></p>
<p>Y luego cambió a:</p>
<p><code>C:\Users\Ted\diversionConPowerShell\dir\ejemplo.txt</code></p>
<p>En el segundo ejemplo, la ruta cambió de:</p>
<p><code>C:\Users\Ted\diversionConPowerShell\dir\ejemplo.txt</code></p>
<p>a:</p>
<p><code>C:\Users\Ted\diversionConPowerShell\dir\benjamin.txt</code></p>
<p>Dicho de otro modo, en ambos ejemplos <code>mv</code> solamente cambia la ruta. No te preocupes si esto no te hace sentido por ahora. Sólo ten cuidado de escribir correctamente las rutas cuando utilices <code>mv</code> porque, si no lo haces, puedes cambiar el nombre cuando lo que quieres es mover el archivo, o viceversa.</p>
<p>Además de mover archivos, también quisiéramos copiarlos o eliminarlos. Para copiar archivos, utilizamos el <em>cmdlet</em> <code>Copy-Item</code> o<code> cp</code>. Hagamos dos copias de <code>benjamin.txt</code> y llamémoslas <code>steven.txt</code> y <code>susie.txt</code>.</p>
<p><code>cp benjamin.txt steven.txt</code></p>
<p><code>cp benjamin.txt susie.txt</code></p>
<p>También podemos eliminar estos dos nuevos archivos con <code>rm</code>, al igual que hicimnos con los directorios. Intenta hacerlo con un solo comando. Como siempre, ten cuidado cuando utilices <code>rm</code>.</p>
<p>Éste es el comando:</p>
<p><code>rm steven.txt, susie.txt</code></p>
<p>¡Adiós Steven y Susie!</p>
<p>{% include figure.html filename=&quot;intro-to-powershell4.png&quot; caption=&quot;Mover, copiar y borrar&quot; %}</p>
<h1 id="haciendo-más">Haciendo más</h1>
<p>Bien, ahora ya podemos navegar, crear archivos, moverlos y borrarlos en PowerShell. Nos sentimos muy bien, muy <em>geeks</em> porque podemos hacer estas cosas desde la línea de comandos. Pero esto no es realmente útil ya que podíamos hacer estas cosas muy fácilmente con la interfaz gráfica de usuario. Ahora que sabemos estos fundamentos, sin embargo, podemos comenzar a aprender comandos algo más complejos que pueden ser útiles en nuestro trabajo como humanistas digitales.</p>
<h3 id="escribir-en-archivos-con-write-output-write-echo-y-redirección">Escribir en archivos con <code>Write-Output</code> (<code>write</code>, <code>echo</code>) y redirección</h3>
<p>Tenemos un archivo vacío en nuestro directorio <code>dir</code>. Eso no es muy interesante, así que vamos a añadir un poco de contenido. Podríamos abrir el archivo en el Bloc de notas y modificarlo de esa manera. Pero también podemos añadirle contenido con órdenes desde la línea de comandos. El <em>cmdlet</em> que utilizamos para esto es <code>Write-Output</code>, o simplemente <code>write</code>.</p>
<p>Prueba con esto:</p>
<p><code>write &quot;La técnica de la reproducción separa el objeto reproducido del dominio de la tradición.&quot;</code></p>
<p>PowerShell debe imprimir esta frase directamente en la ventana de la línea de comandos. Eso es todo lo que hace <code>write</code>. Le dice a PowerShell &quot;Imprime lo que yo escriba&quot;. Eso no es muy útil dado que queremos poner este texto en nuestro documento. Para ello, usaremos algo llamado <strong>redirección</strong>.</p>
<p>Redirección es una forma de decirle a PowerShell que tome los resultados de un comando y los coloque en algún lugar que no sea en la ventana de PowerShell. Para redirigir un comando, ponemos un paréntesis angular derecho (<code>&gt;</code>) entre el comando y el lugar donde queremos que vaya su salida. En este caso, queremos que la salida de nuestro comando <code>write</code> termine en<code> benjamin.txt</code>. Así que usamos la flecha hacia arriba para recuperar la declaración, y añadimos <code>&gt; benjamin.txt</code> al final. Todo el asunto debería ser así:</p>
<p><code>write &quot;La técnica de la reproducción separa el objeto reproducido del dominio de la tradición.&quot; &gt; benjamin.txt</code></p>
<p>Cuando presiones Enter parecerá que nada sucede. Esto se debe a que la instrucción <code>write</code> fue redirigida. Para ver qué es lo que realmente ocurrió, usa <code>gci</code> para ver el contenido de tu directorio. Ten en cuenta que la longitud de <code>benjamin.txt</code> ya no es 0. ¡Esto es porque acabamos de poner texto en él!</p>
<h3 id="leer-archivos-con-get-content-gc-cat">Leer archivos con <code>Get-Content</code> (<code>gc</code>, <code>cat</code>)</h3>
<p>Ya que <code>gci</code> nos muestrta que hay algo en el archivo, sería bueno poder ver qué frase pusimos en él. Podríamos hacerlo con el comando: <code>notepad benjamin.txt</code>, lo que abriría el documento en el Bloc de notas. Pero también hay un <em>cmdlet</em> para imprimir el contenido del archivo en PowerShell que se llama <code>Get-Content</code>. Escribe:</p>
<p><code>gc benjamin.txt</code></p>
<p>¡Y ahí está tu frase!</p>
<p>Ustilizar <code>gc</code> es útil por sí mismo, pero no resulta tan interesante. Si lo combinamos con la redirección, podemos hacer mucho más. Para empezar, podemos poner el contenido de un archivo en otro, casi igual que copiar un archivo. Ya sabes cómo hacerlo con <code>cp</code>. Haz una copia de <code>benjamin.txt</code> llamada <code>benjamin1.txt</code> usando <code>cp</code>. Ese comando se verá así:</p>
<p><code>cp benjamin.txt benjamin1.txt</code></p>
<p>Ahora haz un archivo <code>benjamin2.txt</code> con el mismo contenido que<code> benjamin.txt</code>, pero usando <code>gc</code> y redirección. Intenta averiguar cómo se hace.</p>
<p>En caso de que no lo logres, aquí está la respuesta:</p>
<p><code>gc benjamin.txt &gt; benjamin2.txt</code></p>
<p>Por supuesto que esto es solamente una forma más engorrosa de hacer lo que ya podemos hacer con <code>cp</code>. Pero la diferencia en estos métodos es sustancial porque al usar <code>gc</code> podemos agregar información a un archivo de texto sin reemplazar lo que ya está allí, y también podemos obtener el contenido de varios archivos de texto y ponerlos en otro.</p>
<p>En primer lugar vamos a aprender a adjuntar. Necesitamos algo que añadir a texto así que hagamos un nuevo archivo llamado <code>siguiente.txt</code> y escribamos la frase &quot;Haciendo muchas reproducciones sustituye una pluralidad de copias para una existencia única.&quot; Podríamos hacer nuestro archivo primero con <code>ni</code>, pero no es necesario. Si le decimos a PowerShell que escriba en un archivo que no está en tu directorio, lo creará para nosotros. Así podemos simplemente escribir:</p>
<p><code>write &quot;Haciendo muchas reproducciones sustituye una pluralidad de copias para una existencia única.&quot; &gt; siguiente.txt</code></p>
<p>Utiliza <code>gc</code>para comprobar que se creó <code>siguiente.txt</code> y que es realmente lo que queremos que sea.</p>
<p>Ahora vamos a agregar el contenido de <code>siguiente.txt</code> a <code>benjamin.txt</code> usando <code>gc</code>y redirección. Parece simple, ¿verdad? Inténtalo con este comando:</p>
<p><code>gc siguiente.txt &gt; benjamin.txt</code></p>
<p>Luego comprueba lo que sucedió con el comando <code>gc benjamin.txt</code>. Verás que efectivamente pusiste el contenido de <code>siguiente.txt</code> en<code> benjamin.txt</code>, pero has <em>reemplazado</em> el contenido que ya estaba allí y ¡esto no es lo que queríamos hacer!</p>
<p>Al usar <code>&gt;</code>, le ordenamos a PowerShell que pusiera el contenido de un texto en otro y sobrescribió lo que ya estaba allí. Podemos arreglar esto usando <code>&gt;&gt;</code> para nuestro redireccionamiento en lugar de un solo <code>&gt;</code>. Esto le dice a PowerShell que agregue la nueva información. Prueba esto:</p>
<p><code>gc siguiente.txt &gt;&gt; benjamin1.txt</code></p>
<p>Utiliza <code>gc</code> para comprobar que <code>benjamin1.text</code> ahora tiene ambas frases.</p>
<p>{% include figure.html filename=&quot;intro-to-powershell5.png&quot; caption=&quot;La diferencia entre <code>&gt;</code> y <code>&gt;&gt;</code>&quot; %}</p>
<p>Ahora veamos cómo obtener el contenido de varios archivos al mismo tiempo.</p>
<h3 id="trabajar-con-varios-archivos-a-la-vez-usando-caracteres-comodín-">Trabajar con varios archivos a la vez usando caracteres comodín (<code>*</code>)</h3>
<p>Ahora debes tener cuatro archivos en tu directorio, cada uno con una o dos frases del ensayo sobre el arte de Walter Benjamin. Es posible que hayas perdido la pista de lo que está exactamente en ellos. Utilicemos <code>gc</code> para comprobar el contenido.</p>
<p>Podríamos ver cada uno individualmente. Pero como puedes haber adivinado se puede mostrar el contenido de los cuatro archivos con un solo comando. Escribe:</p>
<p><code>gc benjamin.txt, benjamin1.txt, benjamin2.txt, siguiente.txt</code></p>
<p>y obtendrás la frase impresa tres veces. Podemos hacerlo aún más rápidamente. Inténtalo:</p>
<p><code>gc *.txt</code></p>
<p>El resultado será exactamente el mismo. Lo que hace <code>*.txt</code> es decirle a PowerShell que encuentre todo lo que termine con <code>.txt</code>. El <code>*</code> se llama <strong>comodín</strong>, y se puede usar para reemplazar cualquier parte de un nombre de archivo. Escribe <code>gc ben*</code> y obtendrás sólo los textos que comiencen con &quot;ben&quot;. Dado que los únicos archivos de este directorio son los cuatro que queremos, puedes incluso escribir <code>gc *</code> y obtener el contenido que nos interesa haciendo que PowerShell juestre todo lo que está en el directorio.</p>
<h3 id="búsquedas-con-select-string-sls">Búsquedas con <code>Select-String</code> (<code>sls</code>)</h3>
<p>Por supuesto que no siempre queremos ver todo el contenido sino que querramos encontrar contenido específico. Al utilizar <code>*</code>, podemos buscar varios archivos al mismo tiempo. Una de nuestras oraciones tenía algo acerca de &quot;existencia única&quot;, ¿no? ¿Donde fue eso? Podemos usar el <em>cmdlet</em> <code>Select-String</code> para buscar fragmentos específicos de texto. Escribe:</p>
<p><code>sls &quot;existencia única&quot; *.txt</code></p>
<p>y PowerShell arrojará todas las líneas que contengan esa cadena de caracteres de cualquier archivo de nuestro directorio que termine en <code>.txt</code>.</p>
<p>El uso de <code>sls</code> en archivos tan pequeños como los nuestros no nos ahorrará mucho tiempo comparado con el que ocuparíamos si leyéramos los archivos nosotros mismos. Pero el uso de este <em>cmdlet</em> con un mayor número de archivos, más largos, puede ser extraordinariamente útil.</p>
<h3 id="bucles-infinitos-y-abortar-procesos-con-control-c">Bucles infinitos y abortar procesos con <code>control-c</code></h3>
<p>Veamos una tarea más útil que podemos lograr combinando <code>gc</code>, comodines y redirección. Supongamos que tenemos muchos archivos diferentes que queremos combinar en un nuevo archivo, por ejemplo, porque hemos descargado cientos de letras de canciones que necesitamos analizar y  agrupar las de un solo artista en un archivo único. Aunque podríamos hacer esto especificándolos todos, es decir, <code>gc texto1, texto2, texto3&gt; nuevotexto</code>, al tener cientos de textos puede resultar una tarea bastante engorrosa. Los comodines sirven para evitar esto.</p>
<p>Vamos a concatenar nuestros cuatro textos y colocar el resultado en un quinto texto. Quizá usar <code>*.txt</code> puede parecer un auxiliar práctico. <strong>Estamos a punto de hacer algo tonto, así que por favor, lee el siguiente párrafo antes de escribir este comando!</strong></p>
<p>Intentemos</p>
<p><code>gc *.txt &gt; granben.txt</code></p>
<p>Parecerá que tu computadora no hace nada. Pero, a diferencia de otras veces cuando tu computadora aparenta que no ha hecho nada, esta vez el prompt del símbolo del sistema no vuelve a aparecer. Si intentas escribir otro comando no sucederá nada. Esto es porque PowerShell todavía está trabajando en tu último comando. A medida que haces más y más cosas complicadas con PowerShell, es algo que a veces sucede -¡estás haciendo sudar a tu computadora!-. Pero, en este caso, PowerShell nunca dejará de trabajar con este comando ya que está en un bucle infinito. Afortunadamente, puedes abortar esta tarea con:</p>
<p><code>control-c</code></p>
<p>La utilidad de <code>control-c</code> es grande, ya que a veces puedes quedar atrapado accidentalmente en un bucle infinito o, simplemente, puedes hartarte de esperar a que tu computadora haga ciertas tareas extremadamente largas.</p>
<p>¿Cómo nos quedamos atrapados en ese bucle? Le dijimos a PowerShell que pusiera todos los archivos que terminaran en <code>.txt</code> en un nuevo archivo que terminara en <code>.txt</code>. Dado que ese nuevo archivo caía bajo la rúbrica de archivos que el equipo debía concatenar y agregar a <code>granben.txt</code>, lo añadió. Y luego, ya que tenía un archivo <code>.txt</code> con nuevo contenido, lo añadió también. Este es un excelente ejemplo de algo que a menudo olvidamos sobre nuestras computadoras: no son inteligentes. Son extremadamente potentes pero carecen absolutamente de sentido común. Los humanos miramos las instrucciones e intentamos interpretarlas. &quot;No puede significar, para mí, agregar el contenido del texto final de nuevo en sí mismo una y otra vez para siempre.&quot; Los ordenadores, por otro lado, hacen exactamente lo que les decimos, sin importar lo ilógicos que sean nuestros mandamientos. A medida que adquieras experiencia trabajando con la línea de comandos, te sentirás desconcertado por las interpretaciones excesivamente literales de sus comandos, pero también aprenderán a darle instrucciones que puede seguir. Los bucles infinitos deben evitarse a toda costa, pero se producirán, y cuando lo hagan, recuerda: <code>control-c</code>.</p>
<h3 id="especificación-de-cmdlets-con-parámetros">Especificación de <em>cmdlets</em> con parámetros</h3>
<p>Hemos visto que tu computadora necesita que le digan cosas de manera muy exacta. Afortunadamente, PowerShell proporciona métodos para refinar los <em>cmdlets</em> añadiendo parámetros.</p>
<p>Veamos un ejemplo: utiliza <code>gci</code> para comprobar que tienes cinco archivos en tu directorio. Uno de ellos, <code>granben.txt</code>, es muy grande. Escribe:</p>
<p><code>gc granben.txt</code></p>
<p>PowerShell comenzará a descargar una cantidad excesiva de texto en la pantalla. Es posible que quieras interrumpir el proceso con <code>control-c</code>, pero esto no es un bucle infinito, sólo se trasta de un archivo muy grande, por lo que puedes esperar a que todo se imprima, sólo que tardará un tiempo. Al final, puedes usar el <em>cmdlet</em> <code>clear</code> si te molesta el gran bloque de texto en la pantalla.</p>
<p>Lo que queremos comprobar es que &quot;granben.txt&quot; está compuesto por las líneas de los otros textos, repetidas una y otra vez. Podemos hacer esto mirando sólo al principio y al final, y para ello, agregamos un <strong>parámetro</strong> a nuestro <em>cmdlet</em>.</p>
<p>Introduce esto:</p>
<p><code>gc granben.txt -totalcount 10</code></p>
<p>Verás las primeras 10 líneas de tu texto. Asegúrate de incluir el guión, ya que de lo contrario PowerShell no sabrá que <code>-TotalCount</code> es un parámetro. Ahora escribe:</p>
<p><code>gc granben.txt -tail 10</code></p>
<p>y verás las últimas 10 líneas. Lo que hemos hecho es especificarle a nuestro <em>cmdlet</em> <code>gc</code> los parámetros <code>-totalcount</code> y <code>-tail</code>. Casi todos los <em>cmdlets</em> pueden ser refinados añadiendo parámetros como este. Pero, ¿cómo sabemos qué parámetros están disponibles?</p>
<h3 id="más-información-sobre-get-help">Más información sobre <code>Get-Help</code></h3>
<p>PowerShell no espera que memorices todos los parámetros posibles para todos los <em>cmdlets</em>^. En su lugar, proporciona una forma sencilla de enumerarlos utilizando el <em>cmdlet</em> <code>Get-Help</code>. Escribe</p>
<p><code>Get-Help gc</code></p>
<p>y obtendrás una pantalla que se ve así:</p>
<p>{% include figure.html filename=&quot;intro-to-powershell6.png&quot; caption=&quot;Páginas de ayuda de <code>Get-Content</code>&quot; %}</p>
<p>Tu página puede ser ligeramente distinta, pero la parte importante para mirar en este momento es la sección llamada &quot;SYNTAX&quot;. Esta nos muestra todos los parámetros que podemos agregar a <code>Get-Content</code>. Si estás tratando de recordar el nombre exacto de un parámetro que has utilizado antes, esta ayuda será suficiente. Sin embargo, no nos dice lo que realmente hacen los parámetros.</p>
<p>Afortunadamente, el mismo <code>Get-Help</code> tiene parámetros y, agregando <code>-online</code> al <em>cmdlet</em> <code>Get-Help</code>, le indicas a PowerShell que pida a tu navegador abrir una página en el portal TechNet de Microsoft que explica todos los parámetros (en inglés). Escribe:</p>
<p><code>Get-Help gc -online</code></p>
<p>{% include figure.html filename=&quot;intro-to-powershell7.png&quot; caption=&quot;La página de ayuda en línea para <code>Get-Content</code>&quot; %}</p>
<p>Ahí podemos ver la descripción completa de los parámetros <code>-TotalCount</code> y <code>-Tail</code>.</p>
<h3 id="solución-del-problema-de-bucle-infinito-con-el-parámetro--exclude">Solución del problema de bucle infinito con el parámetro <code>-exclude</code></h3>
<p>Observa de nuevo la ayuda de <code>Get-Content</code> y verás que uno de los parámetros es <code>-exclude</code>. Esto suena prometedor para tratar con nuestro problema del bucle infinito. La descripción en línea dice: Omite los elementos especificados. El valor de este parámetro califica el parámetro de <strong>ruta</strong>. Introduzca un elemento o patrón de ruta, como &quot;*.txt&quot;. Los comodines están permitidos.&quot; El &quot;parámetro de ruta&quot; es, normalmente, lo que escribes inmediatamente después de tu <em>cmdlet</em>. Indica a PowerShell dónde se va a aplicar el <em>cmdlet</em>. Cuando escribimos <code>gc benjamin.txt</code>, <code>benjamin.txt</code> es la ruta. En realidad, es una abreviatura de <code>.\Benjamin.txt</code>, que a su vez es una abreviatura de <code>C:\Users\TUNOMBREDEUSUARIO\diversionConPowerShell\dir\benjamin.txt</code>. Esa línea le dice a su computadora el camino a seguir a través de la estructura de tu sistema de archivos, similar a la de un árbol, para encontrar el archivo que deseas. Entonces, lo que la ayuda nos está diciendo es que podemos omitir elementos específicos de nuestro <em>cmdlet</em> <code>gc</code> añadiendo el parámetro <code>-exclude</code> y luego ingresando la ruta que queremos que excluya. Podemos utilizar esto para tomar el contenido de todos nuestros archivos <code>.txt</code> y ponerlos en un nuevo archivo sin crear un bucle infinito. Trata de averiguar qué escribir, utilizando lo que hicimos con <code>-totalcount</code> y<code> -tail</code> como referencia.</p>
<p>Esto es lo que yo hice. Primero eliminé mi <code>granben.txt</code> actual con <code>rm</code>. Aunque esto no es realmente necesario, ya que al usar un solo <code>&gt;</code> en el rediccionamiento reemplazaría el contenido actual de todos modos, pero es agradable tener un inicio limpio. Entonces escribí:</p>
<p><code>gc *.txt -exclude granben.txt &gt; granben.txt</code></p>
<p>Voilà!</p>
<p>A lo largo de este proceso, hemos estado agregando textos juntos o concatenándolos. Puedes obtener más información sobre <a href="https://es.wikipedia.org/wiki/Concatenaci%C3%B3n">concatenación en Wikipedia</a>, y si quieres ver algunos ejemplos más de concatenación usando PowerShell, echa un vistazo a esta <a href="https://blogs.technet.microsoft.com/heyscriptingguy/2014/07/15/keep-your-hands-clean-use-powershell-to-glue-strings-together">entrada de blog</a> (en inglés), que te llevará al maravilloso mundo de las variables, algo más allá del alcance de este tutorial, pero acerca de las que vale la pena aprender.</p>
<h3 id="obtener-más-provecho-de-los-cmdlets-con-piping">Obtener más provecho de los <em>cmdlets</em> con Piping</h3>
<p>Tenemos ahora cinco documentos en nuestro directorio. Con el fin de poder hacer cosas realmente útiles con ellos necesitamos una herramienta más: <strong>canalización</strong>. Ésta es una especie de redirección, pero en lugar de decirle a PowerShell que coloque los resultados de un <em>cmdlet</em> en otro lugar, le dice que tome la salida de un <em>cmdlet</em> y lo use como entrada para otro. Donde usamos <code>&gt;</code> para la redirección, para las canalizaciones usamos <code>|</code>.</p>
<p>Vamos a obtener aún mayor rendimiento de <code>gc</code>, canalizando los resultados al <em>cmdlet</em> <code>measure-object</code> (o simplemente <code>measure</code>). Este último <em>cmdlet</em> tiene varias propiedades. Para nuestro propósito, lo usaremos para obtener el número de líneas, palabras y caracteres en nuestros archivos agregando los parámetros <code>-line</code>,<code> -word</code> y <code>-character</code>, o simplemente<code> -l</code>, <code>-w</code>, <code>-c</code>. (Con los parámetros, sólo necesitas escribir el nombre adecuado para identificar el parámetro en cuestión. Utiliza <code>Get-Help</code> para averiguar cuál será para un determinado <em>cmdlet</em>).</p>
<p>Escribe esto:</p>
<p><code>gc benjamin.txt | measure -l -w -c</code></p>
<p>Lo que debes obtener es un recuento de las líneas, palabras y caracteres del texto. Por supuesto, podrías hacer esto fácilmente con tu procesador de textos. Sin embargo, el poder que te da trabajar en línea de comandos es el de ser capaz de manipular muchas cosas a la vez y especificar lo que quieres hacer con mucha mayor precisión. En este ejemplo significa que podemos contar palabras en varios de nuestros archivos a la vez, y que podemos agregar parámetros adicionales para especificar exactamente cómo queremos contarlos.</p>
<p>Obtén el recuento de líneas, palabras y caracteres de todos los archivos en el directorio. No debería sorprendernos que el comodín (<code>*</code>) pueda ser también de gran ayuda. Por ejemplo, puedes escribir:</p>
<p><code>gc *.txt | measure -l -w -c</code></p>
<p>Con nuestros cinco pequeños archivos esto todavía no resulta muy vistoso, pero habrías perdido más tiempo usando el procesador de textos. También podríamos hacerlo con un directorio que contenga miles de archivos largos. También podemos controlar nuestras acciones con mayor precisión con parámetros adicionales. Utiliza <code>Get-Help measure</code> para ver los parámetros a tu disposición. Podríamos ir a la ayuda en línea para aprender más sobre ellos, pero por ahora vamos a usar uno que se explica por sí mismo como un ejemplo que consiste en ignorar los espacios en blanco: <code>-IgnoreWhiteSpace</code>.</p>
<p>Utiliza la flecha hacia arriba para recuperar tu último comando y agrega <code>-ignorewhitespace</code> al final. También puedes escribir <code>-ig</code>. Ten en cuenta que <code>-i</code> solo no es suficiente, ya que no diferencia el parámetro <code>-IgnoreWhiteSpace</code> del parámetro <code>-InputObject</code>, como te lo indicará un útil mensaje de error si lo intentarás. Verás el mismo recuento pero con menos caracteres, porque esta vez PowerShell no contó los espacios. La ventaja de la precisión es clara sobre el uso de un procesador de textos, donde es difícil determinar si se ignora o no el espacio en blanco en primer lugar, dejando de lado las posibilidades de cambiar funciones según tus necesidades.</p>
<h2 id="utilización-de-herramientas-de-línea-de-comandos-y-ejecución-de-secuencias-de-comandos-en-python">Utilización de herramientas de línea de comandos y ejecución de secuencias de comandos en Python</h2>
<p>La razón más importante para familiarizarse con el uso de la línea de comandos no es la mayor precisión o capacidad para trabajar con archivos, si bien estas características son útiles. Su importancia radica en que permite el acceso a muchas herramientas adicionales, como se mencionó en la introducción. Cuando se configura PowerShell para trabajar con algunas de estas herramientas, puede tener problemas ya que, a veces, Windows dispone las rutas incorrectamente. La solución a este problema requiere de una configuración correcta de las <a href="https://es.wikipedia.org/wiki/Variable_de_entorno">variables de entorno</a>, un tema que va más allá del alcance de este tutorial. Afortunadamente, hay mucha infortmación disponible en línea y con un poco de búsqueda darás con la solución que necesitas. Debido a que muchas lecciones de <em>The Programming Historian</em> en español requieren que utilices Python, echaremos un vistazo brevemente a la configuración para Python. Una vez hecho esto, estarás menos intimidado por las instrucciones para establecer variables de entorno para otros programas.</p>
<p>Si aún no tienes Python, o si te preguntas por qué deberías usarlo, consulta el <a href="/es/lecciones/introduccion-e-instalacion">tutorial de Python</a> aquí en <em>The Historian</em> en español. En dicho tutorial, aprenderás a configurar Python para ejecutar secuencias de comandos directamente en un editor de texto. Pero, generalmente, será muy útil poder ejecutar <em>scripts</em> desde la línea de comandos. Para ello, necesitamos establecer una variable de entorno. Primero, necesitas saber el nombre del directorio donde Python está instalado en tu computadora. Introduce <code>sl C:\</code> y luego utiliza <code>gci</code>. Deberías ver un directorio llamado &quot;Python&quot; con el número de versión al final. En mi computadora, el directorio es &quot;Python27&quot;. Ahora le ordenamos a Windows que cree una variable de ruta (<em>Path</em>) que apunte a ese directorio introduciendo esto en PowerShell, reemplazando &quot;Python27&quot; por el nombre del directorio en tu computadora:</p>
<p><code>[Environment]::SetEnvironmentVariable(&quot;Path&quot;, &quot;$env:Path;C:\Python27&quot;, &quot;User&quot;)</code></p>
<p>Esto le dice a Windows: &quot;Oye, la ruta para Python es: C:\Python27&quot;. Si quieres entender exactamente cómo funciona esto, mira <a href="https://technet.microsoft.com/en-us/library/ff730964.aspx">esta página</a> (en inglés) en el portal TechNet de Microsoft (el mismo portal que utilizas en línea con <code>Get-Help</code>).</p>
<p>Una vez que hayas corrido el comando anterior, sal de PowerShell y vuelve a iniciarlo. Entonces deberías poder abrir el intérprete de Python escribiendo <code>python</code> en PowerShell. Para ejecutar <em>scripts</em>, simplemente escribe <code>python</code> seguido de la ruta del <em>script</em> que quieres. Es más fácil navegar primero al directorio que contiene el <em>script</em>, y luego simplemente escribir <code>python nombre-de-script.py</code>.</p>
<p>Ahora ya estás preparado para ejecutar <em>scripts</em> de Python desde la línea de comandos.</p>
<h1 id="conclusión">Conclusión</h1>
<p>En este tutorial has aprendido algunos de los conceptos básicos para trabajar con PowerShell, la interfaz de línea de comandos de Windows. Ya sabes lo suficiente para usar PowerShell para muchas de las tareas cotidianas que haces en tu computadora y yo recomendaría usarlo para eso. Al principio puede resultar más difícil copiar un archivo y moverlo a un nuevo directorio desde la línea de comandos, pero cuanto más practiques más natural será. Eventualmente, te encontrarás cómodamente trabajando en PowerShell, y serás capaz de hacer muchas tareas más fácilmente de esta manera.</p>
<p>Aunque sólo hemos dado un vistazo de lo que puede hacer PowerShell, ahora tienes suficientes conocimientos básicos para aprender a hacer más cosas. Hay muchos recursos útiles en línea y los puedes hacer tuyos con Google. También es útil saber que muchas discusiones sobre el uso de la línea de comandos se basarán en Unix y otros sistemas *nix. En la mayoría de los casos, si simplemente escribes en un buscador los nombres de los comandos que estás utilizando junto con &quot;PowerShell&quot;, encontrarás el <em>cmdlet</em> correspondiente.</p>
<p>Cuanto más utilices PowerShell más fácil será descubrir capacidades que ni siquiera sabías que tenía tu computadora. Eventualmente, notarás cómo el uso de la GUI te ha restringido en el uso de la potencialidad de tu máqiuna. No dejarás de usar la GUI, pero te encontrarás iniciando PowerShell cada vez con mayor frecuencia para liberarte de estas limitaciones y utilizar tu computadora de manera más completa. Tu computadora es como una navaja de bolsillo. La GUI sólo te permite abrir algunas cuchillas; ¡pero con la línea de comandos puedes abrirlas todas!</p>
<h1 id="referencia-rápida">Referencia rápida</h1>
<p>Esta tabla sirve como una referencia rápida a todos los <em>cmdlets</em> mencionados en esta lección. La primera columna muestra el nombre real; el segundo muestra la abreviatura que normalmente se escribe. El equivalente de Bash muestra el comando más similar en Bash. A menos que este comando esté entre paréntesis, también se puede utilizar en PowerShell como un alias para el <em>cmdlet</em> correspondiente. Para obtener una explicación más completa de cualquiera de los <em>cmdlets</em>, utiliza <code>Get-Help</code> con el parámetro <code>-online</code> (por ejemplo, <code>Get-Help Get-ChildItem -online</code>).</p>
<table>
<thead>
<tr>
<th>Cmdlet</th>
<th>Alias</th>
<th>Bash Equivalent</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Get-ChildItem</code></td>
<td><code>gci</code></td>
<td><code>ls</code></td>
<td>Enlista los directorios y archivos en la ubicación actual.</td>
</tr>
<tr>
<td><code>Set-Location</code></td>
<td><code>sl</code></td>
<td><code>cd</code></td>
<td>Cambia al directorio en la ruta de acceso dada. Si escribes <code>..</code> en lugar de una ruta te moverá hacia arriba un directorio.</td>
</tr>
<tr>
<td><code>Push-Location</code></td>
<td><code>pushd</code></td>
<td><code>pushd</code></td>
<td>Cambiar al directorio.</td>
</tr>
<tr>
<td><code>Pop-Location</code></td>
<td><code>popd</code></td>
<td><code>popd</code></td>
<td>Regresa al directorio previo despues de usar <code>pushd</code></td>
</tr>
<tr>
<td><code>New-Item</code></td>
<td><code>ni</code></td>
<td>(<code>touch</code>)</td>
<td>Crea un nuevo ítem. De no utilizarse un parámetro, el ítem será un archivo por defecto. El uso de <code>mkdir</code> es una abreviatura para incluir el parámetro <code>-ItemType dir</code>.</td>
</tr>
<tr>
<td><code>mkdir</code></td>
<td>none</td>
<td><code>mkdir</code></td>
<td>Crea un nuevo directorio. (Ver <code>New-Item</code>.)</td>
</tr>
<tr>
<td><code>Explorer</code></td>
<td>none</td>
<td>(<code>open</code>)</td>
<td>Abre algo utilizando el Explorador de archivos (la GUI)</td>
</tr>
<tr>
<td><code>Remove-Item</code></td>
<td><code>rm</code></td>
<td><code>rm</code></td>
<td>Borra algo... ¡de manera permanente!</td>
</tr>
<tr>
<td><code>Move-Item</code></td>
<td><code>mv</code></td>
<td><code>mv</code></td>
<td>Mueve algo. Necesita dos argumentos. Primero un nombre de archivo (i.e. su ruta actual), luego la ruta de nueva nueva locación (incluido el nombre que debe tener ahí). Si no se cambia la ruta, puede usarse para renombrar archivos.</td>
</tr>
<tr>
<td><code>Copy-Item</code></td>
<td><code>cp</code></td>
<td><code>cp</code></td>
<td>Copia un archivo en una nueva ubicación. Requiere los mismos argumentos que mover, pero mantiene el archivo original en su ubicación.</td>
</tr>
<tr>
<td><code>Write-Output</code></td>
<td><code>write</code></td>
<td><code>echo</code></td>
<td>Exporta lo que escribas. Utiliza la redirección para enviarlo a un archivo. La redirección con <code>&gt;&gt;</code> añadirá texto al archivo en lugar de sobrescribir el contenido.</td>
</tr>
<tr>
<td><code>Get-Content</code></td>
<td><code>gc</code></td>
<td><code>cat</code></td>
<td>Obtiene el contenido de un archivo y lo imprime en la pantalla. La adición del parámetro <code>-TotalCount</code> seguido de un número x sólo imprime las primeras x líneas. Añadiendo el parámetro <code>-Tail</code> seguido de un número x sólo imprime las x líneas finales.</td>
</tr>
<tr>
<td><code>Select-String</code></td>
<td><code>sls</code></td>
<td>(<code>grep</code>)</td>
<td>Busca contenido específico.</td>
</tr>
<tr>
<td><code>Measure-Object</code></td>
<td><code>measure</code></td>
<td>(<code>wc</code>)</td>
<td>Obtiene información estadística sobre un objeto. Utiliza <code>Get-Content</code> y dirige la salida a<code> Measure-Object</code> con los parámetros <code>-line</code>, <code>-word</code> y <code>-character</code> para obtener información sobre el recuento de líneas, palabras o caracteres.</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>none</td>
<td><code>&gt;</code></td>
<td>Redirección. Pone la salida del comando a la izquierda de <code>&gt;</code> en un archivo a la derecha de <code>&gt;</code>.</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
<td>none</td>
<td>`</td>
</tr>
<tr>
<td><code>Get-Help</code></td>
<td>none</td>
<td><code>man</code></td>
<td>Obtiene el archivo de ayuda de un <em>cmdlet</em>. La adición del parámetro <code>-online</code> abre la página de ayuda en TechNet.</td>
</tr>
<tr>
<td><code>exit</code></td>
<td>none</td>
<td><code>exit</code></td>
<td>Salir de PowerShell</td>
</tr>
</tbody></table>
<!-- HTML_TAG_END -->

<script type="application/json" data-type="svelte-data" data-url="introduccion-a-powershell/raw.json">{"status":200,"statusText":"","headers":{"content-type":"application/json; charset=utf-8"},"body":"{\"metadata\":{\"title\":\"Introducción a la línea de comandos de Windows con PowerShell\",\"date\":\"2016-07-21T00:00:00.000Z\",\"translation_date\":\"2018-06-02T00:00:00.000Z\",\"authors\":[\"Ted Dawson\"],\"reviewers\":[\"Erin N. Bush\",\"Derek Price\"],\"editors\":[\"Jeri E. Wieringa\"],\"translator\":[\"Victor Gayol\"],\"translation-editor\":[\"Antonio Rojas Castro\"],\"translation-reviewer\":[\"Silvia Gutiérrez\",\"José Antonio Motilla\"],\"layout\":\"lesson\",\"difficulty\":1,\"redirect-from\":\"\u002Fes\u002Flessons\u002Fintro-to-powershell\",\"original\":\"intro-to-powershell\",\"review-ticket\":\"https:\u002F\u002Fgithub.com\u002Fprogramminghistorian\u002Fph-submissions\u002Fissues\u002F146\",\"activity\":\"transforming\",\"topics\":[\"data-manipulation\",\"get-ready\"],\"abstract\":\"En este tutorial aprenderás las bases de PowerShell de Windows, la interfaz de línea de comandos estándar de computadoras con Windows.\",\"avatar_alt\":\"Grabado de una concha de molusco\",\"doi\":\"10.46430\u002Fphes0037\"},\"html_body\":\"\u003Cp\u003E{% include toc.html %}\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"introducción\\\"\u003EIntroducción\u003C\u002Fh1\u003E\\n\u003Cp\u003EEn este tutorial aprenderás las bases de PowerShell de Windows, la interfaz de línea de comandos estándar de computadoras con Windows. Si eres usuario de Mac o Linux deberías consultar la \u003Ca href=\\\"\u002Fes\u002Flecciones\u002Fintroduccion-a-bash\\\"\u003EIntroducción a la línea de comandos en Bash\u003C\u002Fa\u003E. Si ya estás familiarizado con el uso de Bash, es posible que puedas comenzar con PowerShell solamente con ver la \u003Ca href=\\\"#referencia-rapida\\\"\u003Etabla al final de esta lección\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EEl tutorial está dividido en dos secciones principales. En la primera sección, &quot;\u003Ca href=\\\"#para-empezar\\\"\u003EPara empezar\u003C\u002Fa\u003E&quot;, aprenderás a realizar tareas básicas de escritorio como crear y abrir archivos y carpetas con PowerShell. En la segunda sección, &quot;\u003Ca href=\\\"#haciendo-m%C3%A1s\\\"\u003EHaciendo más\u003C\u002Fa\u003E&quot;, obtendrás un vistazo de algunas de las características que hacen que el trabajo en línea de comandos sea particularmente eficiente y aprendas lo básico para poder explorar más por tu cuenta. También te prepararás para \u003Ca href=\\\"#Utilizaci%C3%B3n-de-herramientas-de-l%C3%ADnea-de-comandos-y-ejecuci%C3%B3n-de-secuencias-de-comandos-en-Python\\\"\u003Eejecutar \u003Cem\u003Escripts\u003C\u002Fem\u003E de Python desde la línea de comandos\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EEste tutorial fue escrito para PowerShell 5.0. Si estás usando una versión anterior, encontrarás algunas pequeñas diferencias de sintaxis que debes ser capaz de superar con la pequeña ayuda de un buscador.\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"¿qué-es-powershell-y-por-qué-es-útil\\\"\u003E¿Qué es PowerShell y por qué es útil?\u003C\u002Fh1\u003E\\n\u003Cp\u003EWindows PowerShell es una \u003Cstrong\u003Einterfaz de línea de comandos\u003C\u002Fstrong\u003E para computadoras Windows. Una interfaz de línea de comandos (CLI, por sus siglas en inglés) es un programa que te permite hacer que tu computadora ejecute tareas utilizando órdenes escritas en vez de hacer clic sobre las imágenes en el escritorio como en una \u003Cstrong\u003Einterfaz gráfica de usuario\u003C\u002Fstrong\u003E (GUI, por sus siglas en inglés). Técnicamente, PowerShell es más que sólo una CLI; puedes obtener una visión general de sus características en \u003Ca href=\\\"https:\u002F\u002Fes.wikipedia.org\u002Fwiki\u002FWindows_PowerShell\\\"\u003EWikipedia\u003C\u002Fa\u003E. El uso de la línea de comandos tiene muchas ventajas. Hace posible automatizar tareas y hacer muchas cosas con una orden. Lo que es más importante, una serie de herramientas de valor para los humanistas sólo se pueden ejecutar desde la línea de comandos, incluyendo muchas de las que puedes aprender en \u003Cem\u003EThe Historian\u003C\u002Fem\u003E en español, como \u003Ca href=\\\"\u002Fen\u002Flessons\u002Ftopic-modeling-and-mallet\\\"\u003EMallet\u003C\u002Fa\u003E (en inglés), \u003Ca href=\\\"\u002Fes\u002Flecciones\u002Fescritura-sostenible-usando-pandoc-y-markdown\\\"\u003EPandoc\u003C\u002Fa\u003E, o \u003Ca href=\\\"\u002Fen\u002Flessons\u002Fautomated-downloading-with-wget\\\"\u003EWget\u003C\u002Fa\u003E (en inglés). La línea de comandos es también el mejor lugar para trabajar con los programas que has construido y personalizado para tu propia investigación utilizando lenguajes de programación como Python.\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"para-empezar\\\"\u003EPara empezar\u003C\u002Fh1\u003E\\n\u003Cp\u003EEn primer lugar aprenderás a navegar a través de tus archivos y a realizar algunas tareas básicas que haces todos los días en la computadora.\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"abrir-powershell\\\"\u003EAbrir PowerShell\u003C\u002Fh1\u003E\\n\u003Cp\u003EBusca PowerShell en tu computadora. Probablemente tengas varias opciones, como &quot;PowerShell&quot;, &quot;PowerShell ISE&quot; y &quot;PowerShell (x86)&quot;. El ISE (entorno integrado de secuencias de órdenes -\u003Cem\u003Eintegrated scripting environment\u003C\u002Fem\u003E) es una herramienta útil que te permite escribir \u003Cem\u003Escripts\u003C\u002Fem\u003E al vuelo y también cuenta con una búsqueda de todos los comandos de PowerShell. En este momento es más de lo que necesitamos. El &quot;X86&quot; es compatible con versiones anteriores del sistema operativo (si has estado en el mundo de las computadoras por algún tiempo, recordarás los viejos procesadores de Intel de los años 80 y 90 llamados &quot;286&quot;, 2386&quot;, &quot;486&quot;, y así sucesivamente. Eso es lo que permite el &quot;X86&quot;, pues es una versión de 32 bits). Pero queremos 64-bits y lo más simple, así que vamos a utilizar el llamado solamente &quot;Windows PowerShell&quot;. Posiblemente quieras agregarlo a tu barra de tareas: haz clic con el botón derecho para obtener la opción. Al abrirlo, se verá así:\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;intro-to-powershell1.png&quot; caption=&quot;Puesta en marcha de PowerShell&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003ESi no quieres blanco sobre azul, haz clic con el botón derecho en la barra superior, selecciona &quot;propiedades&quot; y ve a &quot;colores&quot; para cambiar las cosas. Deberás cerrar y volver a abrir PowerShell para que se vea correctamente.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"navegación\\\"\u003ENavegación\u003C\u002Fh2\u003E\\n\u003Cp\u003EAlgo bueno de PowerShell es que siempre sabrás dónde estás porque te lo dice en el prompt. En mi caso, yo veo:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003EC:\\\\Users\\\\Ted&gt;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EDebes ver algo similar pero con tu nombre de usuario. En caso de que no sea así, escribe:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Esl ~\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EAsegúrate de incluir el espacio. Esto te llevará a tu directorio personal: \u003Ccode\u003EC:\\\\Users\\\\TUNOMBREDEUSUARIO\u003C\u002Fcode\u003E donde &quot;TUNOMBREDEUSUARIO&quot; se reemplaza con el nombre de tu cuenta en la máquina. &quot;Directorio&quot; es sólo otra palabra para &quot;carpeta&quot;, y PowerShell considera tu carpeta de usuario como inicio -no el escritorio. El escritorio es realmente otra carpeta dentro de tu carpeta de usuario, es decir, un subdirectorio del directorio usuario. Introducir \u003Ccode\u003Esl ~\u003C\u002Fcode\u003E es como abrir la carpeta llamada &quot;usuarios&quot; y desde ahí TUNOMBREDEUSUARIO utilizando la GUI. Comencemos aprendiendo como moverte entre los directorios y ver su contenido.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"ver-contenido-del-directorio-con-get-childitem-gci-ls\\\"\u003EVer contenido del directorio con \u003Ccode\u003EGet-ChildItem\u003C\u002Fcode\u003E (\u003Ccode\u003Egci\u003C\u002Fcode\u003E, \u003Ccode\u003Els\u003C\u002Fcode\u003E)\u003C\u002Fh3\u003E\\n\u003Cp\u003ENuestra primera orden es \u003Ccode\u003EGet-ChildItem\u003C\u002Fcode\u003E. Escríbela y oprime Enter. Verás una lista de todo lo que hay en tu directorio actual. En mi caso se verá así:\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;intro-to-powershell2.png&quot; caption=&quot;Listado del contenido del directorio con \u003Ccode\u003EGet-ChildItem\u003C\u002Fcode\u003E&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EToma en cuenta que en realdad no escribí \u003Ccode\u003EGetChildItem\u003C\u002Fcode\u003E. Solamente \u003Ccode\u003Egci\u003C\u002Fcode\u003E. Los comandos que aprenderemos son todos de la forma &quot;Verbo-Sustantivo&quot; (\u003Cem\u003EVerb-Noun\u003C\u002Fem\u003E). Son llamados &quot;cmdlets&quot; (pronunciado &quot;commandlets&quot;) y se supone que su forma hace más fácil recordar lo que hacen y predecir otros \u003Cem\u003Ecmdlets\u003C\u002Fem\u003E similares. Debido a que los \u003Cem\u003Ecmdlets\u003C\u002Fem\u003E son bastante largos, la mayoría de ellos tienen alias más elegantes que puedes utilizar en su lugar. Primero presentaré los \u003Cem\u003Ecmdlets\u003C\u002Fem\u003E con sus nombres, pero siempre usaré los alias estándar, porque son mucho más rápidos para trabajar. Es importante tener en cuenta que muchos \u003Cem\u003Ecmdlets\u003C\u002Fem\u003E tienen varios alias. Por ejemplo, \u003Ccode\u003EGet-ChildItem\u003C\u002Fcode\u003E,\u003Ccode\u003E gci\u003C\u002Fcode\u003E, \u003Ccode\u003Edir\u003C\u002Fcode\u003E y\u003Ccode\u003E ls\u003C\u002Fcode\u003E hacen exactamente lo mismo. Aunque no sorprende que \u003Ccode\u003Egci\u003C\u002Fcode\u003E sea la abreviatura de\u003Ccode\u003E Get-ChildItem\u003C\u002Fcode\u003E, es posible que te preguntes de dónde provienen \u003Ccode\u003Edir\u003C\u002Fcode\u003E y\u003Ccode\u003E ls\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EPowerShell es relativamente nuevo (se lanzó por primera vez en 2006), y sus diseñadores esperaban que muchas personas que lo utilizarían ya tendrían experiencia con algunas CLI existentes (interfaces de línea de comandos), específicamente con el CLI más antiguo de Microsoft llamado Símbolo de sistema (\u003Cem\u003Ecommand prompt\u003C\u002Fem\u003E) o con Linux CLIs como Bash, que ahora también es estándar en OS X. Por lo tanto, muchos \u003Cem\u003Ecmdlets\u003C\u002Fem\u003E tienen un alias que es el comando estándar en uno de estos dos sistemas (y a menudo para ambos). En el ejemplo presente, \u003Ccode\u003Edir\u003C\u002Fcode\u003E viene de Símbolo de sistema, y\u003Ccode\u003E ls\u003C\u002Fcode\u003E proviene de Bash. Utilizaré los alias de estilo &quot;PowerShell&quot; en este tutorial, ya que hace más fácil recordar los nombres reales de \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E. Sin embargo, intentaré también mencionar otros alias comunes, particularmente aquellos familiares para los usuarios de Bash. Si trabajas con mucha gente que usa OS X o Linux, puede ser bueno conocer estos nombres. La \u003Ca href=\\\"#referencia-r%C3%A1pida\\\"\u003Etabla en la parte inferior\u003C\u002Fa\u003E proporciona los \u003Cem\u003Ecmdlets\u003C\u002Fem\u003E junto con sus alias estándar de PowerShell y el equivalente de Bash más cercano.\u003C\u002Fp\u003E\\n\u003Cp\u003ESigue adelante e intenta usar \u003Ccode\u003Egci\u003C\u002Fcode\u003E,\u003Ccode\u003E dir\u003C\u002Fcode\u003E y \u003Ccode\u003Els\u003C\u002Fcode\u003E. Obtendrás exactamente la misma lista de cosas. La mayoría de estas cosas serán directorios. Uno de ellos debe ser tu escritorio. Vamos a entrar en ese directorio.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"navegar-entre-directorios-con-set-location--sl-cd\\\"\u003ENavegar entre directorios con \u003Ccode\u003ESet-Location\u003C\u002Fcode\u003E (\u003Ccode\u003E sl\u003C\u002Fcode\u003E, \u003Ccode\u003Ecd\u003C\u002Fcode\u003E)\u003C\u002Fh3\u003E\\n\u003Cp\u003EPara desplazarte a tu escritorio, usaremos el \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E \u003Ccode\u003ESet-Location\u003C\u002Fcode\u003E. Escribe en PowerShell:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Esl desktop\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EEsto le indica a PowerShell que se mueva al escritorio. Observa que puedes escribir &quot;desktop&quot; usando todas las letras minúsculas, aunque cuando viste el contenido del directorio \u003Ccode\u003ETUNOMBREDEUSUARIO\u003C\u002Fcode\u003E, &quot;Desktop&quot; se escribió con una &quot;D&quot; mayúscula. PowerShell no distingue entre mayúsculas y minúsculas. Ahora que has cambiado tu ubicación, puedes usar \u003Ccode\u003Egci\u003C\u002Fcode\u003E para ver una lista de todo lo que hay en tu escritorio, es decir, todo el directorio llamado\u003Ccode\u003E Desktop\u003C\u002Fcode\u003E. Si estás tan desorganizado como yo, esta será una larga lista. Podemos volver al directorio \u003Ccode\u003ETUNOMBREDEUSUARIO\u003C\u002Fcode\u003E escribiendo:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Esl ..\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003E¡No olvides el espacio! Ahora escribe de nuevo:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Esl ..\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EDebes estar en el directorio \u003Ccode\u003EUsers\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EAhora trata de volver al escritorio y luego de nuevo a \u003Ccode\u003EUsers\u003C\u002Fcode\u003E. Debe tomarte escribir cuatro comandos: \u003Ccode\u003Esl TUNOMBREDEUSUARIO\u003C\u002Fcode\u003E, \u003Ccode\u003Esl desktop\u003C\u002Fcode\u003E, \u003Ccode\u003Esl ..\u003C\u002Fcode\u003E, \u003Ccode\u003Esl ..\u003C\u002Fcode\u003E. Pero en realidad puedes hacerlo con sólo dos. Deberías estar en \u003Ccode\u003EC:\\\\Users&gt;\u003C\u002Fcode\u003E ahora mismo. En lugar de escribir \u003Ccode\u003Esl TUNOMBREDEUSUARIO\u003C\u002Fcode\u003E y luego \u003Ccode\u003Esl desktop\u003C\u002Fcode\u003E, puedes escribir solamente:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Esl TUNOMBREDEUSUARIO\\\\desktop\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003E¡Y llegar al escritorio con un comando! Del mismo modo, desde el escritorio, escribiendo:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Esl ..\\\\..\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EPuedes volver a donde comenzaste con un comando. Si no tienes la resistencia del dedo meñique para escribir \u003Ccode\u003E\\\\\u003C\u002Fcode\u003E todo el tiempo, también puedes escribir \u003Ccode\u003Esl ..\u002F ..\u003C\u002Fcode\u003E. No sólo PowerShell no distingue entre mayúsculas y minúsculas, sino que tampoco le importa en qué dirección va la barra. \u003Ccode\u003ESl ..\u002F ..\u003C\u002Fcode\u003E, \u003Ccode\u003ESL .. \\\\ ..\u003C\u002Fcode\u003E, \u003Ccode\u003ESet-Location .. \\\\ ..\u003C\u002Fcode\u003E y \u003Ccode\u003Eset-location ..\u002F ..\u003C\u002Fcode\u003E todos hacen exactamente lo mismo.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"creación-de-nuevos-directorios-con-mkdir\\\"\u003ECreación de nuevos directorios con \u003Ccode\u003Emkdir\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\\n\u003Cp\u003EEstamos avanzando hacia el trabajo con archivos. Antes de comenzar, hagamos un directorio donde podamos almacenar todo lo que estamos usando para esta lección. Navega de regreso a casa escribiendo:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Esl ~\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EHaremos un nuevo directorio dentro del directorio \u003Ccode\u003ETUNOMBREDEUSUARIO\u003C\u002Fcode\u003E. Para ello, utilizaremos el comando \u003Ccode\u003Emkdir\u003C\u002Fcode\u003E. Llama a tu directorio como quieras, pero trata de no usar espacios, ya que hacen que trabajar en línea de comandos sea más complicado de lo necesario. Voy a llamar a mi directorio &quot;diversionConPowerShell&quot;. Entonces yo escribo:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Emkdir diversionConPowerShell\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003E¿Viste cómo utilizo \u003Ca href=\\\"https:\u002F\u002Fes.wikipedia.org\u002Fwiki\u002FCamelCase\\\"\u003ECamelCase\u003C\u002Fa\u003E para evitar los espacios?\u003C\u002Fp\u003E\\n\u003Cp\u003EOtra forma común de hacer esto es insertando guión o guión bajo, como en \u003Ccode\u003Ediversion_con_power_shell\u003C\u002Fcode\u003E. Sea cual sea el nombre de tu directorio, trata de evitar el uso de espacios. Una vez que has estado trabajando con PowerShell un poco, probablemente te encontrarás nombrando a tu nuevos archivos sin espacios por defecto. Este es un buen hábito ya que simplifica el trabajo en la línea de comandos, así como al trabajar con lenguajes de programación como Python.\u003C\u002Fp\u003E\\n\u003Cp\u003ESin embargo, es probable que tengas un montón de archivos ya existentes con espacios en sus nombres. Para abrir estos en PowerShell, sólo tienes que utilizar comillas. Intentemos esto. Muevete a tu nuevo directorio utilizando:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Esl diversionConPowerShell\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003E(O como hayas nombrado tu directorio). Escribe:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Egci\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EY verás que no hay nada aquí. ¡Eso es porque no has puesto nada en él! Vamos a poner un nuevo directorio dentro con \u003Ccode\u003Emkdir\u003C\u002Fcode\u003E. Llamaremos a este directorio &quot;Directorio con un nombre largo y muchos espacios&quot;. Debido a que el nombre tiene espacios en él, tendremos que usar comillas para crearlo. Tipo\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Emkdir &quot;Directorio con un nombre largo y muchos espacios&quot;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EPresiona Enter. Ahora escribe:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Egci\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EY verás tu nuevo directorio. Supongamos que queremos movernos a este directorio. Tendríamos que escribir \u003Ccode\u003Esl &quot;Directorio con un nombre largo y muchos espacios&quot;\u003C\u002Fcode\u003E. No solo tomará un tiempo escribirlo sino que, si nos equivocamos, PowerShell no podrá encontrar nuestro directorio. En su lugar, escribe simplemente:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Esl d\u003C\u002Fcode\u003E y entonces oprime la tecla de tabulador.\u003C\u002Fp\u003E\\n\u003Cp\u003EVoilà! ¡PowerShell completa el nombre del directorio por nosotros, incluidas las comillas! El uso del tabulador para completar automáticamente te ahorrará mucho tiempo. Notarás que cuando PowerShell completó el nombre, también puso \u003Ccode\u003E.\\\\\u003C\u002Fcode\u003E al principio del nombre del directorio. El punto es solo una abreviatura de directorio actual. Cuando escribes órdenes, PowerShell siempre asume que hay un \u003Ccode\u003E.\\\\\u003C\u002Fcode\u003Eal principio -en otras palabras, que te estás refiriendo a algo en el directorio actual-. Por lo tanto, no es necesario que escribas esta parte, a menos que quieras que PowerShell busque en otro lugar lo que estás pidiendo que haga, en cuyo caso puedes escribir la ruta de ese directorio. Por ejemplo: \u003Ccode\u003EC:\\\\directorio\\\\bla\\\\etc\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EPractiquemos un poco más con directorios antes de comenzar con archivos.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"uso-de-explorerpara-ver-directorios-en-la-gui\\\"\u003EUso de \u003Ccode\u003EExplorer\u003C\u002Fcode\u003Epara ver directorios en la GUI\u003C\u002Fh3\u003E\\n\u003Cp\u003EHasta ahora hemos hecho dos directorios. He mencionado anteriormente que &quot;directorio&quot; es solo otra palabra para &quot;carpeta&quot;. Puedes verlo al mirar tus nuevos directorios en la GUI. Windows llama a su GUI &quot;Explorador de archivos&quot; o simplemente &quot;Explorador&quot;. Podemos llamar al Explorador desde PowerShell utilizando el comando &quot;Explorer&quot;. Vuelve a la carpeta diversionConPowerShell con:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Esl ..\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EAhora escribe:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Eexplorer .\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003ERecuerda que el punto solamente significa &quot;este directorio&quot;, y no tienes que escribir con mayúscula &quot;explorer&quot; porque las mayúsculas no importan en PowerShell. Explorador debería haber abierto una ventana que muestra el contenido del directorio &quot;diversiónConPowerShell&quot;. Organiza tus ventanas para que puedas ver tanto la imagen en Explorador como en PowerShell. Ahora podrás ver que lo que haces en PowerShell aparece en Explorador. El comando &quot;Explorer&quot; es extremadamente útil. Básicamente, es como hacer doble clic en la GUI. De tal manera, puedes utilizarlo para abrir archivos y programas.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"eliminación-con-remove-item-rm\\\"\u003EEliminación con \u003Ccode\u003ERemove-Item\u003C\u002Fcode\u003E (\u003Ccode\u003Erm\u003C\u002Fcode\u003E)\u003C\u002Fh3\u003E\\n\u003Cp\u003EAhora que puedes ver los resultados de lo que haces en PowerShell, aprendamos a borrar cosas, por ejemplo, aquel directorio con el nombre largo. Primero crearemos algunos directorios más. Nómbralos &quot;dir&quot;, &quot;dir1&quot;, y &quot;dir2&quot;. Puedes crear los tres con un solo comando escribiendo:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Emkdir dir, dir1, dir2\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EGenial, ¿no? Deberías ver tus tres nuevos directorios en la ventana abierta de Explorador (en la GUI).\u003C\u002Fp\u003E\\n\u003Cp\u003EAhora vamos a deshacernos de ese directorio con el nombre largo. Para ello utilizaremos el \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E \u003Ccode\u003ERemove-Item\u003C\u002Fcode\u003E o \u003Ccode\u003Erm\u003C\u002Fcode\u003E. Tienes que ser \u003Cstrong\u003Emuy cuidadoso\u003C\u002Fstrong\u003E con este \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E pues no transfiere los ítems borrados a la papelera o basurero de reciclaje, sino que \u003Cstrong\u003Elos elimina de manera permanente\u003C\u002Fstrong\u003E, así que lo puedes considerar borrado sin posibilidad de recuperarlo. Escribe \u003Ccode\u003Erm\u003C\u002Fcode\u003E seguido de un espacio y el nombre largo de ese directorio del que nos queremos deshacer. Quizá quieras utilizar la tecla de tabulador para completar automáticamente el nombre. Sin embargo ten en cuenta que, como ahora tenemos varios directorios que comienzan con la letra &quot;d&quot;, tendrás que escribir algo más que la primera letra para que se complete automáticamente. Escribe:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Erm dire\u003C\u002Fcode\u003E y entonces presiona la tecla de tabulación.\u003C\u002Fp\u003E\\n\u003Cp\u003EDe manera alternativa, puedes escribir solamente \u003Ccode\u003Erm\u003C\u002Fcode\u003E y oprimir la tecla de tabulador varias veces para desplazarte por todos tus directorios. Si fuiste más allá del que te interesa, solamente oprime la tecla de mayúscula (\u003Cem\u003Eshift\u003C\u002Fem\u003E) con tabulador para desplazarte hacia atrás.\u003C\u002Fp\u003E\\n\u003Cp\u003EAntes de presionar la tecla \u003Ccode\u003EEnter\u003C\u002Fcode\u003E, yo observo con atención lo que escribí para asegurarme de que estoy borrando el ítem que quiero eliminar. Solo entonces hago clic en \u003Ccode\u003EEnter\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EAdelante. Borra los otros tres directorios y observa cómo desaparecen del Explorador. Igual que con \u003Ccode\u003Emkdir\u003C\u002Fcode\u003E, puedes borrar los tres directorios de una sola vez con un comando. Inténtalo.\u003C\u002Fp\u003E\\n\u003Cp\u003EAcabamos de eliminar los directorios \u003Ccode\u003Edir\u003C\u002Fcode\u003E,\u003Ccode\u003E dir1\u003C\u002Fcode\u003E y \u003Ccode\u003Edir2\u003C\u002Fcode\u003E. Pero resulta que los necesitamos para el siguiente ejemplo. Así que vamos a crearlos de nuevo. Pero ahora, en lugar de escribir la instrucción, vamos a oprimir la flecha hacia arriba del teclado un par de veces (o las que sean necesarias). En algún punto deberás ver el comando que usaste para crear los tres directorios la primera vez. Una vez que encuentres esa línea pulsa Enter y se volverán a crear. De la misma manera que usar el tabulador (\u003Ccode\u003Etab\u003C\u002Fcode\u003E) para completar automáticamente, el uso de las flechas arriba y abajo para desplazarte por los comandos recientes te ahorrará mucho tiempo. \u003Cstrong\u003EConsidera que no estamos deshaciendo el borrado que hicimos con anterioridad\u003C\u002Fstrong\u003E. Por el contrario, estamos usando un &quot;acceso directo&quot; para ingresar de nuevo un comando que hemos usado recientemente.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"entender-la-estructura-de-árbol-del-sistema-de-archivos-de-tu-computadora\\\"\u003EEntender la estructura de árbol del sistema de archivos de tu computadora\u003C\u002Fh3\u003E\\n\u003Cp\u003EAhora debes tener tres directorios dentro de tu directorio \u003Ccode\u003EdiversionConPowerShell\u003C\u002Fcode\u003E. Desplázate al interior del directorio \u003Ccode\u003Edir\u003C\u002Fcode\u003E (utiliza \u003Ccode\u003Esl dir\u003C\u002Fcode\u003E)\u003C\u002Fp\u003E\\n\u003Cp\u003EEs importante entender la manera en la que tu computadora organiza las cosas. Observa la ruta a tu directorio actual. La ruta es todo lo que escribiste después del \u003Cem\u003Eprompt\u003C\u002Fem\u003E. En mi caso es:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003EC:\\\\Users\\\\Ted\\\\diverionConPowerShell\\\\dir\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003ETu ruta debe verse bastante similiar. Lo que representa esta ruta en realidad es una structura parecida a un árbol que sigue el ordenador para llegar al punto en el que estás. El tronco del árbol es \u003Ccode\u003EC:\u003C\u002Fcode\u003E, que es tu disco duro. En realidad, en la mayoría de las computadoras modernas \u003Ccode\u003EC:\u003C\u002Fcode\u003Ees una partición de su disco duro. ¿Por qué se llama \u003Ccode\u003EC\u003C\u002Fcode\u003E? El ordenador asigna una letra a cada una de las unidades. \u003Ccode\u003EA\u003C\u002Fcode\u003Ey \u003Ccode\u003EB\u003C\u002Fcode\u003Eestán reservados para las dos unidades de disquettes que hace mucho tiempo utilizaban con frecuencia los usuarios para interactuar con los discos duros de sus computadoras. Aunque la mayoría de los ordenadores ya no los tienen, los nombres quedaron reservados.\u003C\u002Fp\u003E\\n\u003Cp\u003ESi \u003Ccode\u003EC:\u003C\u002Fcode\u003E es el tronco del árbol, cada sección de la ruta después de \u003Ccode\u003EC:\u003C\u002Fcode\u003E es una rama, de la cual salen otras que están por encima de ella. Así, \u003Ccode\u003EUsers\u003C\u002Fcode\u003E es una rama de \u003Ccode\u003EC:\u003C\u002Fcode\u003E, \u003Ccode\u003ETed\u003C\u002Fcode\u003E es una rama más pequeña que sale de \u003Ccode\u003EUsers\u003C\u002Fcode\u003E y así sucesivamente. También se puede usar la metáfora de la herencia en lugar de la de la botánica y llamar a cada rama un \u003Ccode\u003Ehijo\u003C\u002Fcode\u003E del directorio por encima de ella. Este es el lenguaje más común para describir las relaciones entre los directorios (de ahí el cmdlet \u003Ccode\u003EGet-ChildItem\u003C\u002Fcode\u003E), pero nos quedaremos con la metáfora del árbol ya que, en la vida real, las relaciones de herencia pueden ser mucho más complejas que la extremadamente jerárquica estructura según la cual está organizada tu computadora.\u003C\u002Fp\u003E\\n\u003Cp\u003EEntender que la ruta funciona como un árbol es importante para poder navegar por los directorios que no están inmediatamente por encima o por debajo de tu directorio actual. Sabemos que hay un directorio llamado &quot;dir1&quot;, y que éste directorio también está en el directorio &quot;diverionConPowerShell&quot;. Ve lo que sucede si intentas usar \u003Ccode\u003Esl\u003C\u002Fcode\u003E para pasar directamente a él escribiendo:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Esl dir1\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003E¡Esto arroja error!\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;intro-to-powershell3.png&quot; caption=&quot;Error por intentar saltar entre ramas&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EEl problema es que intentamos saltar de una rama a otra, y PowerShell sólo entiende nuestro movimiento si nos desplazamos a lo largo del árbol. Eso significa que primero tenemos que movernos hasta donde se encuentran las ramas de &quot;dir1&quot; y &quot;dir&quot;, y luego volver a &quot;dir1&quot;. Puedes hacerlo con un comando. Veamos si puedes imaginarlo antes de leer la siguiente línea.\u003C\u002Fp\u003E\\n\u003Cp\u003EEl comando es:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Esl ..\\\\dir1\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EEsto le indica a PowerShell subir un directorio a \u003Ccode\u003EdiversionConPowerShell\u003C\u002Fcode\u003E, y luego bajar al directorio \u003Ccode\u003Edir1\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"moverse-rápido-con-push-locationpushd-y-pop-location-popd\\\"\u003EMoverse rápido con \u003Ccode\u003EPush-Location\u003C\u002Fcode\u003E(\u003Ccode\u003Epushd\u003C\u002Fcode\u003E) y \u003Ccode\u003EPop-Location\u003C\u002Fcode\u003E (\u003Ccode\u003Epopd\u003C\u002Fcode\u003E)\u003C\u002Fh3\u003E\\n\u003Cp\u003EAntes de trabajar con archivos vamos a probar los comandos \u003Ccode\u003Epush\u003C\u002Fcode\u003Ey \u003Ccode\u003Epopd\u003C\u002Fcode\u003E. Haz lo siguiente: ve hasta el tronco del árbol.\u003Ccode\u003EC:\u003C\u002Fcode\u003E.deben ser cuatro directorios arriba del directorio en el que estás, por lo cual podrías escribir:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Esl ..\\\\..\\\\..\\\\..\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EEntonces cambia de nuevo a \u003Ccode\u003Edir1\u003C\u002Fcode\u003E. Pero en vez de escribir \u003Ccode\u003Esl\u003C\u002Fcode\u003Eantes de la ruta, escribe \u003Ccode\u003Epushd\u003C\u002Fcode\u003E. Como esto:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Epushd users\\\\TUNOMBREDEUSUARIO\\\\diversionConPowerShell\\\\dir1\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EAhora estarás en el directorio como si hubieras escrito \u003Ccode\u003Esl\u003C\u002Fcode\u003E al principio de la ruta. Pero aquí está la parte divertida. Ahora escribe:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Epopd\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EY pulsa Enter. Genial, ¿no? El comando \u003Ccode\u003Epushd\u003C\u002Fcode\u003E indica a PowerShell que se mueva a un directorio determinado desde tu directorio actual al que puedes ser devuelto con \u003Ccode\u003Epopd\u003C\u002Fcode\u003E. En otras palabras, \u003Ccode\u003Epopd\u003C\u002Fcode\u003E siempre te regresará al último directorio en el cual estuviste antes de usar \u003Ccode\u003Epushd\u003C\u002Fcode\u003E. Si quieres entender más sobre lo que está pasando, lee sobre la \u003Ca href=\\\"https:\u002F\u002Fes.wikipedia.org\u002Fwiki\u002FPila_de_llamadas\\\"\u003Epila de llamadas\u003C\u002Fa\u003E en Wikipedia. El uso de \u003Ccode\u003Epushd\u003C\u002Fcode\u003E y \u003Ccode\u003Epopd\u003C\u002Fcode\u003E es muy útil cuando te mueves con frecuencia entre dos directorios.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"trabajar-con-archivos\\\"\u003ETrabajar con archivos\u003C\u002Fh2\u003E\\n\u003Cp\u003EAhora que sabes cómo moverte a través del sistema de archivos de tu computadora desde la línea de comandos, vamos a trabajar manipulando archivos. Comenzaremos por aprender a \u003Cstrong\u003Ecrear\u003C\u002Fstrong\u003E nuevos archivos, \u003Cstrong\u003Ecopiarlos\u003C\u002Fstrong\u003E y \u003Cstrong\u003Emoverlos\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"crear-archivos-con-new-item-ni\\\"\u003ECrear archivos con \u003Ccode\u003ENew-Item\u003C\u002Fcode\u003E (\u003Ccode\u003Eni\u003C\u002Fcode\u003E)\u003C\u002Fh3\u003E\\n\u003Cp\u003EPrimero, necesitamos algunos archivos para trabajar con ellos. Hagamos un nuevo documento de texto plano llamado &quot;ejemplo.txt&quot;. Navega hasta el directorio \u003Ccode\u003EdiversionConPowerShell\u003C\u002Fcode\u003E -utiliza el tabulador para cada nombre de directorio que escribas y acelerar el proceso-, y escribe:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Eni ejemplo.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EPresiona Enter. Después ecribe:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Egci\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003Epara que confirmes, en efecto, que ahora tienes el archivo \u003Ccode\u003Eejemplo.txt\u003C\u002Fcode\u003E además de tus directorios. Necesitaremos varios archivos así que, adelante: crea \u003Ccode\u003Eejemplo1.txt\u003C\u002Fcode\u003E y \u003Ccode\u003Eejemplo2.txt\u003C\u002Fcode\u003E. No te sorprenderá saber que, incluyendo una coma, puedes hacer esto con un solo comando:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Eni ejemplo1.txt, ejemplo2.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"copiar-y-mover-archivos-con-copy-itemcp-y-move-item-mv\\\"\u003ECopiar y mover archivos con \u003Ccode\u003ECopy-Item\u003C\u002Fcode\u003E(\u003Ccode\u003Ecp\u003C\u002Fcode\u003E) y \u003Ccode\u003EMove-Item\u003C\u002Fcode\u003E (\u003Ccode\u003Emv\u003C\u002Fcode\u003E)\u003C\u002Fh3\u003E\\n\u003Cp\u003EQuizá deberíamos haber puesto estos archivos en un directorio. Movámoslos. Pongamos \u003Ccode\u003Eejemplo.txt\u003C\u002Fcode\u003E en \u003Ccode\u003Edir\u003C\u002Fcode\u003E escribiendo:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Emv ejemplo.txt dir\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EAhora escribe \u003Ccode\u003Egci\u003C\u002Fcode\u003E y verás que \u003Ccode\u003Eejemplo.txt\u003C\u002Fcode\u003E ha desaparecido. Entra a \u003Ccode\u003Edir\u003C\u002Fcode\u003E (\u003Ccode\u003Esl dir\u003C\u002Fcode\u003E) y escribe \u003Ccode\u003Egci\u003C\u002Fcode\u003E para que compruebes que ¡ahora está ahí! También puedes hacer esto sin cambiar de directorio escribiendo \u003Ccode\u003Egci dir\u003C\u002Fcode\u003E desde el directorio \u003Ccode\u003EdiversionConPowerShell\u003C\u002Fcode\u003E. Regresa a \u003Ccode\u003EdiversionConPowerShell\u003C\u002Fcode\u003E y mueve \u003Ccode\u003Eejemplo1.txt\u003C\u002Fcode\u003E a \u003Ccode\u003Edir1\u003C\u002Fcode\u003E y \u003Ccode\u003Eejemplo2.txt\u003C\u002Fcode\u003E a \u003Ccode\u003Edir2\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003ETambién podemos utilizar \u003Ccode\u003Emv\u003C\u002Fcode\u003E para \u003Cstrong\u003Erenombrar\u003C\u002Fstrong\u003E ítems. Usa \u003Ccode\u003Esl\u003C\u002Fcode\u003E para moverte a \u003Ccode\u003Edir\u003C\u002Fcode\u003E. Escribe \u003Ccode\u003Egci\u003C\u002Fcode\u003E y deberás ver tu archivo \u003Ccode\u003Eejemplo.txt\u003C\u002Fcode\u003E. Es un nombre aburrido, así que llamémosle \u003Ccode\u003Ebenjamin.txt\u003C\u002Fcode\u003E. Escribe:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Emv ejemplo.txt benjamin.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EUtiliza \u003Ccode\u003Egci\u003C\u002Fcode\u003E de nuevo para confirmnar que tu documento ahora se llama \u003Ccode\u003Ebejamin.txt\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003ETe sorprenderá que el mismo \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E se utiliza tanto para mover como para renombrar archivos. De hecho, la operación es la misma. En ambos casos le estás diciendo a la computadora que cambie el &quot;nombre&quot; de la ubicación del archivo, es decir, que cambie la \u003Cstrong\u003Eruta\u003C\u002Fstrong\u003E que sigue para encontrar el archivo. En el primer ejemplo, la ruta comenzó como:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003EC:\\\\Users\\\\Ted\\\\diversionConPowerShell\\\\ejemplo.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EY luego cambió a:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003EC:\\\\Users\\\\Ted\\\\diversionConPowerShell\\\\dir\\\\ejemplo.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EEn el segundo ejemplo, la ruta cambió de:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003EC:\\\\Users\\\\Ted\\\\diversionConPowerShell\\\\dir\\\\ejemplo.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003Ea:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003EC:\\\\Users\\\\Ted\\\\diversionConPowerShell\\\\dir\\\\benjamin.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EDicho de otro modo, en ambos ejemplos \u003Ccode\u003Emv\u003C\u002Fcode\u003E solamente cambia la ruta. No te preocupes si esto no te hace sentido por ahora. Sólo ten cuidado de escribir correctamente las rutas cuando utilices \u003Ccode\u003Emv\u003C\u002Fcode\u003E porque, si no lo haces, puedes cambiar el nombre cuando lo que quieres es mover el archivo, o viceversa.\u003C\u002Fp\u003E\\n\u003Cp\u003EAdemás de mover archivos, también quisiéramos copiarlos o eliminarlos. Para copiar archivos, utilizamos el \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E \u003Ccode\u003ECopy-Item\u003C\u002Fcode\u003E o\u003Ccode\u003E cp\u003C\u002Fcode\u003E. Hagamos dos copias de \u003Ccode\u003Ebenjamin.txt\u003C\u002Fcode\u003E y llamémoslas \u003Ccode\u003Esteven.txt\u003C\u002Fcode\u003E y \u003Ccode\u003Esusie.txt\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Ecp benjamin.txt steven.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Ecp benjamin.txt susie.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003ETambién podemos eliminar estos dos nuevos archivos con \u003Ccode\u003Erm\u003C\u002Fcode\u003E, al igual que hicimnos con los directorios. Intenta hacerlo con un solo comando. Como siempre, ten cuidado cuando utilices \u003Ccode\u003Erm\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EÉste es el comando:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Erm steven.txt, susie.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003E¡Adiós Steven y Susie!\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;intro-to-powershell4.png&quot; caption=&quot;Mover, copiar y borrar&quot; %}\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"haciendo-más\\\"\u003EHaciendo más\u003C\u002Fh1\u003E\\n\u003Cp\u003EBien, ahora ya podemos navegar, crear archivos, moverlos y borrarlos en PowerShell. Nos sentimos muy bien, muy \u003Cem\u003Egeeks\u003C\u002Fem\u003E porque podemos hacer estas cosas desde la línea de comandos. Pero esto no es realmente útil ya que podíamos hacer estas cosas muy fácilmente con la interfaz gráfica de usuario. Ahora que sabemos estos fundamentos, sin embargo, podemos comenzar a aprender comandos algo más complejos que pueden ser útiles en nuestro trabajo como humanistas digitales.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"escribir-en-archivos-con-write-output-write-echo-y-redirección\\\"\u003EEscribir en archivos con \u003Ccode\u003EWrite-Output\u003C\u002Fcode\u003E (\u003Ccode\u003Ewrite\u003C\u002Fcode\u003E, \u003Ccode\u003Eecho\u003C\u002Fcode\u003E) y redirección\u003C\u002Fh3\u003E\\n\u003Cp\u003ETenemos un archivo vacío en nuestro directorio \u003Ccode\u003Edir\u003C\u002Fcode\u003E. Eso no es muy interesante, así que vamos a añadir un poco de contenido. Podríamos abrir el archivo en el Bloc de notas y modificarlo de esa manera. Pero también podemos añadirle contenido con órdenes desde la línea de comandos. El \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E que utilizamos para esto es \u003Ccode\u003EWrite-Output\u003C\u002Fcode\u003E, o simplemente \u003Ccode\u003Ewrite\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EPrueba con esto:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Ewrite &quot;La técnica de la reproducción separa el objeto reproducido del dominio de la tradición.&quot;\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EPowerShell debe imprimir esta frase directamente en la ventana de la línea de comandos. Eso es todo lo que hace \u003Ccode\u003Ewrite\u003C\u002Fcode\u003E. Le dice a PowerShell &quot;Imprime lo que yo escriba&quot;. Eso no es muy útil dado que queremos poner este texto en nuestro documento. Para ello, usaremos algo llamado \u003Cstrong\u003Eredirección\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003ERedirección es una forma de decirle a PowerShell que tome los resultados de un comando y los coloque en algún lugar que no sea en la ventana de PowerShell. Para redirigir un comando, ponemos un paréntesis angular derecho (\u003Ccode\u003E&gt;\u003C\u002Fcode\u003E) entre el comando y el lugar donde queremos que vaya su salida. En este caso, queremos que la salida de nuestro comando \u003Ccode\u003Ewrite\u003C\u002Fcode\u003E termine en\u003Ccode\u003E benjamin.txt\u003C\u002Fcode\u003E. Así que usamos la flecha hacia arriba para recuperar la declaración, y añadimos \u003Ccode\u003E&gt; benjamin.txt\u003C\u002Fcode\u003E al final. Todo el asunto debería ser así:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Ewrite &quot;La técnica de la reproducción separa el objeto reproducido del dominio de la tradición.&quot; &gt; benjamin.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003ECuando presiones Enter parecerá que nada sucede. Esto se debe a que la instrucción \u003Ccode\u003Ewrite\u003C\u002Fcode\u003E fue redirigida. Para ver qué es lo que realmente ocurrió, usa \u003Ccode\u003Egci\u003C\u002Fcode\u003E para ver el contenido de tu directorio. Ten en cuenta que la longitud de \u003Ccode\u003Ebenjamin.txt\u003C\u002Fcode\u003E ya no es 0. ¡Esto es porque acabamos de poner texto en él!\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"leer-archivos-con-get-content-gc-cat\\\"\u003ELeer archivos con \u003Ccode\u003EGet-Content\u003C\u002Fcode\u003E (\u003Ccode\u003Egc\u003C\u002Fcode\u003E, \u003Ccode\u003Ecat\u003C\u002Fcode\u003E)\u003C\u002Fh3\u003E\\n\u003Cp\u003EYa que \u003Ccode\u003Egci\u003C\u002Fcode\u003E nos muestrta que hay algo en el archivo, sería bueno poder ver qué frase pusimos en él. Podríamos hacerlo con el comando: \u003Ccode\u003Enotepad benjamin.txt\u003C\u002Fcode\u003E, lo que abriría el documento en el Bloc de notas. Pero también hay un \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E para imprimir el contenido del archivo en PowerShell que se llama \u003Ccode\u003EGet-Content\u003C\u002Fcode\u003E. Escribe:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Egc benjamin.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003E¡Y ahí está tu frase!\u003C\u002Fp\u003E\\n\u003Cp\u003EUstilizar \u003Ccode\u003Egc\u003C\u002Fcode\u003E es útil por sí mismo, pero no resulta tan interesante. Si lo combinamos con la redirección, podemos hacer mucho más. Para empezar, podemos poner el contenido de un archivo en otro, casi igual que copiar un archivo. Ya sabes cómo hacerlo con \u003Ccode\u003Ecp\u003C\u002Fcode\u003E. Haz una copia de \u003Ccode\u003Ebenjamin.txt\u003C\u002Fcode\u003E llamada \u003Ccode\u003Ebenjamin1.txt\u003C\u002Fcode\u003E usando \u003Ccode\u003Ecp\u003C\u002Fcode\u003E. Ese comando se verá así:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Ecp benjamin.txt benjamin1.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EAhora haz un archivo \u003Ccode\u003Ebenjamin2.txt\u003C\u002Fcode\u003E con el mismo contenido que\u003Ccode\u003E benjamin.txt\u003C\u002Fcode\u003E, pero usando \u003Ccode\u003Egc\u003C\u002Fcode\u003E y redirección. Intenta averiguar cómo se hace.\u003C\u002Fp\u003E\\n\u003Cp\u003EEn caso de que no lo logres, aquí está la respuesta:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Egc benjamin.txt &gt; benjamin2.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EPor supuesto que esto es solamente una forma más engorrosa de hacer lo que ya podemos hacer con \u003Ccode\u003Ecp\u003C\u002Fcode\u003E. Pero la diferencia en estos métodos es sustancial porque al usar \u003Ccode\u003Egc\u003C\u002Fcode\u003E podemos agregar información a un archivo de texto sin reemplazar lo que ya está allí, y también podemos obtener el contenido de varios archivos de texto y ponerlos en otro.\u003C\u002Fp\u003E\\n\u003Cp\u003EEn primer lugar vamos a aprender a adjuntar. Necesitamos algo que añadir a texto así que hagamos un nuevo archivo llamado \u003Ccode\u003Esiguiente.txt\u003C\u002Fcode\u003E y escribamos la frase &quot;Haciendo muchas reproducciones sustituye una pluralidad de copias para una existencia única.&quot; Podríamos hacer nuestro archivo primero con \u003Ccode\u003Eni\u003C\u002Fcode\u003E, pero no es necesario. Si le decimos a PowerShell que escriba en un archivo que no está en tu directorio, lo creará para nosotros. Así podemos simplemente escribir:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Ewrite &quot;Haciendo muchas reproducciones sustituye una pluralidad de copias para una existencia única.&quot; &gt; siguiente.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EUtiliza \u003Ccode\u003Egc\u003C\u002Fcode\u003Epara comprobar que se creó \u003Ccode\u003Esiguiente.txt\u003C\u002Fcode\u003E y que es realmente lo que queremos que sea.\u003C\u002Fp\u003E\\n\u003Cp\u003EAhora vamos a agregar el contenido de \u003Ccode\u003Esiguiente.txt\u003C\u002Fcode\u003E a \u003Ccode\u003Ebenjamin.txt\u003C\u002Fcode\u003E usando \u003Ccode\u003Egc\u003C\u002Fcode\u003Ey redirección. Parece simple, ¿verdad? Inténtalo con este comando:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Egc siguiente.txt &gt; benjamin.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003ELuego comprueba lo que sucedió con el comando \u003Ccode\u003Egc benjamin.txt\u003C\u002Fcode\u003E. Verás que efectivamente pusiste el contenido de \u003Ccode\u003Esiguiente.txt\u003C\u002Fcode\u003E en\u003Ccode\u003E benjamin.txt\u003C\u002Fcode\u003E, pero has \u003Cem\u003Ereemplazado\u003C\u002Fem\u003E el contenido que ya estaba allí y ¡esto no es lo que queríamos hacer!\u003C\u002Fp\u003E\\n\u003Cp\u003EAl usar \u003Ccode\u003E&gt;\u003C\u002Fcode\u003E, le ordenamos a PowerShell que pusiera el contenido de un texto en otro y sobrescribió lo que ya estaba allí. Podemos arreglar esto usando \u003Ccode\u003E&gt;&gt;\u003C\u002Fcode\u003E para nuestro redireccionamiento en lugar de un solo \u003Ccode\u003E&gt;\u003C\u002Fcode\u003E. Esto le dice a PowerShell que agregue la nueva información. Prueba esto:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Egc siguiente.txt &gt;&gt; benjamin1.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EUtiliza \u003Ccode\u003Egc\u003C\u002Fcode\u003E para comprobar que \u003Ccode\u003Ebenjamin1.text\u003C\u002Fcode\u003E ahora tiene ambas frases.\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;intro-to-powershell5.png&quot; caption=&quot;La diferencia entre \u003Ccode\u003E&gt;\u003C\u002Fcode\u003E y \u003Ccode\u003E&gt;&gt;\u003C\u002Fcode\u003E&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EAhora veamos cómo obtener el contenido de varios archivos al mismo tiempo.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"trabajar-con-varios-archivos-a-la-vez-usando-caracteres-comodín-\\\"\u003ETrabajar con varios archivos a la vez usando caracteres comodín (\u003Ccode\u003E*\u003C\u002Fcode\u003E)\u003C\u002Fh3\u003E\\n\u003Cp\u003EAhora debes tener cuatro archivos en tu directorio, cada uno con una o dos frases del ensayo sobre el arte de Walter Benjamin. Es posible que hayas perdido la pista de lo que está exactamente en ellos. Utilicemos \u003Ccode\u003Egc\u003C\u002Fcode\u003E para comprobar el contenido.\u003C\u002Fp\u003E\\n\u003Cp\u003EPodríamos ver cada uno individualmente. Pero como puedes haber adivinado se puede mostrar el contenido de los cuatro archivos con un solo comando. Escribe:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Egc benjamin.txt, benjamin1.txt, benjamin2.txt, siguiente.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003Ey obtendrás la frase impresa tres veces. Podemos hacerlo aún más rápidamente. Inténtalo:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Egc *.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EEl resultado será exactamente el mismo. Lo que hace \u003Ccode\u003E*.txt\u003C\u002Fcode\u003E es decirle a PowerShell que encuentre todo lo que termine con \u003Ccode\u003E.txt\u003C\u002Fcode\u003E. El \u003Ccode\u003E*\u003C\u002Fcode\u003E se llama \u003Cstrong\u003Ecomodín\u003C\u002Fstrong\u003E, y se puede usar para reemplazar cualquier parte de un nombre de archivo. Escribe \u003Ccode\u003Egc ben*\u003C\u002Fcode\u003E y obtendrás sólo los textos que comiencen con &quot;ben&quot;. Dado que los únicos archivos de este directorio son los cuatro que queremos, puedes incluso escribir \u003Ccode\u003Egc *\u003C\u002Fcode\u003E y obtener el contenido que nos interesa haciendo que PowerShell juestre todo lo que está en el directorio.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"búsquedas-con-select-string-sls\\\"\u003EBúsquedas con \u003Ccode\u003ESelect-String\u003C\u002Fcode\u003E (\u003Ccode\u003Esls\u003C\u002Fcode\u003E)\u003C\u002Fh3\u003E\\n\u003Cp\u003EPor supuesto que no siempre queremos ver todo el contenido sino que querramos encontrar contenido específico. Al utilizar \u003Ccode\u003E*\u003C\u002Fcode\u003E, podemos buscar varios archivos al mismo tiempo. Una de nuestras oraciones tenía algo acerca de &quot;existencia única&quot;, ¿no? ¿Donde fue eso? Podemos usar el \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E \u003Ccode\u003ESelect-String\u003C\u002Fcode\u003E para buscar fragmentos específicos de texto. Escribe:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Esls &quot;existencia única&quot; *.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003Ey PowerShell arrojará todas las líneas que contengan esa cadena de caracteres de cualquier archivo de nuestro directorio que termine en \u003Ccode\u003E.txt\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EEl uso de \u003Ccode\u003Esls\u003C\u002Fcode\u003E en archivos tan pequeños como los nuestros no nos ahorrará mucho tiempo comparado con el que ocuparíamos si leyéramos los archivos nosotros mismos. Pero el uso de este \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E con un mayor número de archivos, más largos, puede ser extraordinariamente útil.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"bucles-infinitos-y-abortar-procesos-con-control-c\\\"\u003EBucles infinitos y abortar procesos con \u003Ccode\u003Econtrol-c\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\\n\u003Cp\u003EVeamos una tarea más útil que podemos lograr combinando \u003Ccode\u003Egc\u003C\u002Fcode\u003E, comodines y redirección. Supongamos que tenemos muchos archivos diferentes que queremos combinar en un nuevo archivo, por ejemplo, porque hemos descargado cientos de letras de canciones que necesitamos analizar y  agrupar las de un solo artista en un archivo único. Aunque podríamos hacer esto especificándolos todos, es decir, \u003Ccode\u003Egc texto1, texto2, texto3&gt; nuevotexto\u003C\u002Fcode\u003E, al tener cientos de textos puede resultar una tarea bastante engorrosa. Los comodines sirven para evitar esto.\u003C\u002Fp\u003E\\n\u003Cp\u003EVamos a concatenar nuestros cuatro textos y colocar el resultado en un quinto texto. Quizá usar \u003Ccode\u003E*.txt\u003C\u002Fcode\u003E puede parecer un auxiliar práctico. \u003Cstrong\u003EEstamos a punto de hacer algo tonto, así que por favor, lee el siguiente párrafo antes de escribir este comando!\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EIntentemos\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Egc *.txt &gt; granben.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EParecerá que tu computadora no hace nada. Pero, a diferencia de otras veces cuando tu computadora aparenta que no ha hecho nada, esta vez el prompt del símbolo del sistema no vuelve a aparecer. Si intentas escribir otro comando no sucederá nada. Esto es porque PowerShell todavía está trabajando en tu último comando. A medida que haces más y más cosas complicadas con PowerShell, es algo que a veces sucede -¡estás haciendo sudar a tu computadora!-. Pero, en este caso, PowerShell nunca dejará de trabajar con este comando ya que está en un bucle infinito. Afortunadamente, puedes abortar esta tarea con:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Econtrol-c\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003ELa utilidad de \u003Ccode\u003Econtrol-c\u003C\u002Fcode\u003E es grande, ya que a veces puedes quedar atrapado accidentalmente en un bucle infinito o, simplemente, puedes hartarte de esperar a que tu computadora haga ciertas tareas extremadamente largas.\u003C\u002Fp\u003E\\n\u003Cp\u003E¿Cómo nos quedamos atrapados en ese bucle? Le dijimos a PowerShell que pusiera todos los archivos que terminaran en \u003Ccode\u003E.txt\u003C\u002Fcode\u003E en un nuevo archivo que terminara en \u003Ccode\u003E.txt\u003C\u002Fcode\u003E. Dado que ese nuevo archivo caía bajo la rúbrica de archivos que el equipo debía concatenar y agregar a \u003Ccode\u003Egranben.txt\u003C\u002Fcode\u003E, lo añadió. Y luego, ya que tenía un archivo \u003Ccode\u003E.txt\u003C\u002Fcode\u003E con nuevo contenido, lo añadió también. Este es un excelente ejemplo de algo que a menudo olvidamos sobre nuestras computadoras: no son inteligentes. Son extremadamente potentes pero carecen absolutamente de sentido común. Los humanos miramos las instrucciones e intentamos interpretarlas. &quot;No puede significar, para mí, agregar el contenido del texto final de nuevo en sí mismo una y otra vez para siempre.&quot; Los ordenadores, por otro lado, hacen exactamente lo que les decimos, sin importar lo ilógicos que sean nuestros mandamientos. A medida que adquieras experiencia trabajando con la línea de comandos, te sentirás desconcertado por las interpretaciones excesivamente literales de sus comandos, pero también aprenderán a darle instrucciones que puede seguir. Los bucles infinitos deben evitarse a toda costa, pero se producirán, y cuando lo hagan, recuerda: \u003Ccode\u003Econtrol-c\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"especificación-de-cmdlets-con-parámetros\\\"\u003EEspecificación de \u003Cem\u003Ecmdlets\u003C\u002Fem\u003E con parámetros\u003C\u002Fh3\u003E\\n\u003Cp\u003EHemos visto que tu computadora necesita que le digan cosas de manera muy exacta. Afortunadamente, PowerShell proporciona métodos para refinar los \u003Cem\u003Ecmdlets\u003C\u002Fem\u003E añadiendo parámetros.\u003C\u002Fp\u003E\\n\u003Cp\u003EVeamos un ejemplo: utiliza \u003Ccode\u003Egci\u003C\u002Fcode\u003E para comprobar que tienes cinco archivos en tu directorio. Uno de ellos, \u003Ccode\u003Egranben.txt\u003C\u002Fcode\u003E, es muy grande. Escribe:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Egc granben.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EPowerShell comenzará a descargar una cantidad excesiva de texto en la pantalla. Es posible que quieras interrumpir el proceso con \u003Ccode\u003Econtrol-c\u003C\u002Fcode\u003E, pero esto no es un bucle infinito, sólo se trasta de un archivo muy grande, por lo que puedes esperar a que todo se imprima, sólo que tardará un tiempo. Al final, puedes usar el \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E \u003Ccode\u003Eclear\u003C\u002Fcode\u003E si te molesta el gran bloque de texto en la pantalla.\u003C\u002Fp\u003E\\n\u003Cp\u003ELo que queremos comprobar es que &quot;granben.txt&quot; está compuesto por las líneas de los otros textos, repetidas una y otra vez. Podemos hacer esto mirando sólo al principio y al final, y para ello, agregamos un \u003Cstrong\u003Eparámetro\u003C\u002Fstrong\u003E a nuestro \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EIntroduce esto:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Egc granben.txt -totalcount 10\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EVerás las primeras 10 líneas de tu texto. Asegúrate de incluir el guión, ya que de lo contrario PowerShell no sabrá que \u003Ccode\u003E-TotalCount\u003C\u002Fcode\u003E es un parámetro. Ahora escribe:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Egc granben.txt -tail 10\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003Ey verás las últimas 10 líneas. Lo que hemos hecho es especificarle a nuestro \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E \u003Ccode\u003Egc\u003C\u002Fcode\u003E los parámetros \u003Ccode\u003E-totalcount\u003C\u002Fcode\u003E y \u003Ccode\u003E-tail\u003C\u002Fcode\u003E. Casi todos los \u003Cem\u003Ecmdlets\u003C\u002Fem\u003E pueden ser refinados añadiendo parámetros como este. Pero, ¿cómo sabemos qué parámetros están disponibles?\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"más-información-sobre-get-help\\\"\u003EMás información sobre \u003Ccode\u003EGet-Help\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\\n\u003Cp\u003EPowerShell no espera que memorices todos los parámetros posibles para todos los \u003Cem\u003Ecmdlets\u003C\u002Fem\u003E^. En su lugar, proporciona una forma sencilla de enumerarlos utilizando el \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E \u003Ccode\u003EGet-Help\u003C\u002Fcode\u003E. Escribe\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003EGet-Help gc\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003Ey obtendrás una pantalla que se ve así:\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;intro-to-powershell6.png&quot; caption=&quot;Páginas de ayuda de \u003Ccode\u003EGet-Content\u003C\u002Fcode\u003E&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003ETu página puede ser ligeramente distinta, pero la parte importante para mirar en este momento es la sección llamada &quot;SYNTAX&quot;. Esta nos muestra todos los parámetros que podemos agregar a \u003Ccode\u003EGet-Content\u003C\u002Fcode\u003E. Si estás tratando de recordar el nombre exacto de un parámetro que has utilizado antes, esta ayuda será suficiente. Sin embargo, no nos dice lo que realmente hacen los parámetros.\u003C\u002Fp\u003E\\n\u003Cp\u003EAfortunadamente, el mismo \u003Ccode\u003EGet-Help\u003C\u002Fcode\u003E tiene parámetros y, agregando \u003Ccode\u003E-online\u003C\u002Fcode\u003E al \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E \u003Ccode\u003EGet-Help\u003C\u002Fcode\u003E, le indicas a PowerShell que pida a tu navegador abrir una página en el portal TechNet de Microsoft que explica todos los parámetros (en inglés). Escribe:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003EGet-Help gc -online\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;intro-to-powershell7.png&quot; caption=&quot;La página de ayuda en línea para \u003Ccode\u003EGet-Content\u003C\u002Fcode\u003E&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EAhí podemos ver la descripción completa de los parámetros \u003Ccode\u003E-TotalCount\u003C\u002Fcode\u003E y \u003Ccode\u003E-Tail\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"solución-del-problema-de-bucle-infinito-con-el-parámetro--exclude\\\"\u003ESolución del problema de bucle infinito con el parámetro \u003Ccode\u003E-exclude\u003C\u002Fcode\u003E\u003C\u002Fh3\u003E\\n\u003Cp\u003EObserva de nuevo la ayuda de \u003Ccode\u003EGet-Content\u003C\u002Fcode\u003E y verás que uno de los parámetros es \u003Ccode\u003E-exclude\u003C\u002Fcode\u003E. Esto suena prometedor para tratar con nuestro problema del bucle infinito. La descripción en línea dice: Omite los elementos especificados. El valor de este parámetro califica el parámetro de \u003Cstrong\u003Eruta\u003C\u002Fstrong\u003E. Introduzca un elemento o patrón de ruta, como &quot;*.txt&quot;. Los comodines están permitidos.&quot; El &quot;parámetro de ruta&quot; es, normalmente, lo que escribes inmediatamente después de tu \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E. Indica a PowerShell dónde se va a aplicar el \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E. Cuando escribimos \u003Ccode\u003Egc benjamin.txt\u003C\u002Fcode\u003E, \u003Ccode\u003Ebenjamin.txt\u003C\u002Fcode\u003E es la ruta. En realidad, es una abreviatura de \u003Ccode\u003E.\\\\Benjamin.txt\u003C\u002Fcode\u003E, que a su vez es una abreviatura de \u003Ccode\u003EC:\\\\Users\\\\TUNOMBREDEUSUARIO\\\\diversionConPowerShell\\\\dir\\\\benjamin.txt\u003C\u002Fcode\u003E. Esa línea le dice a su computadora el camino a seguir a través de la estructura de tu sistema de archivos, similar a la de un árbol, para encontrar el archivo que deseas. Entonces, lo que la ayuda nos está diciendo es que podemos omitir elementos específicos de nuestro \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E \u003Ccode\u003Egc\u003C\u002Fcode\u003E añadiendo el parámetro \u003Ccode\u003E-exclude\u003C\u002Fcode\u003E y luego ingresando la ruta que queremos que excluya. Podemos utilizar esto para tomar el contenido de todos nuestros archivos \u003Ccode\u003E.txt\u003C\u002Fcode\u003E y ponerlos en un nuevo archivo sin crear un bucle infinito. Trata de averiguar qué escribir, utilizando lo que hicimos con \u003Ccode\u003E-totalcount\u003C\u002Fcode\u003E y\u003Ccode\u003E -tail\u003C\u002Fcode\u003E como referencia.\u003C\u002Fp\u003E\\n\u003Cp\u003EEsto es lo que yo hice. Primero eliminé mi \u003Ccode\u003Egranben.txt\u003C\u002Fcode\u003E actual con \u003Ccode\u003Erm\u003C\u002Fcode\u003E. Aunque esto no es realmente necesario, ya que al usar un solo \u003Ccode\u003E&gt;\u003C\u002Fcode\u003E en el rediccionamiento reemplazaría el contenido actual de todos modos, pero es agradable tener un inicio limpio. Entonces escribí:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Egc *.txt -exclude granben.txt &gt; granben.txt\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EVoilà!\u003C\u002Fp\u003E\\n\u003Cp\u003EA lo largo de este proceso, hemos estado agregando textos juntos o concatenándolos. Puedes obtener más información sobre \u003Ca href=\\\"https:\u002F\u002Fes.wikipedia.org\u002Fwiki\u002FConcatenaci%C3%B3n\\\"\u003Econcatenación en Wikipedia\u003C\u002Fa\u003E, y si quieres ver algunos ejemplos más de concatenación usando PowerShell, echa un vistazo a esta \u003Ca href=\\\"https:\u002F\u002Fblogs.technet.microsoft.com\u002Fheyscriptingguy\u002F2014\u002F07\u002F15\u002Fkeep-your-hands-clean-use-powershell-to-glue-strings-together\\\"\u003Eentrada de blog\u003C\u002Fa\u003E (en inglés), que te llevará al maravilloso mundo de las variables, algo más allá del alcance de este tutorial, pero acerca de las que vale la pena aprender.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"obtener-más-provecho-de-los-cmdlets-con-piping\\\"\u003EObtener más provecho de los \u003Cem\u003Ecmdlets\u003C\u002Fem\u003E con Piping\u003C\u002Fh3\u003E\\n\u003Cp\u003ETenemos ahora cinco documentos en nuestro directorio. Con el fin de poder hacer cosas realmente útiles con ellos necesitamos una herramienta más: \u003Cstrong\u003Ecanalización\u003C\u002Fstrong\u003E. Ésta es una especie de redirección, pero en lugar de decirle a PowerShell que coloque los resultados de un \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E en otro lugar, le dice que tome la salida de un \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E y lo use como entrada para otro. Donde usamos \u003Ccode\u003E&gt;\u003C\u002Fcode\u003E para la redirección, para las canalizaciones usamos \u003Ccode\u003E|\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EVamos a obtener aún mayor rendimiento de \u003Ccode\u003Egc\u003C\u002Fcode\u003E, canalizando los resultados al \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E \u003Ccode\u003Emeasure-object\u003C\u002Fcode\u003E (o simplemente \u003Ccode\u003Emeasure\u003C\u002Fcode\u003E). Este último \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E tiene varias propiedades. Para nuestro propósito, lo usaremos para obtener el número de líneas, palabras y caracteres en nuestros archivos agregando los parámetros \u003Ccode\u003E-line\u003C\u002Fcode\u003E,\u003Ccode\u003E -word\u003C\u002Fcode\u003E y \u003Ccode\u003E-character\u003C\u002Fcode\u003E, o simplemente\u003Ccode\u003E -l\u003C\u002Fcode\u003E, \u003Ccode\u003E-w\u003C\u002Fcode\u003E, \u003Ccode\u003E-c\u003C\u002Fcode\u003E. (Con los parámetros, sólo necesitas escribir el nombre adecuado para identificar el parámetro en cuestión. Utiliza \u003Ccode\u003EGet-Help\u003C\u002Fcode\u003E para averiguar cuál será para un determinado \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E).\u003C\u002Fp\u003E\\n\u003Cp\u003EEscribe esto:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Egc benjamin.txt | measure -l -w -c\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003ELo que debes obtener es un recuento de las líneas, palabras y caracteres del texto. Por supuesto, podrías hacer esto fácilmente con tu procesador de textos. Sin embargo, el poder que te da trabajar en línea de comandos es el de ser capaz de manipular muchas cosas a la vez y especificar lo que quieres hacer con mucha mayor precisión. En este ejemplo significa que podemos contar palabras en varios de nuestros archivos a la vez, y que podemos agregar parámetros adicionales para especificar exactamente cómo queremos contarlos.\u003C\u002Fp\u003E\\n\u003Cp\u003EObtén el recuento de líneas, palabras y caracteres de todos los archivos en el directorio. No debería sorprendernos que el comodín (\u003Ccode\u003E*\u003C\u002Fcode\u003E) pueda ser también de gran ayuda. Por ejemplo, puedes escribir:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Egc *.txt | measure -l -w -c\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003ECon nuestros cinco pequeños archivos esto todavía no resulta muy vistoso, pero habrías perdido más tiempo usando el procesador de textos. También podríamos hacerlo con un directorio que contenga miles de archivos largos. También podemos controlar nuestras acciones con mayor precisión con parámetros adicionales. Utiliza \u003Ccode\u003EGet-Help measure\u003C\u002Fcode\u003E para ver los parámetros a tu disposición. Podríamos ir a la ayuda en línea para aprender más sobre ellos, pero por ahora vamos a usar uno que se explica por sí mismo como un ejemplo que consiste en ignorar los espacios en blanco: \u003Ccode\u003E-IgnoreWhiteSpace\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EUtiliza la flecha hacia arriba para recuperar tu último comando y agrega \u003Ccode\u003E-ignorewhitespace\u003C\u002Fcode\u003E al final. También puedes escribir \u003Ccode\u003E-ig\u003C\u002Fcode\u003E. Ten en cuenta que \u003Ccode\u003E-i\u003C\u002Fcode\u003E solo no es suficiente, ya que no diferencia el parámetro \u003Ccode\u003E-IgnoreWhiteSpace\u003C\u002Fcode\u003E del parámetro \u003Ccode\u003E-InputObject\u003C\u002Fcode\u003E, como te lo indicará un útil mensaje de error si lo intentarás. Verás el mismo recuento pero con menos caracteres, porque esta vez PowerShell no contó los espacios. La ventaja de la precisión es clara sobre el uso de un procesador de textos, donde es difícil determinar si se ignora o no el espacio en blanco en primer lugar, dejando de lado las posibilidades de cambiar funciones según tus necesidades.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"utilización-de-herramientas-de-línea-de-comandos-y-ejecución-de-secuencias-de-comandos-en-python\\\"\u003EUtilización de herramientas de línea de comandos y ejecución de secuencias de comandos en Python\u003C\u002Fh2\u003E\\n\u003Cp\u003ELa razón más importante para familiarizarse con el uso de la línea de comandos no es la mayor precisión o capacidad para trabajar con archivos, si bien estas características son útiles. Su importancia radica en que permite el acceso a muchas herramientas adicionales, como se mencionó en la introducción. Cuando se configura PowerShell para trabajar con algunas de estas herramientas, puede tener problemas ya que, a veces, Windows dispone las rutas incorrectamente. La solución a este problema requiere de una configuración correcta de las \u003Ca href=\\\"https:\u002F\u002Fes.wikipedia.org\u002Fwiki\u002FVariable_de_entorno\\\"\u003Evariables de entorno\u003C\u002Fa\u003E, un tema que va más allá del alcance de este tutorial. Afortunadamente, hay mucha infortmación disponible en línea y con un poco de búsqueda darás con la solución que necesitas. Debido a que muchas lecciones de \u003Cem\u003EThe Programming Historian\u003C\u002Fem\u003E en español requieren que utilices Python, echaremos un vistazo brevemente a la configuración para Python. Una vez hecho esto, estarás menos intimidado por las instrucciones para establecer variables de entorno para otros programas.\u003C\u002Fp\u003E\\n\u003Cp\u003ESi aún no tienes Python, o si te preguntas por qué deberías usarlo, consulta el \u003Ca href=\\\"\u002Fes\u002Flecciones\u002Fintroduccion-e-instalacion\\\"\u003Etutorial de Python\u003C\u002Fa\u003E aquí en \u003Cem\u003EThe Historian\u003C\u002Fem\u003E en español. En dicho tutorial, aprenderás a configurar Python para ejecutar secuencias de comandos directamente en un editor de texto. Pero, generalmente, será muy útil poder ejecutar \u003Cem\u003Escripts\u003C\u002Fem\u003E desde la línea de comandos. Para ello, necesitamos establecer una variable de entorno. Primero, necesitas saber el nombre del directorio donde Python está instalado en tu computadora. Introduce \u003Ccode\u003Esl C:\\\\\u003C\u002Fcode\u003E y luego utiliza \u003Ccode\u003Egci\u003C\u002Fcode\u003E. Deberías ver un directorio llamado &quot;Python&quot; con el número de versión al final. En mi computadora, el directorio es &quot;Python27&quot;. Ahora le ordenamos a Windows que cree una variable de ruta (\u003Cem\u003EPath\u003C\u002Fem\u003E) que apunte a ese directorio introduciendo esto en PowerShell, reemplazando &quot;Python27&quot; por el nombre del directorio en tu computadora:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003E[Environment]::SetEnvironmentVariable(&quot;Path&quot;, &quot;$env:Path;C:\\\\Python27&quot;, &quot;User&quot;)\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EEsto le dice a Windows: &quot;Oye, la ruta para Python es: C:\\\\Python27&quot;. Si quieres entender exactamente cómo funciona esto, mira \u003Ca href=\\\"https:\u002F\u002Ftechnet.microsoft.com\u002Fen-us\u002Flibrary\u002Fff730964.aspx\\\"\u003Eesta página\u003C\u002Fa\u003E (en inglés) en el portal TechNet de Microsoft (el mismo portal que utilizas en línea con \u003Ccode\u003EGet-Help\u003C\u002Fcode\u003E).\u003C\u002Fp\u003E\\n\u003Cp\u003EUna vez que hayas corrido el comando anterior, sal de PowerShell y vuelve a iniciarlo. Entonces deberías poder abrir el intérprete de Python escribiendo \u003Ccode\u003Epython\u003C\u002Fcode\u003E en PowerShell. Para ejecutar \u003Cem\u003Escripts\u003C\u002Fem\u003E, simplemente escribe \u003Ccode\u003Epython\u003C\u002Fcode\u003E seguido de la ruta del \u003Cem\u003Escript\u003C\u002Fem\u003E que quieres. Es más fácil navegar primero al directorio que contiene el \u003Cem\u003Escript\u003C\u002Fem\u003E, y luego simplemente escribir \u003Ccode\u003Epython nombre-de-script.py\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EAhora ya estás preparado para ejecutar \u003Cem\u003Escripts\u003C\u002Fem\u003E de Python desde la línea de comandos.\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"conclusión\\\"\u003EConclusión\u003C\u002Fh1\u003E\\n\u003Cp\u003EEn este tutorial has aprendido algunos de los conceptos básicos para trabajar con PowerShell, la interfaz de línea de comandos de Windows. Ya sabes lo suficiente para usar PowerShell para muchas de las tareas cotidianas que haces en tu computadora y yo recomendaría usarlo para eso. Al principio puede resultar más difícil copiar un archivo y moverlo a un nuevo directorio desde la línea de comandos, pero cuanto más practiques más natural será. Eventualmente, te encontrarás cómodamente trabajando en PowerShell, y serás capaz de hacer muchas tareas más fácilmente de esta manera.\u003C\u002Fp\u003E\\n\u003Cp\u003EAunque sólo hemos dado un vistazo de lo que puede hacer PowerShell, ahora tienes suficientes conocimientos básicos para aprender a hacer más cosas. Hay muchos recursos útiles en línea y los puedes hacer tuyos con Google. También es útil saber que muchas discusiones sobre el uso de la línea de comandos se basarán en Unix y otros sistemas *nix. En la mayoría de los casos, si simplemente escribes en un buscador los nombres de los comandos que estás utilizando junto con &quot;PowerShell&quot;, encontrarás el \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E correspondiente.\u003C\u002Fp\u003E\\n\u003Cp\u003ECuanto más utilices PowerShell más fácil será descubrir capacidades que ni siquiera sabías que tenía tu computadora. Eventualmente, notarás cómo el uso de la GUI te ha restringido en el uso de la potencialidad de tu máqiuna. No dejarás de usar la GUI, pero te encontrarás iniciando PowerShell cada vez con mayor frecuencia para liberarte de estas limitaciones y utilizar tu computadora de manera más completa. Tu computadora es como una navaja de bolsillo. La GUI sólo te permite abrir algunas cuchillas; ¡pero con la línea de comandos puedes abrirlas todas!\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"referencia-rápida\\\"\u003EReferencia rápida\u003C\u002Fh1\u003E\\n\u003Cp\u003EEsta tabla sirve como una referencia rápida a todos los \u003Cem\u003Ecmdlets\u003C\u002Fem\u003E mencionados en esta lección. La primera columna muestra el nombre real; el segundo muestra la abreviatura que normalmente se escribe. El equivalente de Bash muestra el comando más similar en Bash. A menos que este comando esté entre paréntesis, también se puede utilizar en PowerShell como un alias para el \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E correspondiente. Para obtener una explicación más completa de cualquiera de los \u003Cem\u003Ecmdlets\u003C\u002Fem\u003E, utiliza \u003Ccode\u003EGet-Help\u003C\u002Fcode\u003E con el parámetro \u003Ccode\u003E-online\u003C\u002Fcode\u003E (por ejemplo, \u003Ccode\u003EGet-Help Get-ChildItem -online\u003C\u002Fcode\u003E).\u003C\u002Fp\u003E\\n\u003Ctable\u003E\\n\u003Cthead\u003E\\n\u003Ctr\u003E\\n\u003Cth\u003ECmdlet\u003C\u002Fth\u003E\\n\u003Cth\u003EAlias\u003C\u002Fth\u003E\\n\u003Cth\u003EBash Equivalent\u003C\u002Fth\u003E\\n\u003Cth\u003EDescription\u003C\u002Fth\u003E\\n\u003C\u002Ftr\u003E\\n\u003C\u002Fthead\u003E\\n\u003Ctbody\u003E\u003Ctr\u003E\\n\u003Ctd\u003E\u003Ccode\u003EGet-ChildItem\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Egci\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Els\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003EEnlista los directorios y archivos en la ubicación actual.\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E\u003Ccode\u003ESet-Location\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Esl\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Ecd\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003ECambia al directorio en la ruta de acceso dada. Si escribes \u003Ccode\u003E..\u003C\u002Fcode\u003E en lugar de una ruta te moverá hacia arriba un directorio.\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E\u003Ccode\u003EPush-Location\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Epushd\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Epushd\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003ECambiar al directorio.\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E\u003Ccode\u003EPop-Location\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Epopd\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Epopd\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003ERegresa al directorio previo despues de usar \u003Ccode\u003Epushd\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E\u003Ccode\u003ENew-Item\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Eni\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E(\u003Ccode\u003Etouch\u003C\u002Fcode\u003E)\u003C\u002Ftd\u003E\\n\u003Ctd\u003ECrea un nuevo ítem. De no utilizarse un parámetro, el ítem será un archivo por defecto. El uso de \u003Ccode\u003Emkdir\u003C\u002Fcode\u003E es una abreviatura para incluir el parámetro \u003Ccode\u003E-ItemType dir\u003C\u002Fcode\u003E.\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E\u003Ccode\u003Emkdir\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003Enone\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Emkdir\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003ECrea un nuevo directorio. (Ver \u003Ccode\u003ENew-Item\u003C\u002Fcode\u003E.)\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E\u003Ccode\u003EExplorer\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003Enone\u003C\u002Ftd\u003E\\n\u003Ctd\u003E(\u003Ccode\u003Eopen\u003C\u002Fcode\u003E)\u003C\u002Ftd\u003E\\n\u003Ctd\u003EAbre algo utilizando el Explorador de archivos (la GUI)\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E\u003Ccode\u003ERemove-Item\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Erm\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Erm\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003EBorra algo... ¡de manera permanente!\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E\u003Ccode\u003EMove-Item\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Emv\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Emv\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003EMueve algo. Necesita dos argumentos. Primero un nombre de archivo (i.e. su ruta actual), luego la ruta de nueva nueva locación (incluido el nombre que debe tener ahí). Si no se cambia la ruta, puede usarse para renombrar archivos.\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E\u003Ccode\u003ECopy-Item\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Ecp\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Ecp\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003ECopia un archivo en una nueva ubicación. Requiere los mismos argumentos que mover, pero mantiene el archivo original en su ubicación.\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E\u003Ccode\u003EWrite-Output\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Ewrite\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Eecho\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003EExporta lo que escribas. Utiliza la redirección para enviarlo a un archivo. La redirección con \u003Ccode\u003E&gt;&gt;\u003C\u002Fcode\u003E añadirá texto al archivo en lugar de sobrescribir el contenido.\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E\u003Ccode\u003EGet-Content\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Egc\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Ecat\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003EObtiene el contenido de un archivo y lo imprime en la pantalla. La adición del parámetro \u003Ccode\u003E-TotalCount\u003C\u002Fcode\u003E seguido de un número x sólo imprime las primeras x líneas. Añadiendo el parámetro \u003Ccode\u003E-Tail\u003C\u002Fcode\u003E seguido de un número x sólo imprime las x líneas finales.\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E\u003Ccode\u003ESelect-String\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Esls\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E(\u003Ccode\u003Egrep\u003C\u002Fcode\u003E)\u003C\u002Ftd\u003E\\n\u003Ctd\u003EBusca contenido específico.\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E\u003Ccode\u003EMeasure-Object\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Emeasure\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003E(\u003Ccode\u003Ewc\u003C\u002Fcode\u003E)\u003C\u002Ftd\u003E\\n\u003Ctd\u003EObtiene información estadística sobre un objeto. Utiliza \u003Ccode\u003EGet-Content\u003C\u002Fcode\u003E y dirige la salida a\u003Ccode\u003E Measure-Object\u003C\u002Fcode\u003E con los parámetros \u003Ccode\u003E-line\u003C\u002Fcode\u003E, \u003Ccode\u003E-word\u003C\u002Fcode\u003E y \u003Ccode\u003E-character\u003C\u002Fcode\u003E para obtener información sobre el recuento de líneas, palabras o caracteres.\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E\u003Ccode\u003E&gt;\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003Enone\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003E&gt;\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003ERedirección. Pone la salida del comando a la izquierda de \u003Ccode\u003E&gt;\u003C\u002Fcode\u003E en un archivo a la derecha de \u003Ccode\u003E&gt;\u003C\u002Fcode\u003E.\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E`\u003C\u002Ftd\u003E\\n\u003Ctd\u003E`\u003C\u002Ftd\u003E\\n\u003Ctd\u003Enone\u003C\u002Ftd\u003E\\n\u003Ctd\u003E`\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E\u003Ccode\u003EGet-Help\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003Enone\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Eman\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003EObtiene el archivo de ayuda de un \u003Cem\u003Ecmdlet\u003C\u002Fem\u003E. La adición del parámetro \u003Ccode\u003E-online\u003C\u002Fcode\u003E abre la página de ayuda en TechNet.\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003Ctr\u003E\\n\u003Ctd\u003E\u003Ccode\u003Eexit\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003Enone\u003C\u002Ftd\u003E\\n\u003Ctd\u003E\u003Ccode\u003Eexit\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\\n\u003Ctd\u003ESalir de PowerShell\u003C\u002Ftd\u003E\\n\u003C\u002Ftr\u003E\\n\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\\n\"}"}</script></div>
	</body>
</html>
