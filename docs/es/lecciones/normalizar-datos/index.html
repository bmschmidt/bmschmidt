<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="description" content="" />
		<link rel="icon" href="/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		

		

		<link rel="stylesheet" href="/_app/assets/start-61d1577b.css">
		<link rel="modulepreload" href="/_app/start-c09d08cd.js">
		<link rel="modulepreload" href="/_app/chunks/vendor-9b9d6288.js">
		<link rel="modulepreload" href="/_app/pages/__layout.svelte-de46afb2.js">
		<link rel="modulepreload" href="/_app/pages/_lang_/__layout.svelte-e75718c6.js">
		<link rel="modulepreload" href="/_app/chunks/stores-191d1505.js">
		<link rel="modulepreload" href="/_app/pages/_lang_/_lessons_/_slug_/index.svelte-efe77d76.js">

		<script type="module">
			import { start } from "/_app/start-c09d08cd.js";
			start({
				target: document.querySelector("#svelte"),
				paths: {"base":"","assets":""},
				session: {},
				route: true,
				spa: false,
				trailing_slash: "never",
				hydrate: {
					status: 200,
					error: null,
					nodes: [
						import("/_app/pages/__layout.svelte-de46afb2.js"),
						import("/_app/pages/_lang_/__layout.svelte-e75718c6.js"),
						import("/_app/pages/_lang_/_lessons_/_slug_/index.svelte-efe77d76.js")
					],
					url: new URL("sveltekit://prerender/es/lecciones/normalizar-datos"),
					params: {lang:"es",lessons:"lecciones",slug:"normalizar-datos"}
				}
			});
		</script><script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('/service-worker.js');
			}
		</script>
	</head>
	<body>
		<div id="svelte">


The Programming Historian <a href="/en">English</a> <a href="/es">Spanish</a>
<br>
This is the es edition.

<h1>Normalizar datos de texto con Python</h1>

<!-- HTML_TAG_START --><p>{% include toc.html %}</p>
<h2 id="objetivos-de-la-lección">Objetivos de la lección</h2>
<p>La lista que creamos en <a href="/es/lecciones/de-html-a-lista-de-palabras-2">De HTML a lista de palabras (parte 2)</a> necesita cierta &quot;normalización&quot; antes de que podamos usarla más adelante. Vamos a hacer esto aplicando métodos adicionales para cadenas de caracteres, así como utilizar <em>expresiones regulares</em>. Una vez normalizadas seremos capaces de analizar nuestros datos de una manera más fácil.</p>
<h2 id="archivos-necesarios-para-esta-lección">Archivos necesarios para esta lección</h2>
<ul>
<li><em>html-a-lista-1.py</em></li>
<li><em>obo.py</em></li>
</ul>
<p>Si no tienes estos archivos de la lección previa, puedes descargar un <a href="/assets/python-es-lecciones3.zip">zip</a>.</p>
<h2 id="limpiar-la-lista">Limpiar la lista</h2>
<p>En <a href="/es/lecciones/de-html-a-lista-de-palabras-2">De HTML a lista de palabras (parte 2)</a>, escribimos un programa en Python llamado <em>html-a-lista-1.py</em> que descargó una <a href="https://www.oldbaileyonline.org/browse.jsp?id=t17800628-33&amp;div=t17800628-33">página Web</a>, retiró el formato HTML y los metadatos y nos devolvió una lista de &quot;palabras&quot; como la que se muestra más abajo. Técnicamente, estas entidades son llamadas &quot;<em>tokens</em>&quot; (o &quot;<em>componente léxico</em>&quot;) en vez de &quot;palabras&quot;. Estos incluyen cosas que nos son palabras estrictamente hablando (como la abreviatura &amp;c. de &quot;etcétera&quot;). También incluyen algunas cosas que se podrían considerar componentes de más de una palabra.  El posesivo &quot;Akerman&#39;s&quot; en idioma inglés, por ejemplo, algunas veces es analizado por los lingüístas como dos palabras: &quot;Akerman&quot; más un marcador posesivo. En inglés también, ¿&quot;o&#39;clock&quot; es una o dos palabras? Y así.</p>
<p>Regresa a tu programa <em>html-a-lista-1.py</em> y asegúrate de que tus resultados se vean como algo por el estilo de esto:</p>
<pre><code class="language-python">[&#39;324.&#39;, &#39;\xc2\xa0&#39;, &#39;BENJAMIN&#39;, &#39;BOWSEY&#39;, &#39;(a&#39;, &#39;blackmoor&#39;, &#39;)&#39;, &#39;was&#39;,
&#39;indicted&#39;, &#39;for&#39;, &#39;that&#39;, &#39;he&#39;, &#39;together&#39;, &#39;with&#39;, &#39;five&#39;, &#39;hundred&#39;,
&#39;other&#39;, &#39;persons&#39;, &#39;and&#39;, &#39;more,&#39;, &#39;did,&#39;, &#39;unlawfully,&#39;, &#39;riotously,&#39;,
&#39;and&#39;, &#39;tumultuously&#39;, &#39;assemble&#39;, &#39;on&#39;, &#39;the&#39;, &#39;6th&#39;, &#39;of&#39;, &#39;June&#39;, &#39;to&#39;,
&#39;the&#39;, &#39;disturbance&#39;, &#39;of&#39;, &#39;the&#39;, &#39;public&#39;, &#39;peace&#39;, &#39;and&#39;, &#39;did&#39;, &#39;begin&#39;,
&#39;to&#39;, &#39;demolish&#39;, &#39;and&#39;, &#39;pull&#39;, &#39;down&#39;, &#39;the&#39;, &#39;dwelling&#39;, &#39;house&#39;, &#39;of&#39;,
&#39;\xc2\xa0&#39;, &#39;Richard&#39;, &#39;Akerman&#39;, &#39;,&#39;, &#39;against&#39;, &#39;the&#39;, &#39;form&#39;, &#39;of&#39;,
&#39;the&#39;, &#39;statute,&#39;, &#39;&amp;amp;c.&#39;, &#39;\xc2\xa0&#39;, &#39;ROSE&#39;, &#39;JENNINGS&#39;, &#39;,&#39;, &#39;Esq.&#39;,
&#39;sworn.&#39;, &#39;Had&#39;, &#39;you&#39;, &#39;any&#39;, &#39;occasion&#39;, &#39;to&#39;, &#39;be&#39;, &#39;in&#39;, &#39;this&#39;, &#39;part&#39;,
&#39;of&#39;, &#39;the&#39;, &#39;town,&#39;, &#39;on&#39;, &#39;the&#39;, &#39;6th&#39;, &#39;of&#39;, &#39;June&#39;, &#39;in&#39;, &#39;the&#39;,
&#39;evening?&#39;, &#39;-&#39;, &#39;I&#39;, &#39;dined&#39;, &#39;with&#39;, &#39;my&#39;, &#39;brother&#39;, &#39;who&#39;, &#39;lives&#39;,
&#39;opposite&#39;, &#39;Mr.&#39;, &quot;Akerman&#39;s&quot;, &#39;house.&#39;, &#39;They&#39;, &#39;attacked&#39;, &#39;Mr.&#39;,
&quot;Akerman&#39;s&quot;, &#39;house&#39;, &#39;precisely&#39;, &#39;at&#39;, &#39;seven&#39;, &quot;o&#39;clock;&quot;, &#39;they&#39;,
&#39;were&#39;, &#39;preceded&#39;, &#39;by&#39;, &#39;a&#39;, &#39;man&#39;, &#39;better&#39;, &#39;dressed&#39;, &#39;than&#39;, &#39;the&#39;,
&#39;rest,&#39;, &#39;who&#39;]
</code></pre>
<p>Por sí misma, esta habilidad de separar el documento en palabras no nos ayuda mucho porque nosotros ya sabemos cómo leerlo. Sin embargo, podemos usar el texto para hacer cosas que normalmente no son posibles sin un programa especial. Vamos a comenzar por computar la frecuencia de los <em>tokens</em> y otras unidades lingüísticas, una medida clásica de un texto.</p>
<p>Queda claro que nuestra lista va a necesitar cierta limpieza antes de que la podamos utilizar para contar frecuencias. Conservando la práctica establecida en <a href="/es/lecciones/de-html-a-lista-de-palabras-1">De HTML a lista de palabras (parte 1)</a>, tratemos de describir nuestro algoritmo primero en lenguaje llano. Queremos saber la frecuencia con la que aparece cada palabra con significado en la transcripción del juicio. De tal manera, los pasos a seguir deben verse de la siguiente manera:</p>
<ul>
<li>Convierte todas las palabras a minúsculas para que &quot;BENJAMIN&quot; y &quot;benjamin&quot; sean contadas como una misma palabra</li>
<li>Retira cualquier carácter extraño o inusual</li>
<li>Cuenta el número de veces que aparece cada palabra</li>
<li>Retira palabras demasiado comunes como &quot;eso&quot;, &quot;el&quot;, &quot;y&quot;, etc.</li>
</ul>
<h2 id="convertir-a-minúsculas">Convertir a minúsculas</h2>
<p>Típicamente los componentes léxicos (<em>tokens</em>) son compactados como minúsculas cuando se cuentan frecuencias, así que lo haremos utilizando el método de cadena &quot;lower&quot; que aprendimos en <a href="/es/lecciones/manipular-cadenas-de-caracteres-en-python">Manipular cadenas de caracteres en Python</a>. Ya que este es un método para cadenas, tendremos que aplicarlo en la cadena <em>texto</em> en el programa <em>html-a-lista-1.py</em>. Enmienda <em>html-a-lista-1.py</em> añadiendo la etiqueta de cadena <code>lower()</code> al final de la cadena <em>texto</em>.</p>
<pre><code class="language-python"># html-a-lista-1.py
import urllib.request, urllib.error, urllib.parse, obo

url = &#39;http://www.oldbaileyonline.org/browse.jsp?id=t17800628-33&amp;div=t17800628-33&#39;

respuesta = urllib.request.urlopen(url)
html = str(respuesta.read().decode(&#39;UTF-8&#39;))
texto = obo.quitarEtiquetas(html).lower() #incluye el metodo de cadena aqui
listaPalabras = texto.split()

print((listaPalabras[0:120]))
</code></pre>
<p>Ahora debes ver la misma lista de palabras que antes pero con todos los caracteres en minúsculas.</p>
<p>Al &quot;llamar&quot; métodos uno tras otro, como en este caso, podemos mantener nuestro código corto y hacer algunos cambios muy significativos en nuestro programa.</p>
<p>Como hemos dicho antes, Python facilita hacer mucho con muy poco código.</p>
<p>En este punto podríamos mirar con atención otras entradas del <em>Old Bailey</em> en línea así como una amplia gama de otras fuentes potenciales para asegurarnos de que no hay otros caracteres especiales que podrían causar problemas más adelante. También podríamos tratar de anticipar situaciones en las que no queremos deshacernos de cierta puntuación (por ejemplo, los distintivos de cantidades monetarios como &quot;$1629&quot; o “£1295”, de fechas, o el reconocer que &quot;1629-40&quot; tiene un significado distinto que &quot;1629 40&quot;). Esto es lo que a lo programadores profesionales se les paga por hacer: trata de pensar en todo lo que podría ir mal y trátalo de antemano.</p>
<p>Veámoslo desde otra perspectiva. Nuestro objetivo principal es desarrollar técnicas que un historiador puede utilizar durante el proceso de investigación. Esto significa que casi siempre preferimos soluciones aproximadamente correctas que puedan desarrollarse rápidamente. Así que, en lugar de invertir tiempo en hacer nuestro programa sólido de cara a excepciones, simplemente queremos deshacernos de todo aquello que no sea un carácter con o sin acentos o un número arábigo. La programación generalmente es un proceso de &quot;refinamiento paso a paso&quot;. Empiezas con un problema y partes de una solución, y luego sigues refinando tu solución hasta que tienes algo que funciona mejor.</p>
<h2 id="expresiones-regulares-en-python">Expresiones regulares en Python</h2>
<p>Hemos eliminado las mayúsculas. Ahora nos toca deshacernos de los signos de puntuación. Si dejamos la puntuación, ésta echa a perder nuestras cuentas de frecuencia. ¿Queremos que &quot;evening?&quot; sea contada como &quot;evening&quot; y &quot;1780.&quot; como &quot;1780&quot;? ¡Por supuesto!</p>
<p>Es posible utilizar el método de cadena &quot;replace&quot; para retirar cada tipo de puntuación:</p>
<pre><code class="language-python">texto = texto.replace(&#39;[&#39;, &#39;&#39;)
texto = texto.replace(&#39;]&#39;, &#39;&#39;)
texto = texto.replace(&#39;,&#39;, &#39;&#39;)
#etc...
</code></pre>
<p>Pero esto no es verdaderamente eficiente. Ateniéndonos a nuestro objetivo de crear programas breves y poderosos, vamos a utilizar un mecanismo llamado &quot;expresiones regulares&quot;. Las expresiones regulares son provistas por varios lenguajes de programación en un abanico de formas distintas.</p>
<p>Las expresiones regulares te permiten buscar patrones bien definidos y pueden acortar drásticamente la longitud de tu código. Por ejemplo, si deseas saber si una subcadena coincidió con una letra del alfabeto, en lugar de utilizar la sentencia <em>if / else</em> para comprobar la coincidencia con la letra &quot;a&quot;, luego la &quot;b&quot; y luego la &quot;c&quot;, y así sucesivamente, se podría utilizar una expresión regular para ver si cualquier letra entre la &quot;a&quot; y la &quot;z&quot; coincide con la subcadena. O bien, puedes comprobar la presencia de un dígito o una letra mayúscula, o de cualquier carácter alfanumérico, un retorno de carro o cualquier combinación de los anteriores y mucho más.</p>
<p>En Python, las expresiones regulares están disponibles como un módulo de Python. Para acelerar el procesamiento, éste no se carga automáticamente porque no todos los programas lo requieren. Por lo tanto, tendrás que importar (<code>import</code>) el módulo (llamado <em>re</em>) de la misma manera en la que has importado tu propio módulo <em>obo.py</em>.</p>
<p>Dado que nos interesan solamente los caracteres alfanuméricos, vamos a crear una expresión regular que aislará sólo estos y eliminará el resto. Copia la siguiente función y pégala al final del módulo <em>obo.py</em>. Puedes dejar las otras funciones en el módulo solo, ya que seguiremos utilizándolas.</p>
<pre><code class="language-python"># Dada una cadena de caracteres, retira todos los caracteres
# no-alfanuméricos (utilizando la definición Unicode de alfanumérico).

def quitaNoAlfaNum(texto):
    import re
    return re.compile(r&#39;\W+&#39;, re.UNICODE).split(texto)
</code></pre>
<p>La expresión regular en el código anterior es el material dentro de la cadena, en otras palabras <code>W+</code>. La <code>W</code> es la abreviatura de la clase de <em>caracteres no-alfanuméricos</em>. En una expresión regular de Python, el signo de adición (+) coincide con una o más copias de un carácter dado. La expresión <code>re.UNICODE</code> le dice al intérprete que queremos que incluya los caracteres de todas las lenguas del mundo en nuestra definición de &quot;alfanumérico&quot;, así como de la A a la Z, de a-z y de 0-9 en inglés. Las expresiones regulares deben ser compiladas antes de poder ser utilizadas, que es lo que hace el resto de la declaración. No te preocupes en entender ahora mismo la parte de la compilación.</p>
<p>Cuando redefinamos nuestro programa <em>html-a-lista-1.py</em>, entonces se verá como esto:</p>
<pre><code class="language-python"># html-a-lista-1.py
import urllib.request, urllib.error, urllib.parse, obo

url = &#39;http://www.oldbaileyonline.org/browse.jsp?id=t17800628-33&amp;div=t17800628-33&#39;

respuesta = urllib.request.urlopen(url)
html = respuesta.read().decode(&#39;UTF-8&#39;)
texto = obo.quitarEtiquetas(html).lower()
listaPalabras = obo.quitaNoAlfaNum(texto)

print(listaPalabras)
</code></pre>
<p>Cuando ejecutes el programa y veas a través de su salida en el panel de &quot;comando de salida&quot;, verás que ha hecho un maravilloso trabajo. Este código separará expresiones con guiones como &quot;coach-wells&quot; en dos palabras y convertirá la partícula posesiva &quot;s&quot; o &quot;o&#39;clock&quot; en palabras separadas perdiéndo el apóstrofe. Pero es una aproximación lo suficientemente buena a lo que queremos, así que podemos proceder a contar frecuencias antes de intentar mejorarlo. (Si trabajas con fuentes documentales en más de una lengua, necesitaras aprender más acerca del estándar <a href="http://unicode.org/">Unicode</a> y acerca del <a href="https://web.archive.org/web/20180502053841/http://www.diveintopython.net/xml_processing/unicode.html">soporte de Python</a> para el mismo).</p>
<h2 id="lecturas-sugeridas">Lecturas sugeridas</h2>
<p>Para una práctica extra en expresiones regulares, encontrarás que el Capítulo 7 del libro de Mark Pilgrim <a href="https://web.archive.org/web/20180416143856/http://www.diveintopython.net/regular_expressions/index.html">Dive into Python</a> es un tutorial muy útil.</p>
<h3 id="sicronización-de-código">Sicronización de código</h3>
<p>Para seguir a lo largo de las lecciones futuras es importante que tengas los archivos correctos y programas en el directorio &quot;programming-historian&quot; de tu disco duro. Al final de cada lección puedes descargar el archivo zip &quot;python-es-lecciones&quot; para asegurarte que tienes el código correcto.</p>
<ul>
<li>python-es-lecciones4.zip (<a href="/assets/python-es-lecciones4.zip">zip sync</a>)</li>
</ul>
<!-- HTML_TAG_END -->

<script type="application/json" data-type="svelte-data" data-url="normalizar-datos/raw.json">{"status":200,"statusText":"","headers":{"content-type":"application/json; charset=utf-8"},"body":"{\"metadata\":{\"title\":\"Normalizar datos de texto con Python\",\"authors\":[\"William J. Turkel\",\"Adam Crymble\"],\"date\":\"2012-07-17T00:00:00.000Z\",\"translation_date\":\"2017-03-15T00:00:00.000Z\",\"editors\":[\"Miriam Posner\"],\"reviewers\":[\"Jim Clifford\",\"Francesca Benatti\",\"Frederik Elwert\"],\"translator\":[\"Víctor Gayol\"],\"translation-editor\":[\"Adam Crymble\"],\"translation-reviewer\":[\"Jairo A. Melo\",\"Maria José Afanador-Llach\",\"Antonio Rojas Castro\"],\"review-ticket\":\"https:\u002F\u002Fgithub.com\u002Fprogramminghistorian\u002Fph-submissions\u002Fissues\u002F46\",\"layout\":\"lesson\",\"next\":\"contar-frecuencias\",\"previous\":\"de-html-a-lista-de-palabras-2\",\"original\":\"normalizing-data\",\"python_warning\":false,\"difficulty\":2,\"activity\":\"transforming\",\"topics\":[\"python\"],\"abstract\":\"En esta lección haremos que la lista que creamos en'De HTML a lista de palabras (parte 2)' sea más fácil de analizar al “normalizar” los datos.\",\"avatar_alt\":\"Ilustración de dos personas caminando agarradas del brazo.\",\"doi\":\"10.46430\u002Fphes0020\",\"sequence\":9,\"series_total\":14},\"html_body\":\"\u003Cp\u003E{% include toc.html %}\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"objetivos-de-la-lección\\\"\u003EObjetivos de la lección\u003C\u002Fh2\u003E\\n\u003Cp\u003ELa lista que creamos en \u003Ca href=\\\"\u002Fes\u002Flecciones\u002Fde-html-a-lista-de-palabras-2\\\"\u003EDe HTML a lista de palabras (parte 2)\u003C\u002Fa\u003E necesita cierta &quot;normalización&quot; antes de que podamos usarla más adelante. Vamos a hacer esto aplicando métodos adicionales para cadenas de caracteres, así como utilizar \u003Cem\u003Eexpresiones regulares\u003C\u002Fem\u003E. Una vez normalizadas seremos capaces de analizar nuestros datos de una manera más fácil.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"archivos-necesarios-para-esta-lección\\\"\u003EArchivos necesarios para esta lección\u003C\u002Fh2\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Cem\u003Ehtml-a-lista-1.py\u003C\u002Fem\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cem\u003Eobo.py\u003C\u002Fem\u003E\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003ESi no tienes estos archivos de la lección previa, puedes descargar un \u003Ca href=\\\"\u002Fassets\u002Fpython-es-lecciones3.zip\\\"\u003Ezip\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"limpiar-la-lista\\\"\u003ELimpiar la lista\u003C\u002Fh2\u003E\\n\u003Cp\u003EEn \u003Ca href=\\\"\u002Fes\u002Flecciones\u002Fde-html-a-lista-de-palabras-2\\\"\u003EDe HTML a lista de palabras (parte 2)\u003C\u002Fa\u003E, escribimos un programa en Python llamado \u003Cem\u003Ehtml-a-lista-1.py\u003C\u002Fem\u003E que descargó una \u003Ca href=\\\"https:\u002F\u002Fwww.oldbaileyonline.org\u002Fbrowse.jsp?id=t17800628-33&amp;div=t17800628-33\\\"\u003Epágina Web\u003C\u002Fa\u003E, retiró el formato HTML y los metadatos y nos devolvió una lista de &quot;palabras&quot; como la que se muestra más abajo. Técnicamente, estas entidades son llamadas &quot;\u003Cem\u003Etokens\u003C\u002Fem\u003E&quot; (o &quot;\u003Cem\u003Ecomponente léxico\u003C\u002Fem\u003E&quot;) en vez de &quot;palabras&quot;. Estos incluyen cosas que nos son palabras estrictamente hablando (como la abreviatura &amp;c. de &quot;etcétera&quot;). También incluyen algunas cosas que se podrían considerar componentes de más de una palabra.  El posesivo &quot;Akerman&#39;s&quot; en idioma inglés, por ejemplo, algunas veces es analizado por los lingüístas como dos palabras: &quot;Akerman&quot; más un marcador posesivo. En inglés también, ¿&quot;o&#39;clock&quot; es una o dos palabras? Y así.\u003C\u002Fp\u003E\\n\u003Cp\u003ERegresa a tu programa \u003Cem\u003Ehtml-a-lista-1.py\u003C\u002Fem\u003E y asegúrate de que tus resultados se vean como algo por el estilo de esto:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E[&#39;324.&#39;, &#39;\\\\xc2\\\\xa0&#39;, &#39;BENJAMIN&#39;, &#39;BOWSEY&#39;, &#39;(a&#39;, &#39;blackmoor&#39;, &#39;)&#39;, &#39;was&#39;,\\n&#39;indicted&#39;, &#39;for&#39;, &#39;that&#39;, &#39;he&#39;, &#39;together&#39;, &#39;with&#39;, &#39;five&#39;, &#39;hundred&#39;,\\n&#39;other&#39;, &#39;persons&#39;, &#39;and&#39;, &#39;more,&#39;, &#39;did,&#39;, &#39;unlawfully,&#39;, &#39;riotously,&#39;,\\n&#39;and&#39;, &#39;tumultuously&#39;, &#39;assemble&#39;, &#39;on&#39;, &#39;the&#39;, &#39;6th&#39;, &#39;of&#39;, &#39;June&#39;, &#39;to&#39;,\\n&#39;the&#39;, &#39;disturbance&#39;, &#39;of&#39;, &#39;the&#39;, &#39;public&#39;, &#39;peace&#39;, &#39;and&#39;, &#39;did&#39;, &#39;begin&#39;,\\n&#39;to&#39;, &#39;demolish&#39;, &#39;and&#39;, &#39;pull&#39;, &#39;down&#39;, &#39;the&#39;, &#39;dwelling&#39;, &#39;house&#39;, &#39;of&#39;,\\n&#39;\\\\xc2\\\\xa0&#39;, &#39;Richard&#39;, &#39;Akerman&#39;, &#39;,&#39;, &#39;against&#39;, &#39;the&#39;, &#39;form&#39;, &#39;of&#39;,\\n&#39;the&#39;, &#39;statute,&#39;, &#39;&amp;amp;c.&#39;, &#39;\\\\xc2\\\\xa0&#39;, &#39;ROSE&#39;, &#39;JENNINGS&#39;, &#39;,&#39;, &#39;Esq.&#39;,\\n&#39;sworn.&#39;, &#39;Had&#39;, &#39;you&#39;, &#39;any&#39;, &#39;occasion&#39;, &#39;to&#39;, &#39;be&#39;, &#39;in&#39;, &#39;this&#39;, &#39;part&#39;,\\n&#39;of&#39;, &#39;the&#39;, &#39;town,&#39;, &#39;on&#39;, &#39;the&#39;, &#39;6th&#39;, &#39;of&#39;, &#39;June&#39;, &#39;in&#39;, &#39;the&#39;,\\n&#39;evening?&#39;, &#39;-&#39;, &#39;I&#39;, &#39;dined&#39;, &#39;with&#39;, &#39;my&#39;, &#39;brother&#39;, &#39;who&#39;, &#39;lives&#39;,\\n&#39;opposite&#39;, &#39;Mr.&#39;, &quot;Akerman&#39;s&quot;, &#39;house.&#39;, &#39;They&#39;, &#39;attacked&#39;, &#39;Mr.&#39;,\\n&quot;Akerman&#39;s&quot;, &#39;house&#39;, &#39;precisely&#39;, &#39;at&#39;, &#39;seven&#39;, &quot;o&#39;clock;&quot;, &#39;they&#39;,\\n&#39;were&#39;, &#39;preceded&#39;, &#39;by&#39;, &#39;a&#39;, &#39;man&#39;, &#39;better&#39;, &#39;dressed&#39;, &#39;than&#39;, &#39;the&#39;,\\n&#39;rest,&#39;, &#39;who&#39;]\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EPor sí misma, esta habilidad de separar el documento en palabras no nos ayuda mucho porque nosotros ya sabemos cómo leerlo. Sin embargo, podemos usar el texto para hacer cosas que normalmente no son posibles sin un programa especial. Vamos a comenzar por computar la frecuencia de los \u003Cem\u003Etokens\u003C\u002Fem\u003E y otras unidades lingüísticas, una medida clásica de un texto.\u003C\u002Fp\u003E\\n\u003Cp\u003EQueda claro que nuestra lista va a necesitar cierta limpieza antes de que la podamos utilizar para contar frecuencias. Conservando la práctica establecida en \u003Ca href=\\\"\u002Fes\u002Flecciones\u002Fde-html-a-lista-de-palabras-1\\\"\u003EDe HTML a lista de palabras (parte 1)\u003C\u002Fa\u003E, tratemos de describir nuestro algoritmo primero en lenguaje llano. Queremos saber la frecuencia con la que aparece cada palabra con significado en la transcripción del juicio. De tal manera, los pasos a seguir deben verse de la siguiente manera:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003EConvierte todas las palabras a minúsculas para que &quot;BENJAMIN&quot; y &quot;benjamin&quot; sean contadas como una misma palabra\u003C\u002Fli\u003E\\n\u003Cli\u003ERetira cualquier carácter extraño o inusual\u003C\u002Fli\u003E\\n\u003Cli\u003ECuenta el número de veces que aparece cada palabra\u003C\u002Fli\u003E\\n\u003Cli\u003ERetira palabras demasiado comunes como &quot;eso&quot;, &quot;el&quot;, &quot;y&quot;, etc.\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Ch2 id=\\\"convertir-a-minúsculas\\\"\u003EConvertir a minúsculas\u003C\u002Fh2\u003E\\n\u003Cp\u003ETípicamente los componentes léxicos (\u003Cem\u003Etokens\u003C\u002Fem\u003E) son compactados como minúsculas cuando se cuentan frecuencias, así que lo haremos utilizando el método de cadena &quot;lower&quot; que aprendimos en \u003Ca href=\\\"\u002Fes\u002Flecciones\u002Fmanipular-cadenas-de-caracteres-en-python\\\"\u003EManipular cadenas de caracteres en Python\u003C\u002Fa\u003E. Ya que este es un método para cadenas, tendremos que aplicarlo en la cadena \u003Cem\u003Etexto\u003C\u002Fem\u003E en el programa \u003Cem\u003Ehtml-a-lista-1.py\u003C\u002Fem\u003E. Enmienda \u003Cem\u003Ehtml-a-lista-1.py\u003C\u002Fem\u003E añadiendo la etiqueta de cadena \u003Ccode\u003Elower()\u003C\u002Fcode\u003E al final de la cadena \u003Cem\u003Etexto\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E# html-a-lista-1.py\\nimport urllib.request, urllib.error, urllib.parse, obo\\n\\nurl = &#39;http:\u002F\u002Fwww.oldbaileyonline.org\u002Fbrowse.jsp?id=t17800628-33&amp;div=t17800628-33&#39;\\n\\nrespuesta = urllib.request.urlopen(url)\\nhtml = str(respuesta.read().decode(&#39;UTF-8&#39;))\\ntexto = obo.quitarEtiquetas(html).lower() #incluye el metodo de cadena aqui\\nlistaPalabras = texto.split()\\n\\nprint((listaPalabras[0:120]))\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EAhora debes ver la misma lista de palabras que antes pero con todos los caracteres en minúsculas.\u003C\u002Fp\u003E\\n\u003Cp\u003EAl &quot;llamar&quot; métodos uno tras otro, como en este caso, podemos mantener nuestro código corto y hacer algunos cambios muy significativos en nuestro programa.\u003C\u002Fp\u003E\\n\u003Cp\u003EComo hemos dicho antes, Python facilita hacer mucho con muy poco código.\u003C\u002Fp\u003E\\n\u003Cp\u003EEn este punto podríamos mirar con atención otras entradas del \u003Cem\u003EOld Bailey\u003C\u002Fem\u003E en línea así como una amplia gama de otras fuentes potenciales para asegurarnos de que no hay otros caracteres especiales que podrían causar problemas más adelante. También podríamos tratar de anticipar situaciones en las que no queremos deshacernos de cierta puntuación (por ejemplo, los distintivos de cantidades monetarios como &quot;$1629&quot; o “£1295”, de fechas, o el reconocer que &quot;1629-40&quot; tiene un significado distinto que &quot;1629 40&quot;). Esto es lo que a lo programadores profesionales se les paga por hacer: trata de pensar en todo lo que podría ir mal y trátalo de antemano.\u003C\u002Fp\u003E\\n\u003Cp\u003EVeámoslo desde otra perspectiva. Nuestro objetivo principal es desarrollar técnicas que un historiador puede utilizar durante el proceso de investigación. Esto significa que casi siempre preferimos soluciones aproximadamente correctas que puedan desarrollarse rápidamente. Así que, en lugar de invertir tiempo en hacer nuestro programa sólido de cara a excepciones, simplemente queremos deshacernos de todo aquello que no sea un carácter con o sin acentos o un número arábigo. La programación generalmente es un proceso de &quot;refinamiento paso a paso&quot;. Empiezas con un problema y partes de una solución, y luego sigues refinando tu solución hasta que tienes algo que funciona mejor.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"expresiones-regulares-en-python\\\"\u003EExpresiones regulares en Python\u003C\u002Fh2\u003E\\n\u003Cp\u003EHemos eliminado las mayúsculas. Ahora nos toca deshacernos de los signos de puntuación. Si dejamos la puntuación, ésta echa a perder nuestras cuentas de frecuencia. ¿Queremos que &quot;evening?&quot; sea contada como &quot;evening&quot; y &quot;1780.&quot; como &quot;1780&quot;? ¡Por supuesto!\u003C\u002Fp\u003E\\n\u003Cp\u003EEs posible utilizar el método de cadena &quot;replace&quot; para retirar cada tipo de puntuación:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Etexto = texto.replace(&#39;[&#39;, &#39;&#39;)\\ntexto = texto.replace(&#39;]&#39;, &#39;&#39;)\\ntexto = texto.replace(&#39;,&#39;, &#39;&#39;)\\n#etc...\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EPero esto no es verdaderamente eficiente. Ateniéndonos a nuestro objetivo de crear programas breves y poderosos, vamos a utilizar un mecanismo llamado &quot;expresiones regulares&quot;. Las expresiones regulares son provistas por varios lenguajes de programación en un abanico de formas distintas.\u003C\u002Fp\u003E\\n\u003Cp\u003ELas expresiones regulares te permiten buscar patrones bien definidos y pueden acortar drásticamente la longitud de tu código. Por ejemplo, si deseas saber si una subcadena coincidió con una letra del alfabeto, en lugar de utilizar la sentencia \u003Cem\u003Eif \u002F else\u003C\u002Fem\u003E para comprobar la coincidencia con la letra &quot;a&quot;, luego la &quot;b&quot; y luego la &quot;c&quot;, y así sucesivamente, se podría utilizar una expresión regular para ver si cualquier letra entre la &quot;a&quot; y la &quot;z&quot; coincide con la subcadena. O bien, puedes comprobar la presencia de un dígito o una letra mayúscula, o de cualquier carácter alfanumérico, un retorno de carro o cualquier combinación de los anteriores y mucho más.\u003C\u002Fp\u003E\\n\u003Cp\u003EEn Python, las expresiones regulares están disponibles como un módulo de Python. Para acelerar el procesamiento, éste no se carga automáticamente porque no todos los programas lo requieren. Por lo tanto, tendrás que importar (\u003Ccode\u003Eimport\u003C\u002Fcode\u003E) el módulo (llamado \u003Cem\u003Ere\u003C\u002Fem\u003E) de la misma manera en la que has importado tu propio módulo \u003Cem\u003Eobo.py\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EDado que nos interesan solamente los caracteres alfanuméricos, vamos a crear una expresión regular que aislará sólo estos y eliminará el resto. Copia la siguiente función y pégala al final del módulo \u003Cem\u003Eobo.py\u003C\u002Fem\u003E. Puedes dejar las otras funciones en el módulo solo, ya que seguiremos utilizándolas.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E# Dada una cadena de caracteres, retira todos los caracteres\\n# no-alfanuméricos (utilizando la definición Unicode de alfanumérico).\\n\\ndef quitaNoAlfaNum(texto):\\n    import re\\n    return re.compile(r&#39;\\\\W+&#39;, re.UNICODE).split(texto)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ELa expresión regular en el código anterior es el material dentro de la cadena, en otras palabras \u003Ccode\u003EW+\u003C\u002Fcode\u003E. La \u003Ccode\u003EW\u003C\u002Fcode\u003E es la abreviatura de la clase de \u003Cem\u003Ecaracteres no-alfanuméricos\u003C\u002Fem\u003E. En una expresión regular de Python, el signo de adición (+) coincide con una o más copias de un carácter dado. La expresión \u003Ccode\u003Ere.UNICODE\u003C\u002Fcode\u003E le dice al intérprete que queremos que incluya los caracteres de todas las lenguas del mundo en nuestra definición de &quot;alfanumérico&quot;, así como de la A a la Z, de a-z y de 0-9 en inglés. Las expresiones regulares deben ser compiladas antes de poder ser utilizadas, que es lo que hace el resto de la declaración. No te preocupes en entender ahora mismo la parte de la compilación.\u003C\u002Fp\u003E\\n\u003Cp\u003ECuando redefinamos nuestro programa \u003Cem\u003Ehtml-a-lista-1.py\u003C\u002Fem\u003E, entonces se verá como esto:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E# html-a-lista-1.py\\nimport urllib.request, urllib.error, urllib.parse, obo\\n\\nurl = &#39;http:\u002F\u002Fwww.oldbaileyonline.org\u002Fbrowse.jsp?id=t17800628-33&amp;div=t17800628-33&#39;\\n\\nrespuesta = urllib.request.urlopen(url)\\nhtml = respuesta.read().decode(&#39;UTF-8&#39;)\\ntexto = obo.quitarEtiquetas(html).lower()\\nlistaPalabras = obo.quitaNoAlfaNum(texto)\\n\\nprint(listaPalabras)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ECuando ejecutes el programa y veas a través de su salida en el panel de &quot;comando de salida&quot;, verás que ha hecho un maravilloso trabajo. Este código separará expresiones con guiones como &quot;coach-wells&quot; en dos palabras y convertirá la partícula posesiva &quot;s&quot; o &quot;o&#39;clock&quot; en palabras separadas perdiéndo el apóstrofe. Pero es una aproximación lo suficientemente buena a lo que queremos, así que podemos proceder a contar frecuencias antes de intentar mejorarlo. (Si trabajas con fuentes documentales en más de una lengua, necesitaras aprender más acerca del estándar \u003Ca href=\\\"http:\u002F\u002Funicode.org\u002F\\\"\u003EUnicode\u003C\u002Fa\u003E y acerca del \u003Ca href=\\\"https:\u002F\u002Fweb.archive.org\u002Fweb\u002F20180502053841\u002Fhttp:\u002F\u002Fwww.diveintopython.net\u002Fxml_processing\u002Funicode.html\\\"\u003Esoporte de Python\u003C\u002Fa\u003E para el mismo).\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"lecturas-sugeridas\\\"\u003ELecturas sugeridas\u003C\u002Fh2\u003E\\n\u003Cp\u003EPara una práctica extra en expresiones regulares, encontrarás que el Capítulo 7 del libro de Mark Pilgrim \u003Ca href=\\\"https:\u002F\u002Fweb.archive.org\u002Fweb\u002F20180416143856\u002Fhttp:\u002F\u002Fwww.diveintopython.net\u002Fregular_expressions\u002Findex.html\\\"\u003EDive into Python\u003C\u002Fa\u003E es un tutorial muy útil.\u003C\u002Fp\u003E\\n\u003Ch3 id=\\\"sicronización-de-código\\\"\u003ESicronización de código\u003C\u002Fh3\u003E\\n\u003Cp\u003EPara seguir a lo largo de las lecciones futuras es importante que tengas los archivos correctos y programas en el directorio &quot;programming-historian&quot; de tu disco duro. Al final de cada lección puedes descargar el archivo zip &quot;python-es-lecciones&quot; para asegurarte que tienes el código correcto.\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003Epython-es-lecciones4.zip (\u003Ca href=\\\"\u002Fassets\u002Fpython-es-lecciones4.zip\\\"\u003Ezip sync\u003C\u002Fa\u003E)\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\"}"}</script></div>
	</body>
</html>
