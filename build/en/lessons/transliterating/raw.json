{"metadata":{"title":"Transliterating non-ASCII characters with Python","layout":"lesson","date":"2013-10-04T00:00:00.000Z","authors":["Seth Bernstein"],"reviewers":["Michelle Moravec","Ezra Brooks","Russell Alleen-Willems"],"editors":["Adam Crymble"],"difficulty":2,"exclude_from_check":["review-ticket"],"activity":"transforming","topics":["data-manipulation"],"abstract":"This lesson shows how to use Python to transliterate automatically a list of words from a language with a non-Latin alphabet to a standardized format using the American Standard Code for Information Interchange (ASCII) characters.","redirect_from":"/lessons/transliterating","avatar_alt":"A set of Cyrillic characters","doi":"10.46430/phen0032"},"html_body":"<p>{% include toc.html %}</p>\n<h2 id=\"lesson-goals\">Lesson Goals</h2>\n<p>This lesson shows how to use Python to transliterate automatically a\nlist of words from a language with a non-Latin alphabet to a\nstandardized format using the American Standard Code for Information\nInterchange (<a href=\"http://en.wikipedia.org/wiki/Ascii\">ASCII</a>) characters. It builds on readers’ understanding\nof Python from the lessons “<a href=\"/lessons/viewing-html-files\">Viewing HTML Files</a>,” “<a href=\"/lessons/working-with-web-pages\">Working with Web\nPages</a>,” “<a href=\"/lessons/from-html-to-list-of-words-1\">From HTML to List of Words (part 1)</a>” and “<a href=\"/lessons/intro-to-beautiful-soup\">Intro to\nBeautiful Soup</a>.” At the end of the lesson, we will use the\ntransliteration dictionary to convert the names from a database of the\nRussian organization <a href=\"http://lists.memo.ru\">Memorial</a> from <a href=\"http://en.wikipedia.org/wiki/Cyrillic_script\">Cyrillic</a> into <a href=\"http://en.wikipedia.org/wiki/Latin_script\">Latin\ncharacters</a>. Although the example uses Cyrillic characters, the\ntechnique can be reproduced with other alphabets using <a href=\"http://en.wikipedia.org/wiki/Unicode\">Unicode</a>.</p>\n<h2 id=\"what-is-transliteration-and-for-whom-is-it-useful\">What Is Transliteration and for Whom Is It Useful?</h2>\n<p>Transliteration is something that most people do every day, knowingly or\nnot. Many English speakers would have trouble recognizing the name\nВладимир Путин but know that Vladimir Putin is Russia’s current\npresident. Transliteration is especially useful with names, because a\nstandardized transliterated name is often the same as a translated name.\n(Exceptions are when someone’s name is translated in a non-uniform way.\nLeon Trotsky’s Russian name would be transliterated in a standardized\nform as Lev Trotskii.)</p>\n<p>But transliteration has other uses too, especially for scholars. In many\nfields, the publishing convention is to transliterate any evidence used\nin the original. Moreover, citations from scholarly works need to be\ntransliterated carefully so that readers can find and verify evidence\nused in texts. Finally, transliteration can be more practical for\nauthors who can type more fluently with Latin letters than in the native\nalphabet of a language that does not use Latin characters.</p>\n<p>This lesson will be particularly useful for research in fields that use\na standardized transliteration format, such as Russian history field,\nwhere the convention is to use a simplified version of the American\nLibrary Association-Library of Congress (<a href=\"http://en.wikipedia.org/wiki/ALA-LC_romanization_for_Russian\">ALA-LC</a>) transliteration\ntable. (All tables currently available can be accessed here.)\nResearchers dealing with large databases of names can benefit\nconsiderably. However, this lesson will also allow practice with\nUnicode, character translation and using the parser <a href=\"http://www.crummy.com/software/BeautifulSoup/\">Beautiful Soup in\nPython.</a></p>\n<h2 id=\"converting-a-webpage-to-unicode\">Converting a Webpage to Unicode</h2>\n<p>The goal of this lesson is to take a list of names from a Russian\ndatabase and convert them from Cyrillic into ASCII characters. The page\nwe will use is from the site of the Russian human rights organization\nMemorial. During <a href=\"http://en.wikipedia.org/wiki/Glasnost\">Glasnost</a> professional and amateur historians in the\nSoviet Union gained the ability to conduct research on previously taboo\nsubjects, such as repression under Stalin. Banding together, they\nfounded <a href=\"http://lists.memo.ru\">Memorial</a> to collect and publicize their findings. Today, the\nNGO conducts research on a range of civil rights abuses in Russia, but\ncollecting data about the victims of Stalinism remains one of its main\nfunctions. On the Memorial website researchers can find a database with\nsome three million entries of people who were arrested or executed by\nStalin’s regime. It is an important resource on a dark topic. However,\nbecause the database has many, many names, it lends itself nicely to\nautomated transliteration. This lesson will use just the first page of\nthe database, found <a href=\"http://lists.memo.ru/d1/f1.htm\">here</a>, but using the lesson on “<a href=\"/lessons/automated-downloading-with-wget\">Automated\nDownloading with Wget</a>,” it would be possible to go through the entire\ndatabase as fast as your computer would allow.</p>\n<p>We need to start by modifying the process found in the lesson “<a href=\"/lessons/working-with-web-pages\">Working\nwith Web Pages</a>.” There we learned how to open and copy the HTML from\na web page in Python. But what if we want to open a page in a language\nthat does not use Latin characters? Python can do this but we need to\ntell it how to read these letters using a codec, a library of codes that\nallows Python to represent non-ASCII characters. Working with web pages\nmakes this easy because almost all web pages specify what kind of\nencoding they use, in the page’s <em>headers</em>. In Python, opening a web page\ndoes not just give you the HTML, but it creates an object with several\nuseful characteristics. One is that we can access the headers by calling\nthe <code>header()</code> method. This method returns something a lot like a Python\ndictionary with information that is important to web programmers. For\nour purposes, what is important is that the encoding is stored under the\n‘content-type’ key.</p>\n<pre><code class=\"language-python\">#transliterator.py\nfrom urllib.request import urlopen\n\npage = urlopen(&#39;http://lists.memo.ru/d1/f1.htm&#39;)\n\n#what is the encoding?\nprint(page.headers[&#39;content-type&#39;])\n</code></pre>\n<p>Under the ‘content-type’ key we find this information:</p>\n<pre><code>text/html; charset=windows-1251\n</code></pre>\n<p>The ‘content-type’ is telling us that the file stored at the url we\naccessed is in HTML and that its encoding (after ‘charset=’, meaning\ncharacter set) is ‘windows-1251′, a common encoding for Cyrillic\ncharacters. You can visit the webpage and view the Page Source and see\nfor yourself that the first line does in fact contain a ‘content-type’\nvariable with the value <code>text/html; charset=windows-1251</code>. It would not be\nso hard to work with the ‘windows-1251′ encoding. However,\n‘windows-1251′ is specifically for Cyrillic and will not handle all\nlanguages. For the sake of learning a standard method, what we want is\nUnicode, a coding set that handles not just Cyrillic but characters and\nsymbols from virtually any language. (For more on Unicode, see the <a href=\"http://www.unicode.org/standard/WhatIsUnicode.html\">What\nis Unicode</a> page.) Converting into Unicode gives us the potential to\ncreate a transliteration table that could cover multiple languages and\nspecial characters in a way that region-specific character sets do not\nallow.</p>\n<p>How do you convert the characters to Unicode? First, Python needs to\nknow the original encoding of the source, ‘windows-1251.’ We could just\nassign ‘windows-1251’ to a variable by typing it manually but the\nencoding may not always be ‘windows-1251.’ There are other character\nsets for Cyrillic, not to mention other languages. Let’s find a way to\nmake the process more automatic for those cases. It helps that the\nencoding is the very last part of the string, so we can isolate it from\neverything that came before in the string. By using the <code>.split()</code> method,\nthe string containing whatever encoding it is can be assigned to a\nvariable. The <code>.split(separator)</code> method in Python returns a list of\nsections in the string that are split by some user-defined separator.\nAssigning no separator to <code>.split()</code> separates a string at the spaces.\nAnother use of the <code>.split()</code> method is to separate by commas, which can\nhelp to work with <a href=\"http://en.wikipedia.org/wiki/Comma-separated_values\">comma separated value</a> (csv) files. In this case,\nthough, by splitting the ‘content-type’ string at ‘charset=’, we get a\n<em>list</em> with two strings where the second will be the character set.</p>\n<pre><code class=\"language-python\">encoding = page.headers[&#39;content-type&#39;].split(&#39;charset=&#39;)[1]\n</code></pre>\n<p>The encoding is assigned to the variable called ‘<em>encoding</em>’. You can\ncheck to see if this worked by printing the ‘<em>encoding</em>’ variable. Now we\ncan tell Python how to read the page as Unicode. Using the\n<code>str(object [, encoding])</code> method turns a text encoded in a specific encoding\ninto a generic Unicode string. A Unicode string cannot only contain ASCII\ncharacters, but also\nspecial characters. If the original text is in a non-ASCII character set,\nlike here with ‘windows-1251’, we have to use the optional encoding\nparameter.</p>\n<pre><code class=\"language-python\">#read the HTML as a string into a variable\ncontent = page.read()\n\n# the unicode method tries to use ASCII so we need to tell it the encoding\ncontent = str(content, encoding)\ncontent[200:300]\n</code></pre>\n<pre><code class=\"language-python\">&#39;&quot;list-right&quot;&gt;\\r\\n&lt;li&gt;&lt;p class=&quot;name&quot;&gt;&lt;a name=&quot;n1&quot;&gt;&lt;/a&gt;А-Аку Туликович &lt;/p&gt;&lt;p class=&quot;cont&quot;&gt;\\r\\nРодился\\xa0в &#39;\n</code></pre>\n<p>As you can see, the Cyrillic characters are mixed with the ASCII characters\nof the HTML code. But typing these can be cumbersome without a corresponding\nkeyboard layout. Alternatively, the Unicode characters can be typed using\nspecial codes that represent the characters using their Unicode number.\nYou can see the text as represented by Unicode numbers using the special ‘<em>unicode-escape</em>’ encoding:</p>\n<pre><code class=\"language-python\"># print string using unicode escape sequences\nprint(content[200:300].encode(&#39;unicode-escape&#39;))\n</code></pre>\n<pre><code>b&#39;&quot;list-right&quot;&gt;\\\\r\\\\n&lt;li&gt;&lt;p class=&quot;name&quot;&gt;&lt;a name=&quot;n1&quot;&gt;&lt;/a&gt;\\\\u0410-\\\\u0410\\\\u043a\\\\u0443 \\\\u0422\\\\u0443\\\\u043b\\\\u0438\\\\u043a\\\\u043e\\\\u0432\\\\u0438\\\\u0447 &lt;/p&gt;&lt;p class=&quot;cont&quot;&gt;\\\\r\\\\n\\\\u0420\\\\u043e\\\\u0434\\\\u0438\\\\u043b\\\\u0441\\\\u044f\\\\xa0\\\\u0432 &#39;\n</code></pre>\n<p>All the\n‘\\u0420’-type marks are Unicode and Python knows that they code to\nCyrillic characters. The backslash is called an ‘<em>escape character</em>’\nand allows Python to do things like use special characters in Unicode or\nsignify a line break (‘<code>\\n</code>’) in a document. Each counts as just one\ncharacter. Now we can create a Python <em>dictionary</em> that will act as the\ntransliteration table.</p>\n<h2 id=\"unicode-transliteration-dictionary\">Unicode Transliteration Dictionary</h2>\n<p>A dictionary is an unordered collection of <em>key-object pairs</em>. What this\nmeans is that under each key, the dictionary stores some number or\nstring or other object – even another dictionary. (See also the lesson\n“<a href=\"/lessons/counting-frequencies\">Counting Frequencies</a>.”) A dictionary has the following syntax:</p>\n<pre><code class=\"language-python\">my_dictionary = {&#39;Vladimir&#39;: &#39;Putin&#39;, &#39;Boris&#39;: &#39;Yeltsin&#39;}\nprint(my_dictionary[&#39;Vladimir&#39;])\n\n&gt; Putin\n</code></pre>\n<p>How can we turn this into a transliteration table? Just make each\nUnicode character a key in the dictionary. Its value will be whatever\ncharacter(s) it transliterates to. The table for Romanization of Russian\nis available from the <a href=\"http://web.archive.org/web/20170312041508/http://www.lcweb.loc.gov/catdir/cpso/romanization/russian.pdf\">Library of Congress</a>. This table needs to be\nsimplified slightly. The ALA-LC suggests using characters with umlauts\nor ligatures to represent Cyrillic letters but those characters are no\nmore ASCII than Cyrillic characters. So instead no umlauts or ligatures\nwill be used.</p>\n<p>Each Cyrillic letter has a different Unicode value. It would take time\nto find each one of them but fortunately <a href=\"http://en.wikipedia.org/wiki/Cyrillic_script_in_Unicode\">Wikipedia has a table</a>. If\nthe script were very rare, we could find it at the <a href=\"http://www.unicode.org/charts/\">Unicode website</a>.</p>\n<p>We just need to combine the transliteration table with the Unicode\ntable. The Unicode value for the Russian letter “Ж” is 0416 and it\ntransliterates to the Latin characters “Zh.” Python needs more than just\nthe Unicode identifier. It also needs to know to look out for a Unicode\ncharacter. Therefore all the Unicode characters used in the dictionary\nshould be in the format <code>&#39;\\uXXXX&#39;</code>. In this case, the letter Ж is\n<code>&#39;\\u0416&#39;</code>. We can create a transliteration dictionary and assign ‘Zh’\nas the value for the key <code>&#39;\\u0416&#39;</code> in it.</p>\n<pre><code class=\"language-python\">cyrillic_translit = { &#39;\\u0416&#39;: &#39;Zh&#39;}\n</code></pre>\n<p>As it turns out, lowercase Cyrillic letters in Unicode have the same\nvalue as their uppercase counterparts except the value of the second\nnumber is two greater. Thus, ‘ж’ codes to 0436. Now that we have a\ntransliteration dictionary created, we just add a dictionary key-value\npair.</p>\n<pre><code class=\"language-python\">cyrillic_translit[&#39;\\u0436&#39;] = &#39;zh&#39;\n</code></pre>\n<p>Of course, rather than do each pair one by one, it would probably be\neasier to write the dictionary in a Python module or paste it in from a\nword processor. The full Cyrillic transliteration dictionary is here:</p>\n<pre><code class=\"language-python\">cyrillic_translit={&#39;\\u0410&#39;: &#39;A&#39;, &#39;\\u0430&#39;: &#39;a&#39;,\n&#39;\\u0411&#39;: &#39;B&#39;, &#39;\\u0431&#39;: &#39;b&#39;,\n&#39;\\u0412&#39;: &#39;V&#39;, &#39;\\u0432&#39;: &#39;v&#39;,\n&#39;\\u0413&#39;: &#39;G&#39;, &#39;\\u0433&#39;: &#39;g&#39;,\n&#39;\\u0414&#39;: &#39;D&#39;, &#39;\\u0434&#39;: &#39;d&#39;,\n&#39;\\u0415&#39;: &#39;E&#39;, &#39;\\u0435&#39;: &#39;e&#39;,\n&#39;\\u0416&#39;: &#39;Zh&#39;, &#39;\\u0436&#39;: &#39;zh&#39;,\n&#39;\\u0417&#39;: &#39;Z&#39;, &#39;\\u0437&#39;: &#39;z&#39;,\n&#39;\\u0418&#39;: &#39;I&#39;, &#39;\\u0438&#39;: &#39;i&#39;,\n&#39;\\u0419&#39;: &#39;I&#39;, &#39;\\u0439&#39;: &#39;i&#39;,\n&#39;\\u041a&#39;: &#39;K&#39;, &#39;\\u043a&#39;: &#39;k&#39;,\n&#39;\\u041b&#39;: &#39;L&#39;, &#39;\\u043b&#39;: &#39;l&#39;,\n&#39;\\u041c&#39;: &#39;M&#39;, &#39;\\u043c&#39;: &#39;m&#39;,\n&#39;\\u041d&#39;: &#39;N&#39;, &#39;\\u043d&#39;: &#39;n&#39;,\n&#39;\\u041e&#39;: &#39;O&#39;, &#39;\\u043e&#39;: &#39;o&#39;,\n&#39;\\u041f&#39;: &#39;P&#39;, &#39;\\u043f&#39;: &#39;p&#39;,\n&#39;\\u0420&#39;: &#39;R&#39;, &#39;\\u0440&#39;: &#39;r&#39;,\n&#39;\\u0421&#39;: &#39;S&#39;, &#39;\\u0441&#39;: &#39;s&#39;,\n&#39;\\u0422&#39;: &#39;T&#39;, &#39;\\u0442&#39;: &#39;t&#39;,\n&#39;\\u0423&#39;: &#39;U&#39;, &#39;\\u0443&#39;: &#39;u&#39;,\n&#39;\\u0424&#39;: &#39;F&#39;, &#39;\\u0444&#39;: &#39;f&#39;,\n&#39;\\u0425&#39;: &#39;Kh&#39;, &#39;\\u0445&#39;: &#39;kh&#39;,\n&#39;\\u0426&#39;: &#39;Ts&#39;, &#39;\\u0446&#39;: &#39;ts&#39;,\n&#39;\\u0427&#39;: &#39;Ch&#39;, &#39;\\u0447&#39;: &#39;ch&#39;,\n&#39;\\u0428&#39;: &#39;Sh&#39;, &#39;\\u0448&#39;: &#39;sh&#39;,\n&#39;\\u0429&#39;: &#39;Shch&#39;, &#39;\\u0449&#39;: &#39;shch&#39;,\n&#39;\\u042a&#39;: &#39;&quot;&#39;, &#39;\\u044a&#39;: &#39;&quot;&#39;,\n&#39;\\u042b&#39;: &#39;Y&#39;, &#39;\\u044b&#39;: &#39;y&#39;,\n&#39;\\u042c&#39;: &quot;&#39;&quot;, &#39;\\u044c&#39;: &quot;&#39;&quot;,\n&#39;\\u042d&#39;: &#39;E&#39;, &#39;\\u044d&#39;: &#39;e&#39;,\n&#39;\\u042e&#39;: &#39;Iu&#39;, &#39;\\u044e&#39;: &#39;iu&#39;,\n&#39;\\u042f&#39;: &#39;Ia&#39;, &#39;\\u044f&#39;: &#39;ia&#39;}\n</code></pre>\n<p>Now that we have the transliteration dictionary, we can simply loop\nthrough every character in the source page and convert those Unicode\ncharacters in the dictionary. If we turn it into a procedure, then we\ncan reuse it for other webpages.</p>\n<pre><code class=\"language-python\">def transliterate(word, translit_table):\n    converted_word = &#39;&#39;\n    for char in word:\n        transchar = &#39;&#39;\n        if char in translit_table:\n            transchar = translit_table[char]\n        else:\n            transchar = char\n        converted_word += transchar\n    return converted_word\n</code></pre>\n<p>We can then call this function using the newly created dictionary and\nthe webpage downloaded earlier.</p>\n<pre><code class=\"language-python\">#we will run it with the cyrillic_translit dictionary and the webpage\nconverted_content = transliterate(content, cyrillic_translit)\nconverted_content[200:310]\n</code></pre>\n<p>Here is what we end up with:</p>\n<pre><code class=\"language-python\">&#39;=&quot;list-right&quot;&gt;\\r\\n&lt;li&gt;&lt;p class=&quot;name&quot;&gt;&lt;a name=&quot;n1&quot;&gt;&lt;/a&gt;A-Aku Tulikovich &lt;/p&gt;&lt;p class=&quot;cont&quot;&gt;\\r\\nRodilsia\\xa0v 1913 g.&#39;\n</code></pre>\n<p>Still not perfect. Python did not convert the special character ‘\\xa0′\nthat signifies a <em>non-breaking space</em>. But with the transliteration\ndictionary, any characters that pop up can just be added to the\ndictionary and they will be converted. First we need to find out what\nthat character is. We could search for it on the Internet or we can just\nprint it:</p>\n<pre><code class=\"language-python\">#let&#39;s find out what u&#39;\\xa0&#39; is\nprint(&#39;\\xa0&#39;)\n\n#it&#39;s not nothing but a non-breaking space\n#it would be better if our transliteration dictionary could change it into a space\n\ncyrillic_translit[&#39;\\xa0&#39;] = &#39; &#39;\n</code></pre>\n<p>With this fix, all the Cyrillic and special characters are gone, making\nit much easier to read the file and deal with it. For the last part of\nthe lesson, we will modify methods used in the lesson “<a href=\"/lessons/intro-to-beautiful-soup\">Intro to\nBeautiful Soup</a>” to get a list of transliterated names from the\nwebpage.</p>\n<h2 id=\"transliterated-list-of-names\">Transliterated List of Names</h2>\n<p>There may be cases where it is best to transliterate the entire file but\nif the goal is to transliterate and extract just a part of the data in\nthe file, it would be best to extract first and transliterate later.\nThat way Python will only transliterate a small part of the file rather\nthan having to loop through the whole of the HTML. Speed is not a huge\nissue when dealing with a handful of web pages but Memorial’s site has\nthousands of pages. The difference between looping through thousands of\nwhole pages and just looping through a small part of each of those pages\ncan add up. But, of course, it would have been anti-climactic to have\nall the names before the transliteration dictionary and also more\ndifficult for non-Cyrillic readers to understand the rest of the lesson.\nSo now we need to find a way to get just the names from the page. Here\nis the first bit of HTML from the converted_content string, containing\nparts of two database entries:</p>\n<pre><code class=\"language-python\">print(converted_content[200:1000])\n</code></pre>\n<p>This code prints out characters 200 to 1000 of the HTML, which happens\nto include the entire first entry and the beginning of the second:</p>\n<pre><code>=&quot;list-right&quot;&gt;\n&lt;li&gt;&lt;p class=&quot;name&quot;&gt;&lt;a name=&quot;n1&quot;&gt;&lt;/a&gt;A-Aku Tulikovich &lt;/p&gt;&lt;p class=&quot;cont&quot;&gt;\nRodilsia v 1913 g., Kamchatskaia gub., Tigil&#39;skii r-n, stoibishcha Utkholok; koriak-kochevnik;  malogramotnyi; b/p;\n\n&lt;br /&gt;Arestovan  12 noiabria 1938 g.\n&lt;br /&gt;Prigovoren: Koriakskii okrsud 8 aprelia 1939 g., obv.: po st. 58-2-8-9-10-11 UK RSFSR.\n&lt;br /&gt;Prigovor: 20 let. Opredeleniem Voennoi kollegii VS SSSR ot 17 oktiabria 1939 g. mera snizhena do 10 let.\nReabilitirovan 15 marta 1958 g. Reabilitirovan opredeleniem Voennoi kollegii VS SSSR\n&lt;/p&gt;&lt;p class=&quot;author&quot;&gt;Istochnik: Baza dannykh o zhertvakh repressii Kamchatskoi obl.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p class=&quot;name&quot;&gt;&lt;a name=&quot;n2&quot;&gt;&lt;/a&gt;Aab Avgust Mikhailovich&lt;/p&gt;&lt;p class=&quot;cont&quot;&gt;\nRodilsia v 1899 g., Saratovskaia obl., Grimm s.; nemets;  obrazovanie nachal&#39;noe;\n</code></pre>\n<p>Each entry includes lots of information: name (last, first and\npatronymic), date of birth, place of birth, profession, date of arrest,\ndate of sentencing and so on. If we wanted the detailed information\nabout each person, we would have to parse the page ourselves and extract\nthat information using the string manipulation techniques from the\nlesson “<a href=\"/lessons/manipulating-strings-in-python\">Manipulating Strings in Python</a>.” However, for just the names\nit will be quicker to use the HTML parsing module Beautiful Soup. If you\nhave not installed Beautiful Soup, see “<a href=\"/lessons/installing-python-modules-pip\">Installing Python Modules with pip</a>”\nand read “<a href=\"/lessons/intro-to-beautiful-soup\">Intro to Beautiful Soup</a>” for an overview of how\nthis tool works. In the transliterator module, we will load Beautiful\nSoup and then turn our converted page into a <em>Beautiful Soup object</em>.</p>\n<pre><code class=\"language-python\">#load Beautiful Soup\nfrom bs4 import BeautifulSoup\n\n#convert the page\nconverted_soup = BeautifulSoup(converted_content)\n</code></pre>\n<p>The lesson “<a href=\"/lessons/intro-to-beautiful-soup\">Intro to Beautiful Soup</a>” teaches how to grab sections of\na web page by their tags. But we can also select sections of the page by\n<em>attributes</em>, HTML code that modifies elements. Looking at the HTML from\nthis page, notice that the text of our names are enclosed in the tag\n <code>&lt;p class=&quot;name&quot;&gt;</code>. The class attribute allows the page’s <a href=\"http://www.w3schools.com/css/\">Cascading\nStyle Sheets</a> (CSS) settings to change the look of all elements that\nshare the “name” <em>class</em> at once. CSS itself is an important tool for web\ndesigners. For those interested in learning more on this aspect of CSS,\nI recommend <a href=\"https://www.codecademy.com/catalog/subject/web-development\">Code Academy’s</a> interactive lessons in its web\nfundamentals track. In mining data from the web, though, attributes like\nclass give us a pattern to separate out certain values.</p>\n<p>What we want is to get the elements where the class attribute’s value is\n“name”. When dealing with most types of attributes, Beautiful Soup can\nselect parts of the page using the same syntax as HTML. The class\nattribute makes things a little tricky because Python uses “class” to\ndefine new types of objects. Beautiful Soup gets around this by making\nus search for class followed by an underscore: <code>class_=&quot;value&quot;</code>.\nBeautiful Soup objects’ <code>.find_all()</code> method will generate a Python list\nof Beautiful Soup objects that match the HTML tags or attributes set as\n<em>parameters</em>. The method <code>.get_text()</code> extracts just the text from\nBeautiful Soup objects, so\n<code>&quot; &lt;p class=&quot;name&quot;&gt;&lt;a name=&quot;n1&quot;&gt;&lt;/a&gt;A-Aku Tulikovich&lt;/p&gt; &quot;.get_text()</code>\nwill become “<em>A-Aku Tulikovich</em>”. We need to use <code>.get_text()</code> on each\nitem in the list, then append it to a new list containing just the\nnames:</p>\n<pre><code class=\"language-python\">#creating the final names list\nnames = []\n\n#creating the list with .find_all() and looping through it\nfor entry in converted_soup.find_all(class_=&quot;name&quot;):\n    names.append(entry.get_text())\n</code></pre>\n<p>To make sure it worked, let’s check the number of names and then see if\nthey look like we expect:</p>\n<pre><code class=\"language-python\">#check the number of names\nlen(names)\n\n&gt; 190\n\n#see the first twenty names in the list\nnames[:20]\n\n&gt; [&#39;A-Aku Tulikovich &#39;, &#39;Aab Avgust Mikhailovich&#39;, &#39;Aab Avgust Khristianovich&#39;, &#39;Aab Aleksandr Aleksandrovich&#39;, &quot;Aab Aleksandr Khrist&#39;ianovich&quot;, &quot;Aab Al&#39;bert Viktorovich&quot;, &quot;Aab Al&#39;brekht Aleksandrovich&quot;, &#39;Aab Amaliia Andreevna&#39;, &#39;Aab Amaliia Ivanovna&#39;, &#39;Aab Angelina Andreevna&#39;, &#39;Aab Andrei Andreevich&#39;, &#39;Aab Andrei Filippovich&#39;, &#39;Aab Arvid Karlovich&#39;, &quot;Aab Arnol&#39;d Aleksandrovich&quot;, &#39;Aab Artur Avgustovich&#39;, &quot;Aab Artur Vil&#39;gel&#39;movich&quot;, &quot;Aab Aelita Arnol&#39;dovna&quot;, &#39;Aab Viktor Aleksandrovich&#39;, &#39;Aab Viktor Aleksandrovich&#39;, &quot;Aab Viktor Vil&#39;gel&#39;movich&quot;]\n</code></pre>\n<p>Transliteration can only do so much. Except for proper names, it can\ntell you little about the content of the source being transliterated.\nYet the ability to transliterate automatically is of great use when\ndealing with lots of names or for people who prefer or need to use ASCII\ncharacters. It is a simple tool but one that can be an enormous time\nsaver.</p>\n"}