{"metadata":{"title":"Output Keywords in Context in an HTML File with Python","layout":"lesson","date":"2012-07-17T00:00:00.000Z","authors":["William J. Turkel","Adam Crymble"],"reviewers":["Jim Clifford","Frederik Elwert"],"editors":["Miriam Posner"],"difficulty":2,"exclude_from_check":["review-ticket"],"activity":"presenting","topics":["python"],"abstract":"This lesson builds on 'Keywords in Context (Using N-grams)', where n-grams were extracted from a text. Here, you will learn how to output all of the n-grams of a given keyword in a document downloaded from the Internet, and display them clearly in your browser window.","next":"downloading-multiple-records-using-query-strings","previous":"keywords-in-context-using-n-grams","series_total":"15 lessons","sequence":14,"python_warning":false,"redirect_from":"/lessons/output-keywords-in-context-in-html-file","avatar_alt":"A monkey dancing with a lion and a bear","doi":"10.46430/phen0016"},"html_body":"<p>{% include toc.html %}</p>\n<h2 id=\"lesson-goals\">Lesson Goals</h2>\n<p>This lesson builds on <a href=\"/lessons/keywords-in-context-using-n-grams\">Keywords in Context (Using N-grams)</a>, where\nn-grams were extracted from a text. Here, you will learn how to output\nall of the n-grams of a given keyword in a document downloaded from the\nInternet, and display them clearly in your browser window.</p>\n<h2 id=\"files-needed-for-this-lesson\">Files Needed For This Lesson</h2>\n<ul>\n<li><code>obo.py</code></li>\n</ul>\n<p>If you do not have these files from the previous lesson, you can\ndownload a <a href=\"/assets/python-lessons8.zip\">zip file from the previous lesson</a></p>\n<h2 id=\"making-an-n-gram-dictionary\">Making an N-Gram Dictionary</h2>\n<p>Our n-grams have an odd number of words in them for a reason. At this\npoint, our n-grams don&quot;t actually have a keyword; they&#39;re just a list of\nwords. However, if we have an odd numbered n-gram the middle word will\nalways have an equal number of words to the left and to the right. We\ncan then use that middle word as our keyword. For instance, [&quot;it&quot;,\n&quot;was&quot;, &quot;the&quot;, &quot;best&quot;, &quot;of&quot;, &quot;times&quot;, &quot;it&quot;] is a 7-gram of the keyword\n&quot;best&quot;.</p>\n<p>Since we have a long text, we want to be able to output all n-grams for\nour keyword. To do this we will put each n-gram into a <em>dictionary</em>, using\nthe middle word as the <em>key</em>. To figure out the keyword for each n-gram we\ncan use the <em>index positions</em> of the list. If we are working with 5-grams,\nfor example, the left context will consist of terms indexed by 0, 1, the\nkeyword will be indexed by 2, and the right context terms indexed by 3,\n4. Since Python indexes start at 0, a 5-gram&#39;s keyword will always be at\nindex position 2.</p>\n<p>That&#39;s fine for 5-grams, but to make the code a bit more robust, we want\nto make sure it will work for any length n-gram, assuming its length is\nan odd number. To do this we&#39;ll take the length of the n-gram, divide it\nby 2 and drop the remainder. We can achieve this using Python&#39;s <code>floor division</code> operator, represented by two slashes, which divides and then\nreturns an answer to the nearest whole number, always rounding down –\nhence the term &quot;floor&quot;.</p>\n<pre><code class=\"language-python\">print(7 // 2)\nprint(5 // 2)\nprint(3 // 2)\n</code></pre>\n<p>Let&#39;s build a function that can identify the index position of the\nkeyword when given an n-gram with an odd number of words. Save the\nfollowing to <code>obo.py</code>.</p>\n<pre><code class=\"language-python\"># Given a list of n-grams identify the index of the keyword.\n\ndef nGramsToKWICDict(ngrams):\n    keyindex = len(ngrams[0]) // 2\n\n    return keyindex\n</code></pre>\n<p>To determine the index of the keyword, we have used the <code>len</code> property to\ntell us how many items are in the first n-gram, then used floor division\nto isolate the middle index position. You can see if this worked by\ncreating a new program, <code>get-keyword.py</code> and running it. If all goes\nwell, since we are dealing with a 5-gram, you should get 2 as the index\nposition of the keyword as we determined above.</p>\n<pre><code class=\"language-python\">#get-keyword.py\n\nimport obo\n\ntest = &#39;this test sentence has eight words in it&#39;\nngrams = obo.getNGrams(test.split(), 5)\n\nprint(obo.nGramsToKWICDict(ngrams))\n</code></pre>\n<p>Now that we know the location of the keywords, let&#39;s add everything to a\ndictionary that can be used to output all KWIC n-grams of a particular\nkeyword. Study this code and then replace your <code>nGramsToKWICDict</code> with\nthe following in your <code>obo.py</code> module.</p>\n<pre><code class=\"language-python\"># Given a list of n-grams, return a dictionary of KWICs,\n# indexed by keyword.\n\ndef nGramsToKWICDict(ngrams):\n    keyindex = len(ngrams[0]) // 2\n\n    kwicdict = {}\n\n    for k in ngrams:\n        if k[keyindex] not in kwicdict:\n            kwicdict[k[keyindex]] = [k]\n        else:\n            kwicdict[k[keyindex]].append(k)\n    return kwicdict\n</code></pre>\n<p>A <code>for</code> loop and <code>if</code> statement checks each n-gram to see if its keyword is\nalready stored in the dictionary. If it isn&#39;t, it&#39;s added as a new\nentry. If it is, it&#39;s appended to the previous entry. We now have a\ndictionary named <em>kwicdict</em> that contains all the n-grams, sortable by\nkeyword and we can turn to the task of outputting the information in a\nmore useful format as we did in <a href=\"/lessons/output-data-as-html-file\">Output Data as HTML File</a>.</p>\n<p>Try rerunning the <code>get-keyword.py</code> program and you should now see what&#39;s\nin your KWIC dictionary.</p>\n<h2 id=\"outputting-to-html\">Outputting to HTML</h2>\n<h3 id=\"pretty-printing-a-kwic\">Pretty Printing a KWIC</h3>\n<p>&quot;Pretty printing&quot; is the process of formatting output so that it can be\neasily read by human beings. In the case of our keywords in context, we\nwant to have the keywords lined up in a column, with the terms in the\nleft-hand context right justified, and the terms in the right-hand\ncontext left justified. In other words, we want our KWIC display to look\nsomething like this:</p>\n<pre><code>               amongst them a black there was one\n                first saw the black i turned to\n             had observed the black in the mob\n                 say who that black was no seeing\n                      i saw a black at first but\n                 swear to any black yes there is\n                   swear to a black than to a\n                              ...\n</code></pre>\n<p>This technique is not the best way to format text from a web designer&#39;s\nperspective. If you have some experience with HTML we encourage you to\nuse another method that will create a standards compliant HTML file, but\nfor new learners, we just can&#39;t resist the ease of the technique we&#39;re\nabout to describe. After all, the point is to integrate programming\nprinciples quickly into your research.</p>\n<p>To get this effect, we are going to need to do a number of list and\nstring manipulations. Let&#39;s start by figuring out what our dictionary\noutput will look like as it currently stands. Then we can work on\nrefining it into what we want.</p>\n<pre><code class=\"language-python\"># html-to-pretty-print.py\nimport obo\n\n# create dictionary of n-grams\nn = 7\nurl = &#39;http://www.oldbaileyonline.org/browse.jsp?id=t17800628-33&amp;div=t17800628-33&#39;\n\ntext = obo.webPageToText(url)\nfullwordlist = obo.stripNonAlphaNum(text)\nngrams = obo.getNGrams(fullwordlist, n)\nworddict = obo.nGramsToKWICDict(ngrams)\n\nprint(worddict[&quot;black&quot;])\n</code></pre>\n<p>As you can see when you run the above program, the output is not very\nreadable yet. What we need to do is split the n-gram into three parts:\nbefore the keyword, the keyword, and after the keyword. We can then use\nthe techniques learned in the previous chapters to wrap everything in\nHTML so that it is easy to read.</p>\n<p>Using the same <code>slice</code> method as above, we will create our three parts.\nOpen a Python shell and try the following examples. Pay close attention\nto what appears before and after the colon in each case. Knowing how to\nmanipulate the slice method is a powerful skill for a new programming\nhistorian.</p>\n<pre><code class=\"language-python\"># ParseError: Could not check this chunk!\n# calculate the length of the n-gram\nkwic = &#39;amongst them a black there was one&#39;.split()\nn = len(kwic)\nprint(n)\n-&gt; 7\n\n# calculate the index position of the keyword\nkeyindex = n // 2\nprint(keyindex)\n-&gt; 3\n\n# display the items before the keyword\nprint(kwic[:keyindex])\n-&gt; [&#39;amongst&#39;, &#39;them&#39;, &#39;a&#39;]\n\n# display the keyword only\nprint(kwic[keyindex])\n-&gt; black\n\n# display the items after the keyword\nprint(kwic[(keyindex+1):])\n-&gt; [&#39;there&#39;, &#39;was&#39;, &#39;one&#39;]\n</code></pre>\n<p>Now that we know how to find each of the three segments, we need to\nformat each to one of three columns in our display.</p>\n<p>The right-hand context is simply going to consist of a string of terms\nseparated by blank spaces. We’ll use the <code>join</code> method to turn the list\nentries into a string.</p>\n<pre><code class=\"language-python\"># ParseError: Could not check this chunk!\nprint(&#39; &#39;.join(kwic[(keyindex+1):]))\n-&gt; there was one\n</code></pre>\n<p>We want the keywords to have a bit of <em>whitespace</em> padding around them. We\ncan achieve this by using a string method called <code>center</code>, which will\nalign the text to the middle of the screen. We can add padding by making\nthe overall string be longer than the keyword itself. The expression\nbelow adds three blank spaces (6/2) to either side of the keyword. We&#39;ve\nadded hash marks at the beginning and end of the expression so you can\nsee the leading and trailing blanks.</p>\n<pre><code class=\"language-python\">print(&#39;#&#39; + str(kwic[keyindex]).center(len(kwic[keyindex])+6) + &#39;#&#39;)\n-&gt; #   black   #\n</code></pre>\n<p>Finally, we want the left-hand context to be right justified. Depending\non how large <em>n</em> is, we are going to need the overall length of this\ncolumn to increase. We do this by defining a variable called <em>width</em> and\nthen making the column length a multiple of this variable (we used a\nwidth of 10 characters, but you can make it larger or smaller as\ndesired). The <code>rjust</code> method handles right justification. Once again,\nwe&#39;ve added hash marks so you can see the leading blanks.</p>\n<pre><code class=\"language-python\">width = 10\nprint(&#39;#&#39; + &#39; &#39;.join(kwic[:keyindex]).rjust(width*keyindex) + &#39;#&#39;)\n-&gt; #                 amongst them a#\n</code></pre>\n<p>We can now combine these into a function that takes a KWIC and returns a\npretty-printed string. Add this to the <code>obo.py</code> module. Study the code\nto make sure you understand it before moving on.</p>\n<pre><code class=\"language-python\"># Given a KWIC, return a string that is formatted for\n# pretty printing.\n\ndef prettyPrintKWIC(kwic):\n    n = len(kwic)\n    keyindex = n // 2\n    width = 10\n\n    outstring = &#39; &#39;.join(kwic[:keyindex]).rjust(width*keyindex)\n    outstring += str(kwic[keyindex]).center(len(kwic[keyindex])+6)\n    outstring += &#39; &#39;.join(kwic[(keyindex+1):])\n\n    return outstring\n</code></pre>\n<h2 id=\"putting-it-all-together\">Putting it All Together</h2>\n<p>We can now create a program that, given a URL and a keyword, wraps a\nKWIC display in HTML and outputs it in Firefox. This program begins and\nends in a similar fashion as the program that computed word frequencies.\nType or copy the code into your text editor, save it as\n<code>html-to-kwic.py</code>, and execute it. You will need to choose either\nobo.wrapStringInHTMLMac() or obo.wrapStringInHTMLWindows() as appropriate\nfor your system, as done before.</p>\n<pre><code class=\"language-python\"># html-to-kwic.py\n\nimport obo\n\n# create dictionary of n-grams\nn = 7\nurl = &#39;http://www.oldbaileyonline.org/browse.jsp?id=t17800628-33&amp;div=t17800628-33&#39;\n\ntext = obo.webPageToText(url)\nfullwordlist = (&#39;# &#39; * (n//2)).split()\nfullwordlist += obo.stripNonAlphaNum(text)\nfullwordlist += (&#39;# &#39; * (n//2)).split()\nngrams = obo.getNGrams(fullwordlist, n)\nworddict = obo.nGramsToKWICDict(ngrams)\n\n# output KWIC and wrap with html\ntarget = &#39;black&#39;\noutstr = &#39;&lt;pre&gt;&#39;\nif target in worddict:\n    for k in worddict[target]:\n        outstr += obo.prettyPrintKWIC(k)\n        outstr += &#39;&lt;br /&gt;&#39;\nelse:\n    outstr += &#39;Keyword not found in source&#39;\n\noutstr += &#39;&lt;/pre&gt;&#39;\nobo.wrapStringInHTML(&#39;html-to-kwic&#39;, url, outstr)\n</code></pre>\n<p>The first part is the same as above. In the second half of the program,\nwe&#39;ve wrapped everything in the HTML <em>pre</em> tag (pre-formatted), which\ntells the browser not to monkey with any of the spacing we&#39;ve added.</p>\n<p>Also, notice that we use the <code>has_key</code> dictionary method to make sure\nthat the keyword actually occurs in our text. If it doesn&#39;t, we can\nprint a message for the user before sending the output to Firefox. Try\nchanging the target variable to a few other keywords. Try one you know\nisn&#39;t there to make sure your program doesn&#39;t output something when it\nshouldn&#39;t.</p>\n<p>We have now created a program that looks for a keyword in a dictionary\ncreated from an HTML page on the web, and then outputs the n-grams of\nthat keyword to a new HTML file for display on the web. All of the\nlessons up to this point have included parts of Python vocabulary and\nmethods needed to create this final program. By referring to those\nlessons, you can now experiment with Python to create programs that\naccomplish specific tasks that will help in your research process.</p>\n<h2 id=\"code-syncing\">Code Syncing</h2>\n<p>This marks the end of this series of original lessons on python. The finished code\nfor the series can be downloaded as a zip file. If you are following along\nwith the Mac / Linux version you may have to open the <code>obo.py</code> file and\nchange &quot;file:///Users/username/Desktop/programming-historian/&quot; to the\npath to the directory on your own computer.</p>\n<ul>\n<li>python-lessons9.zip <a href=\"/assets/python-lessons9.zip\">zip sync</a></li>\n</ul>\n<p>There is an additional lesson on using Python to download multiple records using Query Strings, marked as the next lesson.</p>\n"}