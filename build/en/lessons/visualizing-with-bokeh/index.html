<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="description" content="" />
		<link rel="icon" href="/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		

		

		<link rel="stylesheet" href="/_app/assets/start-61d1577b.css">
		<link rel="modulepreload" href="/_app/start-c09d08cd.js">
		<link rel="modulepreload" href="/_app/chunks/vendor-9b9d6288.js">
		<link rel="modulepreload" href="/_app/pages/__layout.svelte-de46afb2.js">
		<link rel="modulepreload" href="/_app/pages/_lang_/__layout.svelte-e75718c6.js">
		<link rel="modulepreload" href="/_app/chunks/stores-191d1505.js">
		<link rel="modulepreload" href="/_app/pages/_lang_/_lessons_/_slug_/index.svelte-efe77d76.js">

		<script type="module">
			import { start } from "/_app/start-c09d08cd.js";
			start({
				target: document.querySelector("#svelte"),
				paths: {"base":"","assets":""},
				session: {},
				route: true,
				spa: false,
				trailing_slash: "never",
				hydrate: {
					status: 200,
					error: null,
					nodes: [
						import("/_app/pages/__layout.svelte-de46afb2.js"),
						import("/_app/pages/_lang_/__layout.svelte-e75718c6.js"),
						import("/_app/pages/_lang_/_lessons_/_slug_/index.svelte-efe77d76.js")
					],
					url: new URL("sveltekit://prerender/en/lessons/visualizing-with-bokeh"),
					params: {lang:"en",lessons:"lessons",slug:"visualizing-with-bokeh"}
				}
			});
		</script><script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('/service-worker.js');
			}
		</script>
	</head>
	<body>
		<div id="svelte">


The Programming Historian <a href="/en">English</a> <a href="/es">Spanish</a>
<br>
This is the en edition.

<h1>Visualizing Data with Bokeh and Pandas</h1>

<!-- HTML_TAG_START --><h1 id="contents">Contents</h1>
<p>{% include toc.html %}</p>
<h1 id="overview">Overview</h1>
<p>The ability to load raw data, sample it, and then visually explore and present it is a valuable skill across disciplines. In this tutorial, you will learn how to do this in Python by using the Bokeh and Pandas libraries. Specifically, we will work through visualizing and exploring aspects of WWII bombing runs conducted by Allied powers.</p>
<p>At the end of the lesson you will be able to:</p>
<ul>
<li>Load tabular CSV data</li>
<li>Perform basic data manipulation, such as aggregating and sub-sampling raw data</li>
<li>Visualize quantitative, categorical, and geographic data for web display</li>
<li>Add varying types of interactivity to your visualizations</li>
</ul>
<p>To reach these goals, we&#39;ll work through a variety of visualization examples using THOR, a dataset that describes historical bombing operations.</p>
<h2 id="the-wwii-thor-dataset">The WWII THOR Dataset</h2>
<p>The Theater History of Operations Reports (THOR) lists aerial bombing operations during World War I, World War II, the Korean War, and the Vietnam War undertaken by the United States and Allied Powers. The records were compiled from declassified documents by Lt. Col. Jenns Robertson. THOR is made publicly available through a partnership between the US Department of Defense and <a href="https://data.world/datamil">data.world</a>.</p>
<p>Each row in the THOR dataset contains information on a single mission or bombing run. This information can include the mission date, takeoff and target locations, the target type, aircraft involved, and the types and weights of bombs dropped on the target. The <a href="https://data.world/datamil/thor-data-dictionary">THOR data dictionary</a> provides detailed information on the structure of the dataset.</p>
<p>For this tutorial, we&#39;ll use a modified version of the WWII THOR dataset. The original, full-version of the dataset consists of 62 columns of information digitized from the paper forms. To make this dataset more manageable for our purposes, this has been reduced to 19 columns that include core mission information and bombing data. These columns are discussed below when we first load the data. The unabridged dataset is available for download <a href="https://data.world/datamil/world-war-ii-thor-data">here</a>.</p>
<p>The dataset used in this tutorial is contained in <a href="https://github.com/programminghistorian/ph-submissions/tree/gh-pages/assets/visualizing-with-bokeh/thor_wwii.csv">thor_wwii.csv</a>. This file is required to complete most of the examples below.</p>
<p>We&#39;ll use Bokeh and Pandas to address some of the following questions:</p>
<ul>
<li>What types and weights of munitions were dropped during World War II (WWII)? What patterns can we discern in the use of different types of munitions?</li>
<li>How did the types and weights of munitions dropped change over the course of WWII? How do these changes correspond to major military events?</li>
<li>What targets were munitions dropped on during the war? Were particular types of munitions limited to certain theaters of operations or targets?</li>
</ul>
<h2 id="other-possible-datasets">Other Possible Datasets</h2>
<p>If this dataset doesn&#39;t fit your interests or if you&#39;d like more practice after completing this tutorial, here are a few other interesting datasets that you might wish to use with Bokeh and Pandas:</p>
<ul>
<li><p><a href="https://data.world/history/scottish-witchcraft/">Scottish Witchcraft Trials</a>: A multi-table set of data on over 4,000 people accused of witchcraft between 1536 and 1736.</p>
</li>
<li><p><a href="https://data.world/history/civil-unrest-event-data">Civil Unrest Events</a>: A single table cataloging over 60,000 events of civil unrest across the world since the end of World War II.</p>
</li>
<li><p><a href="https://www.slavevoyages.org/voyage/database">Trans-Atlantic Slave Trade Database</a>: Searchable and customizable tabular data on 36,000 slaving voyages that transported over 10 million slaves from the 16th to 19th centuries.</p>
</li>
</ul>
<p>All three datasets contain comparable quantitative, qualitative, and temporal data to those found in the THOR dataset. The Civil Unrest Events and Trans-Atlantic Slave Trade datasets both contain spatial data, though this is lacking from the Scottish Witchcraft Trials data.</p>
<h1 id="getting-started">Getting Started</h1>
<h2 id="prerequisites">Prerequisites</h2>
<p>This tutorial can be completed using any operating systems. It requires Python 3 and a web browser. You may use any text editor to write your code.</p>
<p>This tutorial assumes that you have a basic knowledge of the Python language and its associated data structures, particularly lists.</p>
<p>If you work in Python 2, you will need to create a virtual environment for Python 3, and even if you work in Python 3, creating a virtual environment for this tutorial is good practice.</p>
<h2 id="creating-a-python-3-virtual-environment">Creating a Python 3 Virtual Environment</h2>
<p>A Python virutal environment is an isolated environment in which you can install libraries and execute code. Many different virtual evironments can be created to work with different versions of Python and Python libraries. Virtual environments are useful because they ensure you have only the necessary libraries installed and that you do not encounter version conflicts. An additional benefit of virtual environments is that you can pass them to others so that you know your code will execute on another machine.</p>
<p><a href="https://conda.io/miniconda.html">Miniconda</a> is one easy way to create virtual environments that is simple to install across operating systems. You should download Miniconda and follow the instructions for <a href="https://conda.io/projects/conda/en/latest/user-guide/install/windows.html">Windows</a>, <a href="https://conda.io/projects/conda/en/latest/user-guide/install/macos.html">Mac</a>, or <a href="https://conda.io/projects/conda/en/latest/user-guide/install/linux.html">Linux</a> as appropriate for your operating system.</p>
<p>Once you have downloaded and installed Miniconda for your operating system, you can check that it has installed correctly by opening a command line and typing:</p>
<pre><code class="language-python">conda info
</code></pre>
<p>If you see version information similar to the following, then Miniconda has installed correctly.</p>
<pre><code class="language-python">Current conda install:
               platform : linux-64
          conda version : 4.3.29
          ...
</code></pre>
<p>We&#39;ll use Miniconda to create a Python 3 virtual environment named <em>bokeh-env</em> for this tutorial. In the command line type the following:</p>
<pre><code class="language-python">conda create --name bokeh-env python=3.6
</code></pre>
<p>Say &#39;yes&#39; when you are prompted to install new packages.</p>
<p>To activate the <em>bokeh-env</em> virtual environment, the command differs slightly depending on your operating system.</p>
<pre><code class="language-python">source activate bokeh-env #For Linux/MacOS
activate bokeh-env #For Windows
</code></pre>
<p>Your command line should now show that you are in the <em>bokeh-env</em> virtual environment.</p>
<p>When you would like to leave the virtual environment, you can type the command appropriate for your operating system.</p>
<pre><code class="language-python">source deactivate #For Linux/MacOS
deactivate #For Windows
</code></pre>
<h2 id="installing-packages">Installing Packages</h2>
<p>In your activated <em>bokeh-env</em> virtual environment, issue the following command to install the python packages for this tutorial.</p>
<pre><code class="language-python">pip install pandas bokeh pyproj
</code></pre>
<p>To get the exact versions used to write this tutorial (note: these may not be the most recent versions of each python package) you can pass the following version numbers to <code>pip</code>.</p>
<pre><code class="language-python">pip install &quot;pandas&gt;=1.2.0,&lt;1.2.3&quot; &quot;bokeh&gt;=2.0.0,&lt;2.3.0&quot; &quot;pyproj&gt;=3.0,&lt;3.0.1&quot;
</code></pre>
<h2 id="running-code-examples">Running Code Examples</h2>
<div class="alert alert-info">

<p>At this point in the lesson, you have a choice of two ways to experiment with &quot;Running Code Examples&quot;. You can either proceed in the command line and do the coding by hand, or run the Jupyter notebook provided <a href="https://github.com/programminghistorian/ph-submissions/tree/gh-pages/assets/visualizing-with-bokeh/visualizing-with-bokeh.ipynb">here</a>. Beginners who simply want to get a sense of how the code  operates, rather than write it themselves, may find the Jupyter notebook option especially helpful.</p>
</div>

<p>It is easiest first to create a single directory and save each code example as a <em>.py</em> within it. When you are ready to run the code file, navigate to this directory in your command prompt and make sure your virtual environment is activated. Remember that you can always activate the environment with the following command appropriate for your operating system.</p>
<pre><code class="language-python">source activate bokeh-env #For Linux/MacOS
activate bokeh-env #For Windows
</code></pre>
<p>Within the virtual environment, you can run your code by typing:</p>
<pre><code class="language-python">python filename.py
</code></pre>
<p>A Jupyter Notebook containing the code used in this tutorial is also <a href="https://github.com/programminghistorian/ph-submissions/tree/gh-pages/assets/visualizing-with-bokeh/visualizing-with-bokeh.ipynb">available</a> in case you prefer to work through the tutorial without installing a virtual environment. You can learn more about Jupyter Notebook <a href="http://jupyter.org">here</a>. If you have created a virtual environment using Miniconda, as discussed above, you can install Jupyter Notebook in the environment by typing <code>conda install jupyter</code></p>
<h1 id="the-basics-of-bokeh">The Basics of Bokeh</h1>
<h2 id="what-is-bokeh">What is Bokeh?</h2>
<p>Bokeh is a library for creating interactive data visualizations in a web browser. It offers a concise, human-readable syntax, which allows for rapidly presenting data in an aesthetically pleasing manner. If you&#39;ve worked with visualization in Python before, it&#39;s likely that you have used <a href="https://matplotlib.org">matplotlib</a>. It&#39;s worth briefly mentioning how Bokeh differs from matplotlib, and when one might be preferred to the other.</p>
<p>Matplotlib has existed since 2002 and has long been a standard of Python data visualization. Bokeh emerged in 2013. This difference in age means that Matplotlib matured long before Bokeh was released; however, in a short period of time, Bokeh has reached a high level of maturity.</p>
<p>The intended uses of matplotlib and Bokeh are quite different. Matplotlib creates static graphics that are useful for quick and simple visualizations, or for creating publication quality images. Bokeh creates visualizations for display on the web (whether locally or embedded in a webpage) and most importantly, the visualizations are meant to be highly interactive. Matplotlib does not offer either of these features.</p>
<p>If would you like to visually interact with your data in an exploratory manner or you would like to distribute interactive visual data to a web audience, Bokeh is the library for you! If your main interest is producing finalized visualizations for publication, matplotlib may be better, although Bokeh does offer a way to create static graphics.</p>
<p>With this differences in mind, as we work through the lesson, I&#39;ll emphasize the interactive aspects that make Bokeh useful for exploring and disseminating historical data and that set it apart from other libraries like matplotlib.</p>
<h2 id="your-first-plot">Your First Plot</h2>
<p>First, create a new file called <code>my_first_plot.py</code> in the same directory as  <code>wwii_thor.csv</code> and then open it up in a text editor. We&#39;ll be adding lines to this file to run.</p>
<pre><code class="language-python">#my_first_plot.py
from bokeh.plotting import figure, output_file, show
</code></pre>
<p>To implement and use Bokeh, we first import some basics that we need from the <code>bokeh.plotting</code> module.</p>
<p><code>figure</code> is the core object that we will use to create plots. <code>figure</code> handles the styling of plots, including title, labels, axes, and grids, and it exposes methods for adding data to the plot. The <code>output_file</code> function defines how the visualization will be rendered (namely to an html file) and the <code>show</code> function will be invoked when the plot is ready for output. <code>show</code> tells Bokeh that all of the data has been added to the plot and it is time to render it.</p>
<pre><code class="language-python">output_file(&#39;my_first_graph.html&#39;)
</code></pre>
<p>Bokeh recommends that <code>output_file</code>, to which we pass a file name, be called at the start of your script, immediately after imports. An alternative output function to be aware of is <code>output_notebook</code> which is used to show plots in-line in a Jupyter Notebook. To learn more about installing and using Jupyter notebooks, see <a href="https://jupyter.readthedocs.io/en/latest/">Jupyter&#39;s documentation</a>.</p>
<pre><code class="language-python">x = [1, 3, 5, 7]
y = [2, 4, 6, 8]
</code></pre>
<p>Next we&#39;ll create some data to plot. Data in Bokeh can take on different forms, but at its simplest, data is just a list of values. We create one list for our x-axis and one for our y-axis.</p>
<p>With our output format and data fixed, we can instantiate a <code>figure</code> and  add the data to it.</p>
<pre><code class="language-python">p = figure()

p.circle(x, y, size=10, color=&#39;red&#39;, legend=&#39;circle&#39;)
p.line(x, y, color=&#39;blue&#39;, legend=&#39;line&#39;)
p.triangle(y, x, color=&#39;gold&#39;, size=10, legend=&#39;triangle&#39;)
</code></pre>
<p>{% include alert.html text=&quot;<code>p</code> is a common variable name for a <code>figure</code> object, since a figure is a type of plot.&quot; %}</p>
<p>After instantiating the figure, we call the <code>circle</code> , <code>line</code>, and <code>triangle</code> methods to plot our data. These types of methods are known as a <em>glyph method</em>. The term <em>glyph</em> in Bokeh refers to the lines, circles, bars, and other shapes that are added to plots to display data.</p>
<p>If we wanted, we could just keep adding glyphs to the plot! In addition to the <code>circle</code>, <code>line</code>,   and <code>triangle</code> glyphs, there are many others, including:  <code>asterisk</code>, <code>circle_cross</code>, <code>circle_x</code>, <code>cross</code>, <code>diamond</code>, <code>diamond_cross</code>, <code>inverted_triangle</code>, <code>square</code>, <code>square_cross</code>, <code>square_x</code>, and <code>x</code>.</p>
<p>When calling a glyph method, at a minimum, we must pass the data we would like to plot, but frequently we might add styling arguments. Here, we set a size, color, and legend name for each glyph.</p>
<pre><code class="language-python">p.legend.click_policy=&#39;hide&#39;
</code></pre>
<p>We will also add our first piece of code that brings some interactivity to the plot. By setting a <code>click_policy</code> on our legend, a user can now click on each legend entry (e.g. circle, line, triangle) to show/hide that piece of data! The <code>click_policy</code> can also be set to <code>mute</code> instead of <code>hide</code>. This would mute the color of that data on clicking rather than hide it completely.</p>
<pre><code class="language-python">show(p)
</code></pre>
<p>Calling <code>show</code> and passing the instantiated <code>figure</code> will output the results to our html file. Now let&#39;s run this code!</p>
<p>In your command line, make sure you&#39;re in the directory where you&#39;ve saved the file and then run the file with the <code>python</code> command.</p>
<pre><code>python my_first_plot.py
</code></pre>
<p>{% include figure.html filename=&quot;visualizing-with-bokeh-1.png&quot; caption=&quot;Plotting a Single Glyph&quot; %}</p>
<p>A web browser will now appear showing the html file with your visualization. The red circles, blue line, and gold triangles are the result of our glyph method calls. Clicking the legend in the upper right corner will show/hide each glyph type. Note that Bokeh has automatically handled the creation of the grid-lines and tick labels.</p>
<p>Along the right-hand side, the default toolbar is also displayed. The tools include drag, box zoom, wheel zoom, save, reset, and help. Using these tools, a user can pan along the plot or zoom in on interesting portions of the data. Since this is a stand-alone HTML page, which includes a reference to BokehJS, it can be immediately passed to a co-worker for exploration or posted to the web.</p>
<h1 id="bokeh-and-pandas-exploring-the-wwii-thor-dataset">Bokeh and Pandas: Exploring the WWII THOR Dataset</h1>
<p>In the previous example, we manually created two short Python lists for our x and y data. What happens when you have real-world data with tens-of-thousands of rows and dozens of columns stored in an external format? Pandas, a widely-used data science library, is ideally suited to this type of data and integrates seamlessly with Bokeh to create interactive visualizations of data.</p>
<h2 id="pandas-overview">Pandas Overview</h2>
<p>For the purposes of this tutorial, I will only touch on the basic functions of Pandas that are necessary to produce our visualizations. <a href="https://pandas.pydata.org/pandas-docs/stable/10min.html">10 Minutes to Pandas</a> and <a href="https://pandas.pydata.org/pandas-docs/stable/tutorials.html#lessons-for-new-pandas-users">Lessons for New Pandas Users</a> are excellent introductions that I would recommend for expanding your knowledge beyond the very basics touched on here.</p>
<p>Pandas has quickly become the <em>de facto</em> Python library for data and data science workflows; integration with other major data science and machine learning libraries has only fueled a rise in popularity.[^1] Pandas provides functionality to quickly and efficiently read, write, and modify datasets for analysis. To accomplish this, Pandas provides data structures that hold different dimensionalities of data. The <code>DataFrame</code> holds 2-dimensional data in the manner of a spreadsheet with rows and columns. It&#39;s through this object that we&#39;ll interact with our WWII THOR dataset. Let&#39;s first examine the Pandas <code>DataFrame</code> by loading our csv data into one.</p>
<h2 id="loading-data-in-pandas">Loading Data in Pandas</h2>
<p>To begin with, create a new file called <code>loading_data.py</code>.</p>
<pre><code class="language-python">#loading_data.py
import pandas as pd

df = pd.read_csv(&#39;thor_wwii.csv&#39;)
print(df)
</code></pre>
<p>We start by importing the Pandas library and then calling <code>read_csv()</code> and passing a filename to it. Note that the Pandas library is aliased as <em>pd</em>. This alias is a convention followed in the <a href="https://pandas.pydata.org/pandas-docs/stable/">Pandas official documentation</a> and is widely used by the Pandas community. For this reason, I&#39;ll use the <em>pd</em> alias throughout the tutorial.</p>
<p>In this code, <code>read_csv</code> creates a <code>DataFrame</code> that holds the rows/columns of our csv data. By convention, the variable name <em>df</em> is used to represent the loaded dataframe in tutorials and basic code examples. <a href="https://pandas.pydata.org/pandas-docs/stable/api.html#input-output">Many other methods</a> exist for reading data formats other than csv in Pandas, such as JSON, SQL tables, Excel files, and HTML.</p>
<p>When running this code, <code>print(df)</code> will output an abridged representation of the loaded data.</p>
<pre><code class="language-python">MSNDATE      THEATER    COUNTRY_FLYING_MISSION    ...     TONS_IC TONS_FRAG TOTAL_TONS
03/30/1941          ETO          GREAT BRITAIN    ...         0.0       0.0        0.0
11/24/1940          ETO          GREAT BRITAIN    ...         0.0       0.0        0.0
12/04/1940          ETO          GREAT BRITAIN    ...         0.0       0.0        0.0
12/31/1940          ETO          GREAT BRITAIN    ...         0.0       0.0        0.0

[178281 rows x 19 columns]
</code></pre>
<p>This shows that we have 178,281 records of missions with 19 columns per record. To see what the 19 columns are in full, we can access the dataframe&#39;s  <code>columns</code> object by replacing <code>print(df)</code> in the above code with:</p>
<pre><code class="language-python">df.columns.tolist()
</code></pre>
<p>The output should look like:</p>
<pre><code class="language-python">[&#39;MSNDATE&#39;, &#39;THEATER&#39;, &#39;COUNTRY_FLYING_MISSION&#39;, &#39;NAF&#39;, &#39;UNIT_ID&#39;, &#39;AIRCRAFT_NAME&#39;, &#39;AC_ATTACKING&#39;, &#39;TAKEOFF_BASE&#39;, &#39;TAKEOFF_COUNTRY&#39;, &#39;TAKEOFF_LATITUDE&#39;, &#39;TAKEOFF_LONGITUDE&#39;, &#39;TGT_COUNTRY&#39;, &#39;TGT_LOCATION&#39;, &#39;TGT_LATITUDE&#39;, &#39;TGT_LONGITUDE&#39;, &#39;TONS_HE&#39;, &#39;TONS_IC&#39;, &#39;TONS_FRAG&#39;, &#39;TOTAL_TONS&#39;]
</code></pre>
<p>Some of these column names are self explanatory, but it&#39;s worth pointing out the following: MSNDATE (mission date), NAF (numbered airforce responsible for mission), AC_ATTACKING (number of aircraft), TONS_HE (high-explosives), TONS_IC (incendiary devices), TONS_FRAG (fragmentation bombs).</p>
<p>When it comes to accessing data within a <code>DataFrame</code>, in this tutorial we use one basic approach: indexing. Here to access a single column we pass a string to our dataframe&#39;s indexer: e.g. <code>df[&#39;MSNDATE&#39;]</code>.  To access multiple columns, we pass a list of names to our dataframe&#39;s indexer: e.g. <code>df[[&#39;MSNDATE&#39;, &#39;THEATER&#39;]]</code>.</p>
<h2 id="the-bokeh-columndatasource">The Bokeh ColumnDataSource</h2>
<p>Now that we&#39;ve learned how to create a Bokeh plot and how to load tabular data into Pandas, it&#39;s time to learn how to link Pandas&#39; <code>DataFrame</code> with Bokeh visualizations. The Bokeh object <code>ColumnDataSource</code> provides this integration.</p>
<p>The object&#39;s constructor accepts a Pandas <code>DataFrame</code> as an argument. After it is created, the <code>ColumnDataSource</code> can then be passed to glyph methods via the <code>source</code> parameter and other parameters, such as our x and y data, can then reference column names within our source. Let&#39;s go through an example of this.</p>
<p>Using our THOR dataset, we&#39;ll create a scatter plot of the number of attacking aircraft versus the tons of munitions dropped. We will use a new file called <code>column_datasource.py</code> to do this. We&#39;ll also take this opportunity to learn about Bokeh&#39;s interactive hover feature.</p>
<pre><code class="language-python">#column_datasource.py
import pandas as pd
from bokeh.plotting import figure, output_file, show
from bokeh.models import ColumnDataSource
from bokeh.models.tools import HoverTool

output_file(&#39;columndatasource_example.html&#39;)

df = pd.read_csv(&#39;thor_wwii.csv&#39;)
</code></pre>
<p>Here, we import Pandas, the <code>figure</code> object and basic functions from <code>bokeh.plotting</code>, and the <code>ColumnDataSource</code> object from <code>bokeh.models</code>.  We&#39;re also going to expand our knowledge of interactions in this example by adding a hover feature that is facilitated by the <code>HoverTool</code></p>
<p>We then immediately set our output file following Bokeh&#39;s recommended best practices. Finally, we call Pandas <code>read_csv</code> method to load our csv into a <code>DataFrame</code>.</p>
<pre><code class="language-python">sample = df.sample(50)
source = ColumnDataSource(sample)
</code></pre>
<p>Since we don&#39;t want to plot all 170,000+ rows in our scatterplot (which would require a longer processing time to generate and would create a confusing plot due to the volume of overlapping data), we randomly sample 50 rows using the dataframe&#39;s <code>sample</code> method.  We then pass this sample to the <code>ColumnDataSource</code> constructor and store this in a variable called <code>source</code>.</p>
<pre><code class="language-python">p = figure()
p.circle(x=&#39;TOTAL_TONS&#39;, y=&#39;AC_ATTACKING&#39;,
         source=source,
         size=10, color=&#39;green&#39;)
</code></pre>
<p>Next, we create our <code>figure</code> object and call the <code>circle</code> glyph method to plot our data. This is where the <code>source</code> variable that holds our <code>ColumnDataSource</code> comes into play. It&#39;s passed as our <code>source</code> argument to the glyph method and the column names holding the number of attacking aircraft (AC_ATTACKING) and tons of munitions dropped (TOTAL_TONS) are passed as our <code>x</code> and <code>y</code> arguments.</p>
<p>Interestingly, when we use a <code>ColumnDataSource</code> we&#39;re not limited to just using column names for <code>x</code> and <code>y</code> parameters. We can also pass a column name for other parameters such as <code>size</code>, <code>line_color</code>, or <code>fill_color</code>. This allows styling options to be determined by columns in the datasource itself! If you&#39;d like to see this in action, in the code above, change <code>size=10</code> to <code>size=&#39;TONS_HE&#39;</code>. The size of each dot will then reflect the tons of high explosives used.</p>
<p>{% include alert.html text=&quot;Throughout the tutorial, I often pass arguments by name where they could more succinctly be passed by position. This is helpful, in my opinion, for the reader to keep track of what arguments are being passed&quot; %}</p>
<p>Next we add a title and label our axes.</p>
<pre><code class="language-python">p.title.text = &#39;Attacking Aircraft and Munitions Dropped&#39;
p.xaxis.axis_label = &#39;Tons of Munitions Dropped&#39;
p.yaxis.axis_label = &#39;Number of Attacking Aircraft&#39;
</code></pre>
<p>We can also, at this stage, learn a bit more about the strong interactive, customizable nature of Bokeh plots. In our first Bokeh plot we saw the default Bokeh toolbar, but Bokeh allows us to customize our plot by adding new interactive tools to it.</p>
<pre><code class="language-python">hover = HoverTool()
hover.tooltips=[
    (&#39;Attack Date&#39;, &#39;@MSNDATE&#39;),
    (&#39;Attacking Aircraft&#39;, &#39;@AC_ATTACKING&#39;),
    (&#39;Tons of Munitions&#39;, &#39;@TOTAL_TONS&#39;),
    (&#39;Type of Aircraft&#39;, &#39;@AIRCRAFT_NAME&#39;)
]

p.add_tools(hover)

show(p)
</code></pre>
<p>Bokeh supports <a href="https://bokeh.pydata.org/en/latest/docs/user_guide/tools.html">many plotting tools</a>, but I introduce <code>HoverTool</code> here because it&#39;s particularly useful for data exploration and interaction. <code>HoverTool</code> allows you to set a <code>tooltips</code> property which takes a list of <a href="https://www.w3schools.com/python/python_tuples.asp">tuples</a>. The first part of the tuple is a display name and the second is a column name from your <code>ColumnDataSource</code> prefaced with <code>@</code>. Once we&#39;ve instantiated this tool, we add it to the plot using the <code>add_tool</code> method. We&#39;ll see how this looks in a moment.</p>
<p>Finally, we make sure to add the line to show the plot. Now we can run <code>column_datasource.py</code> and interact with our data in the browser.</p>
<p>{% include figure.html filename=&quot;visualizing-with-bokeh-2.png&quot; caption=&quot;Plotting with the ColumnDataSource and More Styling Options&quot; %}</p>
<p>Note that because we are randomly sampling the data, our plot will look different each time we run the code.</p>
<p>At the top and along the axes of the plot, we see the labels that we added. There is also a new tool in the toolbar. This is the hover tool that we added. To see it in action, hover over any data point in the scatterplot. A window will pop up showing the columns we set in our <code>tooltip</code> property!</p>
<p>Before moving to the next section of the lesson, try returning to the example above and adding/removing other variables and changing display names.</p>
<h1 id="categorical-data-and-bar-charts-munitions-dropped-by-country">Categorical Data and Bar Charts: Munitions Dropped by Country</h1>
<p>In the preceding example, we plotted quantitative data. Frequently, though, we want to plot categorical data. Categorical data, in contrast to quantitative, is data that can be divided into groups, but that does not necessarily have a numerical aspect to it. For example, while your height is numerical, your hair color is categorical. From the perspective of our dataset, features like attacking country hold categorical data, while features like the weight of munitions hold quantitative data.</p>
<p>In this section, we&#39;ll learn how to use categorical data as our x-axis values in Bokeh and how to use the <code>vbar</code> glyph method to create a vertical bar chart (an <code>hbar</code> glyph method functions similarly to create a horizontal bar chart). In addition, we&#39;ll learn about preparing categorical data in Pandas by grouping data. Further, we&#39;ll add to our knowledge of Bokeh styling and the hover tool.</p>
<p>To work through this information, we&#39;ll create a bar chart that shows the total tons of munitions dropped by each country listed in our csv.</p>
<p>We start by creating a new file called <code>munitions_by_country.py</code> and adding some initial code.</p>
<pre><code class="language-python">#munitions_by_country.py
import pandas as pd
from bokeh.plotting import figure, output_file, show
from bokeh.models import ColumnDataSource
from bokeh.models.tools import HoverTool

from bokeh.palettes import Spectral5
from bokeh.transform import factor_cmap
output_file(&#39;munitions_by_country.html&#39;)

df = pd.read_csv(&#39;thor_wwii.csv&#39;)
</code></pre>
<p>First, we import the Pandas library and the basic elements from Bokeh (i.e. <code>figure</code>, <code>output_file</code>, <code>show</code>, and <code>ColumnDataSource</code>). We also make two new imports: <code>Spectral5</code> is a pre-made five color pallette, one of Bokeh&#39;s many <a href="https://bokeh.pydata.org/en/latest/docs/reference/palettes.html">pre-made color palettes</a>, and <code>factor_cmap</code> is a helper method for mapping colors to bars in a bar-charts.</p>
<p>After the imports, we set our <code>output_file</code>  and load the thor_wwii.csv file into a <code>DataFrame</code>.</p>
<p>We now need to get from the 170,000+ records of individual missions to one record per attacking country with the total munitions dropped.</p>
<pre><code class="language-python">grouped = df.groupby(&#39;COUNTRY_FLYING_MISSION&#39;)[[&#39;TOTAL_TONS&#39;, &#39;TONS_HE&#39;, &#39;TONS_IC&#39;, &#39;TONS_FRAG&#39;]].sum()
</code></pre>
<p>Pandas lets us do this in a single line of code by using the <code>groupby</code> dataframe method. This method accepts a column by which to group the data and one or more aggregating methods that tell Pandas how to group the data together. The output is a new dataframe.</p>
<p>Let&#39;s take this one piece at a time. The <code>groupby(&#39;COUNTRY_FLYING_MISSION&#39;)</code> sets the column that we are grouping on. In other words, this says that we want the resulting dataframe to have one row per unique entry in the column <code>COUNTRY_FLYING_MISSION</code>. Since we don&#39;t care about aggregating all 19 columns in the dataframe, we choose just the tons of munitions columns with the indexer, <code>[&#39;TOTAL_TONS&#39;, &#39;TONS_HE&#39;, &#39;TONS_IC&#39;, &#39;TONS_FRAG&#39;]</code>. Finally, we use the <code>sum</code> method to let Pandas know how to aggregate all of the different rows. Other methods also exist for aggregating, such as <code>count</code>, <code>mean</code>, <code>max</code>, and <code>min</code>.</p>
<p>If you execute <code>print(grouped)</code>, you&#39;ll see that Pandas has grouped by the five unique countries in our dataset and summed the total tons dropped by each. You can also see the dataset has some problems: South Africa and New Zealand dropped more high explosives than the total tons column. Problems like this are typical of large, manually-created datasets and this is a great reminder why is so important to explore and visualize your data before creating research results.</p>
<pre><code>                        TOTAL_TONS     TONS_HE     TONS_IC  TONS_FRAG
COUNTRY_FLYING_MISSION
AUSTRALIA                   479.89      453.90      13.600      18.64
GREAT BRITAIN           1112598.95   868277.23  209036.158    1208.00
NEW ZEALAND                2629.06     4263.70     166.500       0.00
SOUTH AFRICA                 11.69       15.00       0.000       0.00
USA                     1625487.68  1297955.65  205288.200  127655.98
</code></pre>
<p>To plot this data, let&#39;s convert to kilotons by dividing by 1000.</p>
<pre><code class="language-python">grouped = grouped / 1000
</code></pre>
<p>This is a convenience that we&#39;ll continue to use in future examples.</p>
<pre><code class="language-python">source = ColumnDataSource(grouped)
countries = source.data[&#39;COUNTRY_FLYING_MISSION&#39;].tolist()
p = figure(x_range=countries)
</code></pre>
<p>Now, we need to make a <code>ColumnDataSource</code> from our grouped data and create a <code>figure</code>. Since our x-axis will list the five countries (rather than numerical data) we need to tell the figure how to handle the x-axis.</p>
<p>To do this, we create a list of countries from our source object, using <code>source.data</code> and the column name as key. The list of countries is then passed as the <code>x_range</code> to our <code>figure</code> constructor. Because this is a list of text data, the figure knows the x-axis is categorical and it also knows what possible values our x range can take (i.e. AUSTRALIA, GREAT BRITAIN, etc.).</p>
<pre><code class="language-python">color_map = factor_cmap(field_name=&#39;COUNTRY_FLYING_MISSION&#39;,
                    palette=Spectral5, factors=countries)

p.vbar(x=&#39;COUNTRY_FLYING_MISSION&#39;, top=&#39;TOTAL_TONS&#39;, source=source, width=0.70, color=color_map)

p.title.text =&#39;Munitions Dropped by Allied Country&#39;
p.xaxis.axis_label = &#39;Country&#39;
p.yaxis.axis_label = &#39;Kilotons of Munitions&#39;
</code></pre>
<p>Now we plot our data as individually colored bars and add basic labels. To color our bars we use the <code>factor_cmap</code> helper function. This creates a special color map that matches an individual color to each category (i.e. what Bokeh calls a <em>factor</em>). The color map is then passed as the color argument to our <code>vbar</code> glyph method.</p>
<p>For the data in our glyph method, we&#39;re passing a source and again referencing column names. Instead of using a <code>y</code> parameter, however, the <code>vbar</code> method takes a <code>top</code> parameter. A <code>bottom</code> parameter can equally be specified, but if left out, its default value is 0.</p>
<pre><code class="language-python">hover = HoverTool()
hover.tooltips = [
    (&quot;Totals&quot;, &quot;@TONS_HE High Explosive / @TONS_IC Incendiary / @TONS_FRAG Fragmentation&quot;)]

hover.mode = &#39;vline&#39;

p.add_tools(hover)

show(p)
</code></pre>
<p>We add a hover tool again, but now we see that we can use multiple data variables in a single line and add in our own text so the hover popup will list the kilotons of each type of explosive. The <code>hover.mode</code> is new. Three modes exist for the hover tool: <code>mouse</code>, <code>vline</code>, and <code>hline</code>. These tell the hover tool when to show the popup. <code>mouse</code> is the default value and shows a popup when directly over a glyph. <code>vline</code> and <code>hline</code> tell the popup to show when a vertical or horizontal line crosses a glyph. With <code>vline</code> set here, anytime your mouse passes through an imaginary vertical line extending from each bar, a popup will show.</p>
<p>{% include figure.html filename=&quot;visualizing-with-bokeh-3.png&quot; caption=&quot;A Bar Chart with Categorical Data and Coloring&quot; %}</p>
<p>{% include alert.html text=&quot;If you have a chance, it&#39;s worth exploring Bokeh&#39;s <a href="https://bokeh.pydata.org/en/latest/docs/reference/palettes.html">color palettes</a>. In the above example, try rewriting the code to use something other than <code>Spectral5</code>, such as <code>Inferno5</code> or <code>RdGy5</code>. To take it one step further, you can try your hand at using built-in palettes in any example that uses color.&quot; %}</p>
<h1 id="stacked-bar-charts-and-sub-sampling-data-types-of-munitions-dropped-by-country">Stacked Bar Charts and Sub-sampling Data: Types of Munitions Dropped by Country</h1>
<p>Because the previous plot shows that the USA and Great Britain account for the overwhelming majority of bombings, we now focus on these two countries and learn how to make a stacked bar chart that shows the types of munitions each country used.</p>
<p>We&#39;ll start a new file called <code>munitions_by_country_stacked.py</code></p>
<pre><code class="language-python">#munitions_by_country_stacked.py
import pandas as pd
from bokeh.plotting import figure, output_file, show
from bokeh.models import ColumnDataSource
from bokeh.palettes import Spectral3
output_file(&#39;types_of_munitions.html&#39;)

df = pd.read_csv(&#39;thor_wwii.csv&#39;)
</code></pre>
<p>In addition to our standard imports, this time we use a three-color Spectral palette, one color for each type of explosive (High Explosive, Incendiary, and Fragmentation).</p>
<pre><code class="language-python">filter = df[&#39;COUNTRY_FLYING_MISSION&#39;].isin((&#39;USA&#39;,&#39;GREAT BRITAIN&#39;))
df = df[filter]
</code></pre>
<p>Since the x-axis is again categorical, we&#39;ll need to group and aggregate our data. This time, though, we need to exclude any records hat don&#39;t have a COUNTRY_FLYING_MISSION with a value of GREAT BRITAIN or USA. To do that, we filter our dataframe.</p>
<p>For each row in <code>df</code>, the <code>isin</code> function checks whether COUNTRY_FLYING_MISSION has a value of USA or GREAT BRITAIN. If it does, the corresponding value in the variable <code>filter</code> is <code>True</code> and if not the value is <code>False</code></p>
<p>When applied to our dataframe via <code>df[filter]</code>, a new dataframe is created in which rows with a <code>True</code>  value are kept and rows with a <code>False</code> value are discarded. After the filter has been applied here, executing <code>df.shape</code> shows that 125,526 rows remain of an original 178,281.</p>
<pre><code class="language-python">grouped = df.groupby(&#39;COUNTRY_FLYING_MISSION&#39;)[&#39;TONS_IC&#39;, &#39;TONS_FRAG&#39;, &#39;TONS_HE&#39;].sum()

#convert tons to kilotons again
grouped = grouped / 1000
</code></pre>
<p>Now that we have reduced the dataframe to show only records for the USA and Great Britain, we group our data with <code>groupby</code> and aggregate the three columns that hold bomb types with <code>sum</code>.</p>
<pre><code class="language-python">source = ColumnDataSource(grouped)
countries = source.data[&#39;COUNTRY_FLYING_MISSION&#39;].tolist()
p = figure(x_range=countries)
</code></pre>
<p>As in the previous example, we create a source object from our grouped data and make sure our figure uses categorical data for the x-axis by setting the <code>x_range</code> to the list of countries.</p>
<pre><code class="language-python">p.vbar_stack(stackers=[&#39;TONS_HE&#39;, &#39;TONS_FRAG&#39;, &#39;TONS_IC&#39;],
             x=&#39;COUNTRY_FLYING_MISSION&#39;, source=source,
             legend = [&#39;High Explosive&#39;, &#39;Fragmentation&#39;, &#39;Incendiary&#39;],
             width=0.5, color=Spectral3)
</code></pre>
<p>To create the stacked bar chart, we call the <code>vbar_stack</code> glyph method. Rather than passing a single column name to a <code>y</code> parameter, we instead pass a list of column names as <code>stackers</code>. The order of this list determines the order that the columns will be stacked from bottom to top (after you&#39;ve worked through this example, try switching the column order to see what happens). The <code>legend</code> argument supplies text for each stacker and the <code>Spectral3</code> palette provides colors for each stacker.</p>
<pre><code class="language-python">p.title.text =&#39;Types of Munitions Dropped by Allied Country&#39;
p.legend.location = &#39;top_left&#39;

p.xaxis.axis_label = &#39;Country&#39;
p.xgrid.grid_line_color = None    #remove the x grid lines

p.yaxis.axis_label = &#39;Kilotons of Munitions&#39;

show(p)
</code></pre>
<p>We add basic styling and labeling, and then output the plot.</p>
<p>{% include figure.html filename=&quot;visualizing-with-bokeh-4.png&quot; caption=&quot;A Stacked Bar Chart with Categorical Data and Coloring&quot; %}</p>
<h1 id="time-series-and-annotations-bombing-operations-over-time">Time-Series and Annotations: Bombing Operations over Time</h1>
<p>Let&#39;s now explore the use of incendiary and fragmentation explosive a little more by seeing if there&#39;s any trend in their use over time versus the total munitions dropped. As you have had some time to get used to Bokeh&#39;s syntax, let&#39;s dive right in with a full code example in a new file named <code>my_first_timeseries.py</code>.</p>
<pre><code class="language-python">#my_first_timeseries.py
import pandas as pd
from bokeh.plotting import figure, output_file, show
from bokeh.models import ColumnDataSource
from bokeh.palettes import Spectral3
output_file(&#39;simple_timeseries_plot.html&#39;)

df = pd.read_csv(&#39;thor_wwii.csv&#39;)

#make sure MSNDATE is a datetime format
df[&#39;MSNDATE&#39;] = pd.to_datetime(df[&#39;MSNDATE&#39;], format=&#39;%m/%d/%Y&#39;)

grouped = df.groupby(&#39;MSNDATE&#39;)[&#39;TOTAL_TONS&#39;, &#39;TONS_IC&#39;, &#39;TONS_FRAG&#39;].sum()
grouped = grouped/1000

source = ColumnDataSource(grouped)

p = figure(x_axis_type=&#39;datetime&#39;)

p.line(x=&#39;MSNDATE&#39;, y=&#39;TOTAL_TONS&#39;, line_width=2, source=source, legend=&#39;All Munitions&#39;)
p.line(x=&#39;MSNDATE&#39;, y=&#39;TONS_FRAG&#39;, line_width=2, source=source, color=Spectral3[1], legend=&#39;Fragmentation&#39;)
p.line(x=&#39;MSNDATE&#39;, y=&#39;TONS_IC&#39;, line_width=2, source=source, color=Spectral3[2], legend=&#39;Incendiary&#39;)

p.yaxis.axis_label = &#39;Kilotons of Munitions Dropped&#39;

show(p)
</code></pre>
<p>Take a minute to seriously look through this code and see what you recognize. Two items should stand out as new.</p>
<p>First, the statement <code>df[&#39;MSNDATE&#39;] = pd.to_datetime(df[&#39;MSNDATE&#39;], format=&#39;%m/%d/%Y&#39;)</code> makes sure our MSNDATE column is a datetime. This is important because often data loaded from a csv file will not be properly typed as datetime. Supplying the <code>format</code> argument is not required, but doing so significantly speeds up the process.</p>
<p>Second, we pass the argument <code>x_axis_type=&#39;datetime&#39;</code> to our figure constructor to tell it that our x data will be datetimes. Otherwise, Bokeh works seamlessly with time data just like any other type of numerical data!</p>
<p>Looking at the output, though, you might notice a major issue.</p>
<p>{% include figure.html filename=&quot;visualizing-with-bokeh-5.png&quot; caption=&quot;A Basic Time-Series Plot&quot; %}</p>
<p>This data is volatile and hard-to-read because it is too fine-grained for our needs. Having daily data over the course of five years is great, but plotting it as such obscures trends in the data. To successfully plot time-series data and look for long-term trends, we need a way to change the time-scale we&#39;re looking at so that, for example, we can plot data summarized by weeks, months, or years.</p>
<p>Thankfully, Pandas offers a quick and easy way to do this. By modifying a single line of code in the above example, we can <em>resample</em> our time-series data to any valid unit of time.</p>
<h2 id="resampling-time-series-data">Resampling Time-Series Data</h2>
<p>Resampling time-series data can involve either upsampling (creating more records) or downsampling (creating fewer records). For example, a list of daily temperatures could be upsampled to a list of hourly temperatures or downsampled to a list of weekly temperatures. We&#39;ll only be downsampling in this tutorial, but upsampling is very useful when you&#39;re trying to match a sporadically-measured dataset with one that&#39;s more periodically measured.</p>
<p>To resample our data, we use a Pandas <code>Grouper</code> object, to which we pass the column name holding our datetimes and a code representing the desired resampling frequency. In the case of our data, the statement <code>pd.Grouper(key=&#39;MSNDATE&#39;, freq=&#39;M&#39;) </code> will be used to resample our MSNDATE column by <em>M</em>onth. We could equally resample by <em>W</em>eek, <em>Y</em>ear, <em>H</em>our, and <a href="http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases">so forth</a>. These frequency designations can also be prefaced with numbers so that, for example, <code>freq=&#39;2W&#39;</code> resamples at two week intervals!</p>
<p>To complete the process of resampling and plotting our data, we pass the above <code>Grouper</code> object to our <code>groupby</code> function in place of the raw column name. The <code>groupby</code> statement from the previous code example should now look like this:</p>
<pre><code class="language-python">grouped = df.groupby(pd.Grouper(key=&#39;MSNDATE&#39;, freq=&#39;M&#39;))[&#39;TOTAL_TONS&#39;, &#39;TONS_IC&#39;, &#39;TONS_FRAG&#39;].sum()
</code></pre>
<p>Rerunning the above code sample will produce a much cleaner plot with obvious trends. The plot now shows four points of interest:</p>
<ul>
<li>First, in both the Spring of 1944 and 1945, the scale of Allied bombing operations reached greater intensity.</li>
<li>Second, there is a smaller spike in the summer of 1945 during the acceleration of bombings against the Japanese after Germany&#39;s surrender.</li>
<li>Third, four spikes in the use of incendiary weapons appear that could further explored.</li>
<li>Fourth and finally, there are a few small spikes in the use of fragmentation bombs, the use of which then effectively stops after the surrender of Germany.</li>
</ul>
<p>{% include figure.html filename=&quot;visualizing-with-bokeh-6.png&quot; caption=&quot;A Time-Series Plot with Data Resampled to Months&quot; %}</p>
<h2 id="annotating-trends-in-plots">Annotating Trends in Plots</h2>
<p>Let&#39;s look more closely now at the bombings in Europe in 1944 and 1945 to see what trends there are with fragmentation and incendiary munitions. We will also point out some of these trends in our plot with annotations. To do this, we&#39;ll filter our dataset so that we work only with bombings in the European Theater of Operations (ETO), resample the data at one-month intervals (<code>freq=&#39;M&#39;</code>), and then plot the results in the same manner as before.</p>
<pre><code class="language-python">#annotating_trends.py
import pandas as pd
from bokeh.plotting import figure, output_file, show
from bokeh.models import ColumnDataSource
from datetime import datetime
from bokeh.palettes import Spectral3
output_file(&#39;eto_operations.html&#39;)

df = pd.read_csv(&#39;thor_wwii.csv&#39;)

#filter for the European Theater of Operations
filter = df[&#39;THEATER&#39;]==&#39;ETO&#39;
df = df[filter]

df[&#39;MSNDATE&#39;] = pd.to_datetime(df[&#39;MSNDATE&#39;], format=&#39;%m/%d/%Y&#39;)
group = df.groupby(pd.Grouper(key=&#39;MSNDATE&#39;, freq=&#39;M&#39;))[&#39;TOTAL_TONS&#39;, &#39;TONS_IC&#39;, &#39;TONS_FRAG&#39;].sum()
group = group / 1000

source = ColumnDataSource(group)

p = figure(x_axis_type=&quot;datetime&quot;)

p.line(x=&#39;MSNDATE&#39;, y=&#39;TOTAL_TONS&#39;, line_width=2, source=source, legend=&#39;All Munitions&#39;)
p.line(x=&#39;MSNDATE&#39;, y=&#39;TONS_FRAG&#39;, line_width=2, source=source, color=Spectral3[1], legend=&#39;Fragmentation&#39;)
p.line(x=&#39;MSNDATE&#39;, y=&#39;TONS_IC&#39;, line_width=2, source=source, color=Spectral3[2], legend=&#39;Incendiary&#39;)

p.title.text = &#39;European Theater of Operations&#39;

p.yaxis.axis_label = &#39;Kilotons of Munitions Dropped&#39;

show(p)
</code></pre>
<p>{% include figure.html filename=&quot;visualizing-with-bokeh-7.png&quot; caption=&quot;A Time-Series Plot of the ETO with Data Resampled to Months&quot; %}</p>
<p>A few patterns emerge in the ETO data. First we see a very clear escalation of overall bombings leading up to June 6, 1944 and a notable dip during the winter of 1944/1945. Incendiary munitions show three spikes and confirm that the fourth spike seen in the preceding example was directed at the bombing of Japan after Germany&#39;s surrender. The pattern of fragmentation bombs is harder to read, but it&#39;s now clear that they were only seriously used in the European Theater after D-Day.</p>
<p>{% include alert.html text=&quot;Try your hand at resampling this data using any of <a href="http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases">Pandas&#39; time frequencies </a> to see what other trends might emerge. Remember, you can preface these frequencies with numbers as well (e.g. if you were working with historical stock market data, 2Q would give you bi-quarterly data!)&quot; %}</p>
<p>Since we have established that 6 June 1944 and the winter of 1944/1945 mark changes to the bombing patterns in the ETO, let&#39;s highlight these trends using Bokeh&#39;s annotation features.</p>
<p>To do this, we&#39;ll create a <code>BoxAnnotation</code> and then add these to our <code>figure</code> before showing it. First, we need to add an additional import statement to our code.</p>
<pre><code class="language-python">from bokeh.models import BoxAnnotation
</code></pre>
<p>To create the box, we first need to determine its coordinates. Coordinates for Bokeh annotations can be either absolute (i.e. positioned using screen units), meaning they always stay in one place, or they can be positioned in relation to data. Our annotations will all be positioned using data coordinates.</p>
<pre><code class="language-python">box_left = pd.to_datetime(&#39;6-6-1944&#39;)
box_right = pd.to_datetime(&#39;16-12-1944&#39;)
</code></pre>
<p>The left of the box will be 6 June 1944 (D-Day) and for the right of the box we&#39;ll choose the first day of the Battle of the Bulge: 16 December 1944. In this case, the dates follow a month-day-year format, but <code>to_datetime</code> also works with <a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.to_datetime.html">day-first and year-first formats</a>.</p>
<p>We pass these coordinates to the <code>BoxAnnotation</code> constructor along with some styling arguments. Then, we add it to the our figure using the <code>add_layout()</code> method.</p>
<pre><code class="language-python">box = BoxAnnotation(left=box_left, right=box_right,
                    line_width=1, line_color=&#39;black&#39;, line_dash=&#39;dashed&#39;,
                    fill_alpha=0.2, fill_color=&#39;orange&#39;)

p.add_layout(box)
</code></pre>
<p>{% include figure.html filename=&quot;visualizing-with-bokeh-8.png&quot; caption=&quot;A Time-Series Plot of the ETO with Annotations Added&quot; %}</p>
<p>{% include alert.html text=&quot;Try to create a similar plot for the Pacific Theater of Operations (PTO). Annotate the invasion of Iwo Jima (February 19, 1945) and Japan&#39;s announcement of surrender (August 15, 1945).&quot; %}</p>
<h1 id="spatial-data-mapping-target-locations">Spatial Data: Mapping Target Locations</h1>
<p>In this final part of the lesson we&#39;ll look at the spatial components of fragmentation bombs.</p>
<p>Bokeh provides <a href="https://bokeh.pydata.org/en/latest/docs/reference/tile_providers.html">built-in tile providers</a> that render base maps of the world. These are contained in the <code>bokeh.tile_providers</code> module. For this example, we&#39;ll use the CartoDB Tile Service (CARTODBPOSITRON).</p>
<p>We&#39;ll also be using functions imported from the <code>pyproj</code> library. Since our coordinates are stored as latitude/longitude, we&#39;ll define a custom function to convert them before mapping. Note that although Bokeh is coordinate-system neutral, it uses the Web Mercator projection for mapping, a standard found across web tile providers. The subject of coordinate systems and projections are outside the scope of this tutorial, but the interested reader will find many useful web resources on these topics.</p>
<p>{% include alert.html text=&quot;If your own dataset has place names, but not latitude and longitude, don&#39;t worry! You can find ways to easily get coordinates from place names in Programming Historian&#39;s <a href="/lessons/geocoding-qgis">Geocoding Historical Data using QGIS</a> or <a href="/lessons/mapping-with-python-leaflet#geocoding-with-python">Web Mapping with Python and Leaflet</a>.&quot; %}</p>
<pre><code class="language-python"># target_locations.py
import pandas as pd
from bokeh.plotting import figure, output_file, show
from bokeh.models import ColumnDataSource, Range1d
from bokeh.layouts import layout
from bokeh.palettes import Spectral3
from bokeh.tile_providers import get_provider
from pyproj import Transformer
output_file(&#39;mapping_targets.html&#39;)

# helper function to convert lat/long to easting/northing for mapping
# this relies on functions from the pyproj library


def LongLat_to_EN(long, lat):
    try:
        transformer = Transformer.from_crs(&#39;epsg:4326&#39;, &#39;epsg:3857&#39;)
        easting, northing = transformer.transform(long, lat)
        return easting, northing
    except:
        return None, None


df = pd.read_csv(&quot;thor_wwii.csv&quot;)


df[&#39;E&#39;], df[&#39;N&#39;] = zip(
    *df.apply(lambda x: LongLat_to_EN(x[&#39;TGT_LONGITUDE&#39;], x[&#39;TGT_LATITUDE&#39;]), axis=1)))
</code></pre>
<p>The boilerplate imports and our conversion function are defined. Next, we load our data and apply our conversion function to create new E and N columns that store our Web Mercator easting and northing.</p>
<pre><code class="language-python">grouped = df.groupby([&#39;E&#39;, &#39;N&#39;])[[&#39;TONS_IC&#39;, &#39;TONS_FRAG&#39;]].sum().reset_index()

filter = grouped[&#39;TONS_FRAG&#39;] != 0
grouped = grouped[filter]

source = ColumnDataSource(grouped)
</code></pre>
<p>Because a single target can appear in multiple records, we need to group the data by E and N to get unique target locations. Otherwise, we would map the same target every time it appears in a record.</p>
<p>The <code>reset_index</code> function applied after aggregating is new here. By default, when Pandas groups these two columns it will make E and N the index for each row in the new dataframe. Since we just want E and N to remain as normal columns for mapping, we call <code>reset_index</code>.</p>
<pre><code class="language-python">left = -2150000
right = 18000000
bottom = -5300000
top = 11000000

p = figure(x_range=Range1d(left, right), y_range=Range1d(bottom, top))
</code></pre>
<p>To set bounds for our map, we&#39;ll set a minimum and maximum value for our plot&#39;s <code>x_range</code> and <code>y_range</code>. We use the <code>Range1D</code> object, which represents bounded 1-dimensional data in Bokeh.</p>
<pre><code class="language-python">provider = get_provider(&#39;CARTODBPOSITRON&#39;)
p.add_tile(provider)

p.circle(x=&#39;E&#39;, y=&#39;N&#39;, source=source, line_color=&#39;grey&#39;, fill_color=&#39;yellow&#39;)

p.axis.visible = False

show(p)
</code></pre>
<p>Finally, we call <code>add_tile</code> and pass the tile provider we imported. Then, we use glyph methods just like in any other plot. Here, we call <code>circle</code> and pass the easting and northing columns as our x and y data.</p>
<p>{% include figure.html filename=&quot;visualizing-with-bokeh-9.png&quot; caption=&quot;A Map of Target Locations&quot; %}</p>
<p>Having plotted which targets in Europe and Asia were bombed with fragmentation bombs, we can now start to examine patterns of destruction with greater detail. In the above code, we also summed incendiary bombs. Try to alter the code to create a map of these targets.</p>
<h1 id="bokeh-as-a-visualization-tool">Bokeh as a Visualization Tool</h1>
<p>Bokeh&#39;s strength as a visualization tool lies in its ability to show differing types of data in an interactive and web-friendly manner. This tutorial has only scratched the surface of Bokeh&#39;s capabilities and the reader is encourage to delve deeper into the library&#39;s workings. A great place to start is the <a href="https://bokeh.pydata.org/en/latest/docs/gallery.html">Bokeh gallery</a>, where you can see a variety of visualizations and decide how you might apply these techniques to your own data. If you&#39;re more inclined to dive right into further code examples, Bokeh&#39;s <a href="https://mybinder.org/v2/gh/bokeh/bokeh-notebooks/master?filepath=tutorial%2F00%20-%20Introduction%20and%20Setup.ipynb">online notebook</a> is an excellent place to start!</p>
<h1 id="further-resources">Further Resources</h1>
<ul>
<li><a href="https://bokeh.pydata.org/en/latest/docs/user_guide.html">Bokeh User Guide</a></li>
<li><a href="https://bokeh.pydata.org/en/latest/docs/gallery.html">Bokeh Gallery</a></li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/index.html">Pandas Documentation</a></li>
<li><a href="https://www.kdnuggets.com/2017/01/pandas-cheat-sheet.html">Pandas Cheat Sheet</a></li>
<li><a href="https://www.kdnuggets.com/2017/03/bokeh-cheat-sheet.html">Bokeh Cheat Sheet</a></li>
</ul>
<p>[^1]: David Robinson, &#39;Why is Python Growing so Quickly?&#39;, <em>Stack Overflow Blog</em>, 14 September 2017 <a href="https://stackoverflow.blog/2017/09/14/python-growing-quickly/">https://stackoverflow.blog/2017/09/14/python-growing-quickly/</a></p>
<!-- HTML_TAG_END -->

<script type="application/json" data-type="svelte-data" data-url="visualizing-with-bokeh/raw.json">{"status":200,"statusText":"","headers":{"content-type":"application/json; charset=utf-8"},"body":"{\"metadata\":{\"title\":\"Visualizing Data with Bokeh and Pandas\",\"authors\":[\"Charlie Harper\"],\"date\":\"2018-07-27T00:00:00.000Z\",\"reviewers\":[\"Zoe LeBlanc\",\"Ben Schmidt\"],\"editors\":[\"James Baker\",\"Ian Milligan\"],\"difficulty\":2,\"activity\":\"analyzing\",\"topics\":[\"python\",\"data-manipulation\",\"mapping\"],\"abstract\":\"In this lesson you will learn how to visually explore and present data in Python by using the Bokeh and Pandas libraries.\",\"review-ticket\":\"https:\u002F\u002Fgithub.com\u002Fprogramminghistorian\u002Fph-submissions\u002Fissues\u002F152\",\"layout\":\"lesson\",\"avatar_alt\":\"Men with torches in an antique tomb\",\"doi\":\"10.46430\u002Fphen0081\"},\"html_body\":\"\u003Ch1 id=\\\"contents\\\"\u003EContents\u003C\u002Fh1\u003E\\n\u003Cp\u003E{% include toc.html %}\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"overview\\\"\u003EOverview\u003C\u002Fh1\u003E\\n\u003Cp\u003EThe ability to load raw data, sample it, and then visually explore and present it is a valuable skill across disciplines. In this tutorial, you will learn how to do this in Python by using the Bokeh and Pandas libraries. Specifically, we will work through visualizing and exploring aspects of WWII bombing runs conducted by Allied powers.\u003C\u002Fp\u003E\\n\u003Cp\u003EAt the end of the lesson you will be able to:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003ELoad tabular CSV data\u003C\u002Fli\u003E\\n\u003Cli\u003EPerform basic data manipulation, such as aggregating and sub-sampling raw data\u003C\u002Fli\u003E\\n\u003Cli\u003EVisualize quantitative, categorical, and geographic data for web display\u003C\u002Fli\u003E\\n\u003Cli\u003EAdd varying types of interactivity to your visualizations\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003ETo reach these goals, we&#39;ll work through a variety of visualization examples using THOR, a dataset that describes historical bombing operations.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"the-wwii-thor-dataset\\\"\u003EThe WWII THOR Dataset\u003C\u002Fh2\u003E\\n\u003Cp\u003EThe Theater History of Operations Reports (THOR) lists aerial bombing operations during World War I, World War II, the Korean War, and the Vietnam War undertaken by the United States and Allied Powers. The records were compiled from declassified documents by Lt. Col. Jenns Robertson. THOR is made publicly available through a partnership between the US Department of Defense and \u003Ca href=\\\"https:\u002F\u002Fdata.world\u002Fdatamil\\\"\u003Edata.world\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EEach row in the THOR dataset contains information on a single mission or bombing run. This information can include the mission date, takeoff and target locations, the target type, aircraft involved, and the types and weights of bombs dropped on the target. The \u003Ca href=\\\"https:\u002F\u002Fdata.world\u002Fdatamil\u002Fthor-data-dictionary\\\"\u003ETHOR data dictionary\u003C\u002Fa\u003E provides detailed information on the structure of the dataset.\u003C\u002Fp\u003E\\n\u003Cp\u003EFor this tutorial, we&#39;ll use a modified version of the WWII THOR dataset. The original, full-version of the dataset consists of 62 columns of information digitized from the paper forms. To make this dataset more manageable for our purposes, this has been reduced to 19 columns that include core mission information and bombing data. These columns are discussed below when we first load the data. The unabridged dataset is available for download \u003Ca href=\\\"https:\u002F\u002Fdata.world\u002Fdatamil\u002Fworld-war-ii-thor-data\\\"\u003Ehere\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe dataset used in this tutorial is contained in \u003Ca href=\\\"https:\u002F\u002Fgithub.com\u002Fprogramminghistorian\u002Fph-submissions\u002Ftree\u002Fgh-pages\u002Fassets\u002Fvisualizing-with-bokeh\u002Fthor_wwii.csv\\\"\u003Ethor_wwii.csv\u003C\u002Fa\u003E. This file is required to complete most of the examples below.\u003C\u002Fp\u003E\\n\u003Cp\u003EWe&#39;ll use Bokeh and Pandas to address some of the following questions:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003EWhat types and weights of munitions were dropped during World War II (WWII)? What patterns can we discern in the use of different types of munitions?\u003C\u002Fli\u003E\\n\u003Cli\u003EHow did the types and weights of munitions dropped change over the course of WWII? How do these changes correspond to major military events?\u003C\u002Fli\u003E\\n\u003Cli\u003EWhat targets were munitions dropped on during the war? Were particular types of munitions limited to certain theaters of operations or targets?\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Ch2 id=\\\"other-possible-datasets\\\"\u003EOther Possible Datasets\u003C\u002Fh2\u003E\\n\u003Cp\u003EIf this dataset doesn&#39;t fit your interests or if you&#39;d like more practice after completing this tutorial, here are a few other interesting datasets that you might wish to use with Bokeh and Pandas:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Cp\u003E\u003Ca href=\\\"https:\u002F\u002Fdata.world\u002Fhistory\u002Fscottish-witchcraft\u002F\\\"\u003EScottish Witchcraft Trials\u003C\u002Fa\u003E: A multi-table set of data on over 4,000 people accused of witchcraft between 1536 and 1736.\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E\u003Ca href=\\\"https:\u002F\u002Fdata.world\u002Fhistory\u002Fcivil-unrest-event-data\\\"\u003ECivil Unrest Events\u003C\u002Fa\u003E: A single table cataloging over 60,000 events of civil unrest across the world since the end of World War II.\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E\u003Ca href=\\\"https:\u002F\u002Fwww.slavevoyages.org\u002Fvoyage\u002Fdatabase\\\"\u003ETrans-Atlantic Slave Trade Database\u003C\u002Fa\u003E: Searchable and customizable tabular data on 36,000 slaving voyages that transported over 10 million slaves from the 16th to 19th centuries.\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003EAll three datasets contain comparable quantitative, qualitative, and temporal data to those found in the THOR dataset. The Civil Unrest Events and Trans-Atlantic Slave Trade datasets both contain spatial data, though this is lacking from the Scottish Witchcraft Trials data.\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"getting-started\\\"\u003EGetting Started\u003C\u002Fh1\u003E\\n\u003Ch2 id=\\\"prerequisites\\\"\u003EPrerequisites\u003C\u002Fh2\u003E\\n\u003Cp\u003EThis tutorial can be completed using any operating systems. It requires Python 3 and a web browser. You may use any text editor to write your code.\u003C\u002Fp\u003E\\n\u003Cp\u003EThis tutorial assumes that you have a basic knowledge of the Python language and its associated data structures, particularly lists.\u003C\u002Fp\u003E\\n\u003Cp\u003EIf you work in Python 2, you will need to create a virtual environment for Python 3, and even if you work in Python 3, creating a virtual environment for this tutorial is good practice.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"creating-a-python-3-virtual-environment\\\"\u003ECreating a Python 3 Virtual Environment\u003C\u002Fh2\u003E\\n\u003Cp\u003EA Python virutal environment is an isolated environment in which you can install libraries and execute code. Many different virtual evironments can be created to work with different versions of Python and Python libraries. Virtual environments are useful because they ensure you have only the necessary libraries installed and that you do not encounter version conflicts. An additional benefit of virtual environments is that you can pass them to others so that you know your code will execute on another machine.\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ca href=\\\"https:\u002F\u002Fconda.io\u002Fminiconda.html\\\"\u003EMiniconda\u003C\u002Fa\u003E is one easy way to create virtual environments that is simple to install across operating systems. You should download Miniconda and follow the instructions for \u003Ca href=\\\"https:\u002F\u002Fconda.io\u002Fprojects\u002Fconda\u002Fen\u002Flatest\u002Fuser-guide\u002Finstall\u002Fwindows.html\\\"\u003EWindows\u003C\u002Fa\u003E, \u003Ca href=\\\"https:\u002F\u002Fconda.io\u002Fprojects\u002Fconda\u002Fen\u002Flatest\u002Fuser-guide\u002Finstall\u002Fmacos.html\\\"\u003EMac\u003C\u002Fa\u003E, or \u003Ca href=\\\"https:\u002F\u002Fconda.io\u002Fprojects\u002Fconda\u002Fen\u002Flatest\u002Fuser-guide\u002Finstall\u002Flinux.html\\\"\u003ELinux\u003C\u002Fa\u003E as appropriate for your operating system.\u003C\u002Fp\u003E\\n\u003Cp\u003EOnce you have downloaded and installed Miniconda for your operating system, you can check that it has installed correctly by opening a command line and typing:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Econda info\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EIf you see version information similar to the following, then Miniconda has installed correctly.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003ECurrent conda install:\\n               platform : linux-64\\n          conda version : 4.3.29\\n          ...\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EWe&#39;ll use Miniconda to create a Python 3 virtual environment named \u003Cem\u003Ebokeh-env\u003C\u002Fem\u003E for this tutorial. In the command line type the following:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Econda create --name bokeh-env python=3.6\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ESay &#39;yes&#39; when you are prompted to install new packages.\u003C\u002Fp\u003E\\n\u003Cp\u003ETo activate the \u003Cem\u003Ebokeh-env\u003C\u002Fem\u003E virtual environment, the command differs slightly depending on your operating system.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Esource activate bokeh-env #For Linux\u002FMacOS\\nactivate bokeh-env #For Windows\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EYour command line should now show that you are in the \u003Cem\u003Ebokeh-env\u003C\u002Fem\u003E virtual environment.\u003C\u002Fp\u003E\\n\u003Cp\u003EWhen you would like to leave the virtual environment, you can type the command appropriate for your operating system.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Esource deactivate #For Linux\u002FMacOS\\ndeactivate #For Windows\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Ch2 id=\\\"installing-packages\\\"\u003EInstalling Packages\u003C\u002Fh2\u003E\\n\u003Cp\u003EIn your activated \u003Cem\u003Ebokeh-env\u003C\u002Fem\u003E virtual environment, issue the following command to install the python packages for this tutorial.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Epip install pandas bokeh pyproj\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ETo get the exact versions used to write this tutorial (note: these may not be the most recent versions of each python package) you can pass the following version numbers to \u003Ccode\u003Epip\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Epip install &quot;pandas&gt;=1.2.0,&lt;1.2.3&quot; &quot;bokeh&gt;=2.0.0,&lt;2.3.0&quot; &quot;pyproj&gt;=3.0,&lt;3.0.1&quot;\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Ch2 id=\\\"running-code-examples\\\"\u003ERunning Code Examples\u003C\u002Fh2\u003E\\n\u003Cdiv class=\\\"alert alert-info\\\"\u003E\\n\\n\u003Cp\u003EAt this point in the lesson, you have a choice of two ways to experiment with &quot;Running Code Examples&quot;. You can either proceed in the command line and do the coding by hand, or run the Jupyter notebook provided \u003Ca href=\\\"https:\u002F\u002Fgithub.com\u002Fprogramminghistorian\u002Fph-submissions\u002Ftree\u002Fgh-pages\u002Fassets\u002Fvisualizing-with-bokeh\u002Fvisualizing-with-bokeh.ipynb\\\"\u003Ehere\u003C\u002Fa\u003E. Beginners who simply want to get a sense of how the code  operates, rather than write it themselves, may find the Jupyter notebook option especially helpful.\u003C\u002Fp\u003E\\n\u003C\u002Fdiv\u003E\\n\\n\u003Cp\u003EIt is easiest first to create a single directory and save each code example as a \u003Cem\u003E.py\u003C\u002Fem\u003E within it. When you are ready to run the code file, navigate to this directory in your command prompt and make sure your virtual environment is activated. Remember that you can always activate the environment with the following command appropriate for your operating system.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Esource activate bokeh-env #For Linux\u002FMacOS\\nactivate bokeh-env #For Windows\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EWithin the virtual environment, you can run your code by typing:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Epython filename.py\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EA Jupyter Notebook containing the code used in this tutorial is also \u003Ca href=\\\"https:\u002F\u002Fgithub.com\u002Fprogramminghistorian\u002Fph-submissions\u002Ftree\u002Fgh-pages\u002Fassets\u002Fvisualizing-with-bokeh\u002Fvisualizing-with-bokeh.ipynb\\\"\u003Eavailable\u003C\u002Fa\u003E in case you prefer to work through the tutorial without installing a virtual environment. You can learn more about Jupyter Notebook \u003Ca href=\\\"http:\u002F\u002Fjupyter.org\\\"\u003Ehere\u003C\u002Fa\u003E. If you have created a virtual environment using Miniconda, as discussed above, you can install Jupyter Notebook in the environment by typing \u003Ccode\u003Econda install jupyter\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"the-basics-of-bokeh\\\"\u003EThe Basics of Bokeh\u003C\u002Fh1\u003E\\n\u003Ch2 id=\\\"what-is-bokeh\\\"\u003EWhat is Bokeh?\u003C\u002Fh2\u003E\\n\u003Cp\u003EBokeh is a library for creating interactive data visualizations in a web browser. It offers a concise, human-readable syntax, which allows for rapidly presenting data in an aesthetically pleasing manner. If you&#39;ve worked with visualization in Python before, it&#39;s likely that you have used \u003Ca href=\\\"https:\u002F\u002Fmatplotlib.org\\\"\u003Ematplotlib\u003C\u002Fa\u003E. It&#39;s worth briefly mentioning how Bokeh differs from matplotlib, and when one might be preferred to the other.\u003C\u002Fp\u003E\\n\u003Cp\u003EMatplotlib has existed since 2002 and has long been a standard of Python data visualization. Bokeh emerged in 2013. This difference in age means that Matplotlib matured long before Bokeh was released; however, in a short period of time, Bokeh has reached a high level of maturity.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe intended uses of matplotlib and Bokeh are quite different. Matplotlib creates static graphics that are useful for quick and simple visualizations, or for creating publication quality images. Bokeh creates visualizations for display on the web (whether locally or embedded in a webpage) and most importantly, the visualizations are meant to be highly interactive. Matplotlib does not offer either of these features.\u003C\u002Fp\u003E\\n\u003Cp\u003EIf would you like to visually interact with your data in an exploratory manner or you would like to distribute interactive visual data to a web audience, Bokeh is the library for you! If your main interest is producing finalized visualizations for publication, matplotlib may be better, although Bokeh does offer a way to create static graphics.\u003C\u002Fp\u003E\\n\u003Cp\u003EWith this differences in mind, as we work through the lesson, I&#39;ll emphasize the interactive aspects that make Bokeh useful for exploring and disseminating historical data and that set it apart from other libraries like matplotlib.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"your-first-plot\\\"\u003EYour First Plot\u003C\u002Fh2\u003E\\n\u003Cp\u003EFirst, create a new file called \u003Ccode\u003Emy_first_plot.py\u003C\u002Fcode\u003E in the same directory as  \u003Ccode\u003Ewwii_thor.csv\u003C\u002Fcode\u003E and then open it up in a text editor. We&#39;ll be adding lines to this file to run.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E#my_first_plot.py\\nfrom bokeh.plotting import figure, output_file, show\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ETo implement and use Bokeh, we first import some basics that we need from the \u003Ccode\u003Ebokeh.plotting\u003C\u002Fcode\u003E module.\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Efigure\u003C\u002Fcode\u003E is the core object that we will use to create plots. \u003Ccode\u003Efigure\u003C\u002Fcode\u003E handles the styling of plots, including title, labels, axes, and grids, and it exposes methods for adding data to the plot. The \u003Ccode\u003Eoutput_file\u003C\u002Fcode\u003E function defines how the visualization will be rendered (namely to an html file) and the \u003Ccode\u003Eshow\u003C\u002Fcode\u003E function will be invoked when the plot is ready for output. \u003Ccode\u003Eshow\u003C\u002Fcode\u003E tells Bokeh that all of the data has been added to the plot and it is time to render it.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Eoutput_file(&#39;my_first_graph.html&#39;)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EBokeh recommends that \u003Ccode\u003Eoutput_file\u003C\u002Fcode\u003E, to which we pass a file name, be called at the start of your script, immediately after imports. An alternative output function to be aware of is \u003Ccode\u003Eoutput_notebook\u003C\u002Fcode\u003E which is used to show plots in-line in a Jupyter Notebook. To learn more about installing and using Jupyter notebooks, see \u003Ca href=\\\"https:\u002F\u002Fjupyter.readthedocs.io\u002Fen\u002Flatest\u002F\\\"\u003EJupyter&#39;s documentation\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Ex = [1, 3, 5, 7]\\ny = [2, 4, 6, 8]\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ENext we&#39;ll create some data to plot. Data in Bokeh can take on different forms, but at its simplest, data is just a list of values. We create one list for our x-axis and one for our y-axis.\u003C\u002Fp\u003E\\n\u003Cp\u003EWith our output format and data fixed, we can instantiate a \u003Ccode\u003Efigure\u003C\u002Fcode\u003E and  add the data to it.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Ep = figure()\\n\\np.circle(x, y, size=10, color=&#39;red&#39;, legend=&#39;circle&#39;)\\np.line(x, y, color=&#39;blue&#39;, legend=&#39;line&#39;)\\np.triangle(y, x, color=&#39;gold&#39;, size=10, legend=&#39;triangle&#39;)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003E{% include alert.html text=&quot;\u003Ccode\u003Ep\u003C\u002Fcode\u003E is a common variable name for a \u003Ccode\u003Efigure\u003C\u002Fcode\u003E object, since a figure is a type of plot.&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EAfter instantiating the figure, we call the \u003Ccode\u003Ecircle\u003C\u002Fcode\u003E , \u003Ccode\u003Eline\u003C\u002Fcode\u003E, and \u003Ccode\u003Etriangle\u003C\u002Fcode\u003E methods to plot our data. These types of methods are known as a \u003Cem\u003Eglyph method\u003C\u002Fem\u003E. The term \u003Cem\u003Eglyph\u003C\u002Fem\u003E in Bokeh refers to the lines, circles, bars, and other shapes that are added to plots to display data.\u003C\u002Fp\u003E\\n\u003Cp\u003EIf we wanted, we could just keep adding glyphs to the plot! In addition to the \u003Ccode\u003Ecircle\u003C\u002Fcode\u003E, \u003Ccode\u003Eline\u003C\u002Fcode\u003E,   and \u003Ccode\u003Etriangle\u003C\u002Fcode\u003E glyphs, there are many others, including:  \u003Ccode\u003Easterisk\u003C\u002Fcode\u003E, \u003Ccode\u003Ecircle_cross\u003C\u002Fcode\u003E, \u003Ccode\u003Ecircle_x\u003C\u002Fcode\u003E, \u003Ccode\u003Ecross\u003C\u002Fcode\u003E, \u003Ccode\u003Ediamond\u003C\u002Fcode\u003E, \u003Ccode\u003Ediamond_cross\u003C\u002Fcode\u003E, \u003Ccode\u003Einverted_triangle\u003C\u002Fcode\u003E, \u003Ccode\u003Esquare\u003C\u002Fcode\u003E, \u003Ccode\u003Esquare_cross\u003C\u002Fcode\u003E, \u003Ccode\u003Esquare_x\u003C\u002Fcode\u003E, and \u003Ccode\u003Ex\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EWhen calling a glyph method, at a minimum, we must pass the data we would like to plot, but frequently we might add styling arguments. Here, we set a size, color, and legend name for each glyph.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Ep.legend.click_policy=&#39;hide&#39;\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EWe will also add our first piece of code that brings some interactivity to the plot. By setting a \u003Ccode\u003Eclick_policy\u003C\u002Fcode\u003E on our legend, a user can now click on each legend entry (e.g. circle, line, triangle) to show\u002Fhide that piece of data! The \u003Ccode\u003Eclick_policy\u003C\u002Fcode\u003E can also be set to \u003Ccode\u003Emute\u003C\u002Fcode\u003E instead of \u003Ccode\u003Ehide\u003C\u002Fcode\u003E. This would mute the color of that data on clicking rather than hide it completely.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Eshow(p)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ECalling \u003Ccode\u003Eshow\u003C\u002Fcode\u003E and passing the instantiated \u003Ccode\u003Efigure\u003C\u002Fcode\u003E will output the results to our html file. Now let&#39;s run this code!\u003C\u002Fp\u003E\\n\u003Cp\u003EIn your command line, make sure you&#39;re in the directory where you&#39;ve saved the file and then run the file with the \u003Ccode\u003Epython\u003C\u002Fcode\u003E command.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Epython my_first_plot.py\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;visualizing-with-bokeh-1.png&quot; caption=&quot;Plotting a Single Glyph&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EA web browser will now appear showing the html file with your visualization. The red circles, blue line, and gold triangles are the result of our glyph method calls. Clicking the legend in the upper right corner will show\u002Fhide each glyph type. Note that Bokeh has automatically handled the creation of the grid-lines and tick labels.\u003C\u002Fp\u003E\\n\u003Cp\u003EAlong the right-hand side, the default toolbar is also displayed. The tools include drag, box zoom, wheel zoom, save, reset, and help. Using these tools, a user can pan along the plot or zoom in on interesting portions of the data. Since this is a stand-alone HTML page, which includes a reference to BokehJS, it can be immediately passed to a co-worker for exploration or posted to the web.\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"bokeh-and-pandas-exploring-the-wwii-thor-dataset\\\"\u003EBokeh and Pandas: Exploring the WWII THOR Dataset\u003C\u002Fh1\u003E\\n\u003Cp\u003EIn the previous example, we manually created two short Python lists for our x and y data. What happens when you have real-world data with tens-of-thousands of rows and dozens of columns stored in an external format? Pandas, a widely-used data science library, is ideally suited to this type of data and integrates seamlessly with Bokeh to create interactive visualizations of data.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"pandas-overview\\\"\u003EPandas Overview\u003C\u002Fh2\u003E\\n\u003Cp\u003EFor the purposes of this tutorial, I will only touch on the basic functions of Pandas that are necessary to produce our visualizations. \u003Ca href=\\\"https:\u002F\u002Fpandas.pydata.org\u002Fpandas-docs\u002Fstable\u002F10min.html\\\"\u003E10 Minutes to Pandas\u003C\u002Fa\u003E and \u003Ca href=\\\"https:\u002F\u002Fpandas.pydata.org\u002Fpandas-docs\u002Fstable\u002Ftutorials.html#lessons-for-new-pandas-users\\\"\u003ELessons for New Pandas Users\u003C\u002Fa\u003E are excellent introductions that I would recommend for expanding your knowledge beyond the very basics touched on here.\u003C\u002Fp\u003E\\n\u003Cp\u003EPandas has quickly become the \u003Cem\u003Ede facto\u003C\u002Fem\u003E Python library for data and data science workflows; integration with other major data science and machine learning libraries has only fueled a rise in popularity.[^1] Pandas provides functionality to quickly and efficiently read, write, and modify datasets for analysis. To accomplish this, Pandas provides data structures that hold different dimensionalities of data. The \u003Ccode\u003EDataFrame\u003C\u002Fcode\u003E holds 2-dimensional data in the manner of a spreadsheet with rows and columns. It&#39;s through this object that we&#39;ll interact with our WWII THOR dataset. Let&#39;s first examine the Pandas \u003Ccode\u003EDataFrame\u003C\u002Fcode\u003E by loading our csv data into one.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"loading-data-in-pandas\\\"\u003ELoading Data in Pandas\u003C\u002Fh2\u003E\\n\u003Cp\u003ETo begin with, create a new file called \u003Ccode\u003Eloading_data.py\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E#loading_data.py\\nimport pandas as pd\\n\\ndf = pd.read_csv(&#39;thor_wwii.csv&#39;)\\nprint(df)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EWe start by importing the Pandas library and then calling \u003Ccode\u003Eread_csv()\u003C\u002Fcode\u003E and passing a filename to it. Note that the Pandas library is aliased as \u003Cem\u003Epd\u003C\u002Fem\u003E. This alias is a convention followed in the \u003Ca href=\\\"https:\u002F\u002Fpandas.pydata.org\u002Fpandas-docs\u002Fstable\u002F\\\"\u003EPandas official documentation\u003C\u002Fa\u003E and is widely used by the Pandas community. For this reason, I&#39;ll use the \u003Cem\u003Epd\u003C\u002Fem\u003E alias throughout the tutorial.\u003C\u002Fp\u003E\\n\u003Cp\u003EIn this code, \u003Ccode\u003Eread_csv\u003C\u002Fcode\u003E creates a \u003Ccode\u003EDataFrame\u003C\u002Fcode\u003E that holds the rows\u002Fcolumns of our csv data. By convention, the variable name \u003Cem\u003Edf\u003C\u002Fem\u003E is used to represent the loaded dataframe in tutorials and basic code examples. \u003Ca href=\\\"https:\u002F\u002Fpandas.pydata.org\u002Fpandas-docs\u002Fstable\u002Fapi.html#input-output\\\"\u003EMany other methods\u003C\u002Fa\u003E exist for reading data formats other than csv in Pandas, such as JSON, SQL tables, Excel files, and HTML.\u003C\u002Fp\u003E\\n\u003Cp\u003EWhen running this code, \u003Ccode\u003Eprint(df)\u003C\u002Fcode\u003E will output an abridged representation of the loaded data.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003EMSNDATE      THEATER    COUNTRY_FLYING_MISSION    ...     TONS_IC TONS_FRAG TOTAL_TONS\\n03\u002F30\u002F1941          ETO          GREAT BRITAIN    ...         0.0       0.0        0.0\\n11\u002F24\u002F1940          ETO          GREAT BRITAIN    ...         0.0       0.0        0.0\\n12\u002F04\u002F1940          ETO          GREAT BRITAIN    ...         0.0       0.0        0.0\\n12\u002F31\u002F1940          ETO          GREAT BRITAIN    ...         0.0       0.0        0.0\\n\\n[178281 rows x 19 columns]\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThis shows that we have 178,281 records of missions with 19 columns per record. To see what the 19 columns are in full, we can access the dataframe&#39;s  \u003Ccode\u003Ecolumns\u003C\u002Fcode\u003E object by replacing \u003Ccode\u003Eprint(df)\u003C\u002Fcode\u003E in the above code with:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Edf.columns.tolist()\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe output should look like:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E[&#39;MSNDATE&#39;, &#39;THEATER&#39;, &#39;COUNTRY_FLYING_MISSION&#39;, &#39;NAF&#39;, &#39;UNIT_ID&#39;, &#39;AIRCRAFT_NAME&#39;, &#39;AC_ATTACKING&#39;, &#39;TAKEOFF_BASE&#39;, &#39;TAKEOFF_COUNTRY&#39;, &#39;TAKEOFF_LATITUDE&#39;, &#39;TAKEOFF_LONGITUDE&#39;, &#39;TGT_COUNTRY&#39;, &#39;TGT_LOCATION&#39;, &#39;TGT_LATITUDE&#39;, &#39;TGT_LONGITUDE&#39;, &#39;TONS_HE&#39;, &#39;TONS_IC&#39;, &#39;TONS_FRAG&#39;, &#39;TOTAL_TONS&#39;]\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ESome of these column names are self explanatory, but it&#39;s worth pointing out the following: MSNDATE (mission date), NAF (numbered airforce responsible for mission), AC_ATTACKING (number of aircraft), TONS_HE (high-explosives), TONS_IC (incendiary devices), TONS_FRAG (fragmentation bombs).\u003C\u002Fp\u003E\\n\u003Cp\u003EWhen it comes to accessing data within a \u003Ccode\u003EDataFrame\u003C\u002Fcode\u003E, in this tutorial we use one basic approach: indexing. Here to access a single column we pass a string to our dataframe&#39;s indexer: e.g. \u003Ccode\u003Edf[&#39;MSNDATE&#39;]\u003C\u002Fcode\u003E.  To access multiple columns, we pass a list of names to our dataframe&#39;s indexer: e.g. \u003Ccode\u003Edf[[&#39;MSNDATE&#39;, &#39;THEATER&#39;]]\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"the-bokeh-columndatasource\\\"\u003EThe Bokeh ColumnDataSource\u003C\u002Fh2\u003E\\n\u003Cp\u003ENow that we&#39;ve learned how to create a Bokeh plot and how to load tabular data into Pandas, it&#39;s time to learn how to link Pandas&#39; \u003Ccode\u003EDataFrame\u003C\u002Fcode\u003E with Bokeh visualizations. The Bokeh object \u003Ccode\u003EColumnDataSource\u003C\u002Fcode\u003E provides this integration.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe object&#39;s constructor accepts a Pandas \u003Ccode\u003EDataFrame\u003C\u002Fcode\u003E as an argument. After it is created, the \u003Ccode\u003EColumnDataSource\u003C\u002Fcode\u003E can then be passed to glyph methods via the \u003Ccode\u003Esource\u003C\u002Fcode\u003E parameter and other parameters, such as our x and y data, can then reference column names within our source. Let&#39;s go through an example of this.\u003C\u002Fp\u003E\\n\u003Cp\u003EUsing our THOR dataset, we&#39;ll create a scatter plot of the number of attacking aircraft versus the tons of munitions dropped. We will use a new file called \u003Ccode\u003Ecolumn_datasource.py\u003C\u002Fcode\u003E to do this. We&#39;ll also take this opportunity to learn about Bokeh&#39;s interactive hover feature.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E#column_datasource.py\\nimport pandas as pd\\nfrom bokeh.plotting import figure, output_file, show\\nfrom bokeh.models import ColumnDataSource\\nfrom bokeh.models.tools import HoverTool\\n\\noutput_file(&#39;columndatasource_example.html&#39;)\\n\\ndf = pd.read_csv(&#39;thor_wwii.csv&#39;)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EHere, we import Pandas, the \u003Ccode\u003Efigure\u003C\u002Fcode\u003E object and basic functions from \u003Ccode\u003Ebokeh.plotting\u003C\u002Fcode\u003E, and the \u003Ccode\u003EColumnDataSource\u003C\u002Fcode\u003E object from \u003Ccode\u003Ebokeh.models\u003C\u002Fcode\u003E.  We&#39;re also going to expand our knowledge of interactions in this example by adding a hover feature that is facilitated by the \u003Ccode\u003EHoverTool\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EWe then immediately set our output file following Bokeh&#39;s recommended best practices. Finally, we call Pandas \u003Ccode\u003Eread_csv\u003C\u002Fcode\u003E method to load our csv into a \u003Ccode\u003EDataFrame\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Esample = df.sample(50)\\nsource = ColumnDataSource(sample)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ESince we don&#39;t want to plot all 170,000+ rows in our scatterplot (which would require a longer processing time to generate and would create a confusing plot due to the volume of overlapping data), we randomly sample 50 rows using the dataframe&#39;s \u003Ccode\u003Esample\u003C\u002Fcode\u003E method.  We then pass this sample to the \u003Ccode\u003EColumnDataSource\u003C\u002Fcode\u003E constructor and store this in a variable called \u003Ccode\u003Esource\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Ep = figure()\\np.circle(x=&#39;TOTAL_TONS&#39;, y=&#39;AC_ATTACKING&#39;,\\n         source=source,\\n         size=10, color=&#39;green&#39;)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ENext, we create our \u003Ccode\u003Efigure\u003C\u002Fcode\u003E object and call the \u003Ccode\u003Ecircle\u003C\u002Fcode\u003E glyph method to plot our data. This is where the \u003Ccode\u003Esource\u003C\u002Fcode\u003E variable that holds our \u003Ccode\u003EColumnDataSource\u003C\u002Fcode\u003E comes into play. It&#39;s passed as our \u003Ccode\u003Esource\u003C\u002Fcode\u003E argument to the glyph method and the column names holding the number of attacking aircraft (AC_ATTACKING) and tons of munitions dropped (TOTAL_TONS) are passed as our \u003Ccode\u003Ex\u003C\u002Fcode\u003E and \u003Ccode\u003Ey\u003C\u002Fcode\u003E arguments.\u003C\u002Fp\u003E\\n\u003Cp\u003EInterestingly, when we use a \u003Ccode\u003EColumnDataSource\u003C\u002Fcode\u003E we&#39;re not limited to just using column names for \u003Ccode\u003Ex\u003C\u002Fcode\u003E and \u003Ccode\u003Ey\u003C\u002Fcode\u003E parameters. We can also pass a column name for other parameters such as \u003Ccode\u003Esize\u003C\u002Fcode\u003E, \u003Ccode\u003Eline_color\u003C\u002Fcode\u003E, or \u003Ccode\u003Efill_color\u003C\u002Fcode\u003E. This allows styling options to be determined by columns in the datasource itself! If you&#39;d like to see this in action, in the code above, change \u003Ccode\u003Esize=10\u003C\u002Fcode\u003E to \u003Ccode\u003Esize=&#39;TONS_HE&#39;\u003C\u002Fcode\u003E. The size of each dot will then reflect the tons of high explosives used.\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include alert.html text=&quot;Throughout the tutorial, I often pass arguments by name where they could more succinctly be passed by position. This is helpful, in my opinion, for the reader to keep track of what arguments are being passed&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003ENext we add a title and label our axes.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Ep.title.text = &#39;Attacking Aircraft and Munitions Dropped&#39;\\np.xaxis.axis_label = &#39;Tons of Munitions Dropped&#39;\\np.yaxis.axis_label = &#39;Number of Attacking Aircraft&#39;\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EWe can also, at this stage, learn a bit more about the strong interactive, customizable nature of Bokeh plots. In our first Bokeh plot we saw the default Bokeh toolbar, but Bokeh allows us to customize our plot by adding new interactive tools to it.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Ehover = HoverTool()\\nhover.tooltips=[\\n    (&#39;Attack Date&#39;, &#39;@MSNDATE&#39;),\\n    (&#39;Attacking Aircraft&#39;, &#39;@AC_ATTACKING&#39;),\\n    (&#39;Tons of Munitions&#39;, &#39;@TOTAL_TONS&#39;),\\n    (&#39;Type of Aircraft&#39;, &#39;@AIRCRAFT_NAME&#39;)\\n]\\n\\np.add_tools(hover)\\n\\nshow(p)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EBokeh supports \u003Ca href=\\\"https:\u002F\u002Fbokeh.pydata.org\u002Fen\u002Flatest\u002Fdocs\u002Fuser_guide\u002Ftools.html\\\"\u003Emany plotting tools\u003C\u002Fa\u003E, but I introduce \u003Ccode\u003EHoverTool\u003C\u002Fcode\u003E here because it&#39;s particularly useful for data exploration and interaction. \u003Ccode\u003EHoverTool\u003C\u002Fcode\u003E allows you to set a \u003Ccode\u003Etooltips\u003C\u002Fcode\u003E property which takes a list of \u003Ca href=\\\"https:\u002F\u002Fwww.w3schools.com\u002Fpython\u002Fpython_tuples.asp\\\"\u003Etuples\u003C\u002Fa\u003E. The first part of the tuple is a display name and the second is a column name from your \u003Ccode\u003EColumnDataSource\u003C\u002Fcode\u003E prefaced with \u003Ccode\u003E@\u003C\u002Fcode\u003E. Once we&#39;ve instantiated this tool, we add it to the plot using the \u003Ccode\u003Eadd_tool\u003C\u002Fcode\u003E method. We&#39;ll see how this looks in a moment.\u003C\u002Fp\u003E\\n\u003Cp\u003EFinally, we make sure to add the line to show the plot. Now we can run \u003Ccode\u003Ecolumn_datasource.py\u003C\u002Fcode\u003E and interact with our data in the browser.\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;visualizing-with-bokeh-2.png&quot; caption=&quot;Plotting with the ColumnDataSource and More Styling Options&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003ENote that because we are randomly sampling the data, our plot will look different each time we run the code.\u003C\u002Fp\u003E\\n\u003Cp\u003EAt the top and along the axes of the plot, we see the labels that we added. There is also a new tool in the toolbar. This is the hover tool that we added. To see it in action, hover over any data point in the scatterplot. A window will pop up showing the columns we set in our \u003Ccode\u003Etooltip\u003C\u002Fcode\u003E property!\u003C\u002Fp\u003E\\n\u003Cp\u003EBefore moving to the next section of the lesson, try returning to the example above and adding\u002Fremoving other variables and changing display names.\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"categorical-data-and-bar-charts-munitions-dropped-by-country\\\"\u003ECategorical Data and Bar Charts: Munitions Dropped by Country\u003C\u002Fh1\u003E\\n\u003Cp\u003EIn the preceding example, we plotted quantitative data. Frequently, though, we want to plot categorical data. Categorical data, in contrast to quantitative, is data that can be divided into groups, but that does not necessarily have a numerical aspect to it. For example, while your height is numerical, your hair color is categorical. From the perspective of our dataset, features like attacking country hold categorical data, while features like the weight of munitions hold quantitative data.\u003C\u002Fp\u003E\\n\u003Cp\u003EIn this section, we&#39;ll learn how to use categorical data as our x-axis values in Bokeh and how to use the \u003Ccode\u003Evbar\u003C\u002Fcode\u003E glyph method to create a vertical bar chart (an \u003Ccode\u003Ehbar\u003C\u002Fcode\u003E glyph method functions similarly to create a horizontal bar chart). In addition, we&#39;ll learn about preparing categorical data in Pandas by grouping data. Further, we&#39;ll add to our knowledge of Bokeh styling and the hover tool.\u003C\u002Fp\u003E\\n\u003Cp\u003ETo work through this information, we&#39;ll create a bar chart that shows the total tons of munitions dropped by each country listed in our csv.\u003C\u002Fp\u003E\\n\u003Cp\u003EWe start by creating a new file called \u003Ccode\u003Emunitions_by_country.py\u003C\u002Fcode\u003E and adding some initial code.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E#munitions_by_country.py\\nimport pandas as pd\\nfrom bokeh.plotting import figure, output_file, show\\nfrom bokeh.models import ColumnDataSource\\nfrom bokeh.models.tools import HoverTool\\n\\nfrom bokeh.palettes import Spectral5\\nfrom bokeh.transform import factor_cmap\\noutput_file(&#39;munitions_by_country.html&#39;)\\n\\ndf = pd.read_csv(&#39;thor_wwii.csv&#39;)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EFirst, we import the Pandas library and the basic elements from Bokeh (i.e. \u003Ccode\u003Efigure\u003C\u002Fcode\u003E, \u003Ccode\u003Eoutput_file\u003C\u002Fcode\u003E, \u003Ccode\u003Eshow\u003C\u002Fcode\u003E, and \u003Ccode\u003EColumnDataSource\u003C\u002Fcode\u003E). We also make two new imports: \u003Ccode\u003ESpectral5\u003C\u002Fcode\u003E is a pre-made five color pallette, one of Bokeh&#39;s many \u003Ca href=\\\"https:\u002F\u002Fbokeh.pydata.org\u002Fen\u002Flatest\u002Fdocs\u002Freference\u002Fpalettes.html\\\"\u003Epre-made color palettes\u003C\u002Fa\u003E, and \u003Ccode\u003Efactor_cmap\u003C\u002Fcode\u003E is a helper method for mapping colors to bars in a bar-charts.\u003C\u002Fp\u003E\\n\u003Cp\u003EAfter the imports, we set our \u003Ccode\u003Eoutput_file\u003C\u002Fcode\u003E  and load the thor_wwii.csv file into a \u003Ccode\u003EDataFrame\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EWe now need to get from the 170,000+ records of individual missions to one record per attacking country with the total munitions dropped.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Egrouped = df.groupby(&#39;COUNTRY_FLYING_MISSION&#39;)[[&#39;TOTAL_TONS&#39;, &#39;TONS_HE&#39;, &#39;TONS_IC&#39;, &#39;TONS_FRAG&#39;]].sum()\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EPandas lets us do this in a single line of code by using the \u003Ccode\u003Egroupby\u003C\u002Fcode\u003E dataframe method. This method accepts a column by which to group the data and one or more aggregating methods that tell Pandas how to group the data together. The output is a new dataframe.\u003C\u002Fp\u003E\\n\u003Cp\u003ELet&#39;s take this one piece at a time. The \u003Ccode\u003Egroupby(&#39;COUNTRY_FLYING_MISSION&#39;)\u003C\u002Fcode\u003E sets the column that we are grouping on. In other words, this says that we want the resulting dataframe to have one row per unique entry in the column \u003Ccode\u003ECOUNTRY_FLYING_MISSION\u003C\u002Fcode\u003E. Since we don&#39;t care about aggregating all 19 columns in the dataframe, we choose just the tons of munitions columns with the indexer, \u003Ccode\u003E[&#39;TOTAL_TONS&#39;, &#39;TONS_HE&#39;, &#39;TONS_IC&#39;, &#39;TONS_FRAG&#39;]\u003C\u002Fcode\u003E. Finally, we use the \u003Ccode\u003Esum\u003C\u002Fcode\u003E method to let Pandas know how to aggregate all of the different rows. Other methods also exist for aggregating, such as \u003Ccode\u003Ecount\u003C\u002Fcode\u003E, \u003Ccode\u003Emean\u003C\u002Fcode\u003E, \u003Ccode\u003Emax\u003C\u002Fcode\u003E, and \u003Ccode\u003Emin\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EIf you execute \u003Ccode\u003Eprint(grouped)\u003C\u002Fcode\u003E, you&#39;ll see that Pandas has grouped by the five unique countries in our dataset and summed the total tons dropped by each. You can also see the dataset has some problems: South Africa and New Zealand dropped more high explosives than the total tons column. Problems like this are typical of large, manually-created datasets and this is a great reminder why is so important to explore and visualize your data before creating research results.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003E                        TOTAL_TONS     TONS_HE     TONS_IC  TONS_FRAG\\nCOUNTRY_FLYING_MISSION\\nAUSTRALIA                   479.89      453.90      13.600      18.64\\nGREAT BRITAIN           1112598.95   868277.23  209036.158    1208.00\\nNEW ZEALAND                2629.06     4263.70     166.500       0.00\\nSOUTH AFRICA                 11.69       15.00       0.000       0.00\\nUSA                     1625487.68  1297955.65  205288.200  127655.98\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ETo plot this data, let&#39;s convert to kilotons by dividing by 1000.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Egrouped = grouped \u002F 1000\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThis is a convenience that we&#39;ll continue to use in future examples.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Esource = ColumnDataSource(grouped)\\ncountries = source.data[&#39;COUNTRY_FLYING_MISSION&#39;].tolist()\\np = figure(x_range=countries)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ENow, we need to make a \u003Ccode\u003EColumnDataSource\u003C\u002Fcode\u003E from our grouped data and create a \u003Ccode\u003Efigure\u003C\u002Fcode\u003E. Since our x-axis will list the five countries (rather than numerical data) we need to tell the figure how to handle the x-axis.\u003C\u002Fp\u003E\\n\u003Cp\u003ETo do this, we create a list of countries from our source object, using \u003Ccode\u003Esource.data\u003C\u002Fcode\u003E and the column name as key. The list of countries is then passed as the \u003Ccode\u003Ex_range\u003C\u002Fcode\u003E to our \u003Ccode\u003Efigure\u003C\u002Fcode\u003E constructor. Because this is a list of text data, the figure knows the x-axis is categorical and it also knows what possible values our x range can take (i.e. AUSTRALIA, GREAT BRITAIN, etc.).\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Ecolor_map = factor_cmap(field_name=&#39;COUNTRY_FLYING_MISSION&#39;,\\n                    palette=Spectral5, factors=countries)\\n\\np.vbar(x=&#39;COUNTRY_FLYING_MISSION&#39;, top=&#39;TOTAL_TONS&#39;, source=source, width=0.70, color=color_map)\\n\\np.title.text =&#39;Munitions Dropped by Allied Country&#39;\\np.xaxis.axis_label = &#39;Country&#39;\\np.yaxis.axis_label = &#39;Kilotons of Munitions&#39;\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ENow we plot our data as individually colored bars and add basic labels. To color our bars we use the \u003Ccode\u003Efactor_cmap\u003C\u002Fcode\u003E helper function. This creates a special color map that matches an individual color to each category (i.e. what Bokeh calls a \u003Cem\u003Efactor\u003C\u002Fem\u003E). The color map is then passed as the color argument to our \u003Ccode\u003Evbar\u003C\u002Fcode\u003E glyph method.\u003C\u002Fp\u003E\\n\u003Cp\u003EFor the data in our glyph method, we&#39;re passing a source and again referencing column names. Instead of using a \u003Ccode\u003Ey\u003C\u002Fcode\u003E parameter, however, the \u003Ccode\u003Evbar\u003C\u002Fcode\u003E method takes a \u003Ccode\u003Etop\u003C\u002Fcode\u003E parameter. A \u003Ccode\u003Ebottom\u003C\u002Fcode\u003E parameter can equally be specified, but if left out, its default value is 0.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Ehover = HoverTool()\\nhover.tooltips = [\\n    (&quot;Totals&quot;, &quot;@TONS_HE High Explosive \u002F @TONS_IC Incendiary \u002F @TONS_FRAG Fragmentation&quot;)]\\n\\nhover.mode = &#39;vline&#39;\\n\\np.add_tools(hover)\\n\\nshow(p)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EWe add a hover tool again, but now we see that we can use multiple data variables in a single line and add in our own text so the hover popup will list the kilotons of each type of explosive. The \u003Ccode\u003Ehover.mode\u003C\u002Fcode\u003E is new. Three modes exist for the hover tool: \u003Ccode\u003Emouse\u003C\u002Fcode\u003E, \u003Ccode\u003Evline\u003C\u002Fcode\u003E, and \u003Ccode\u003Ehline\u003C\u002Fcode\u003E. These tell the hover tool when to show the popup. \u003Ccode\u003Emouse\u003C\u002Fcode\u003E is the default value and shows a popup when directly over a glyph. \u003Ccode\u003Evline\u003C\u002Fcode\u003E and \u003Ccode\u003Ehline\u003C\u002Fcode\u003E tell the popup to show when a vertical or horizontal line crosses a glyph. With \u003Ccode\u003Evline\u003C\u002Fcode\u003E set here, anytime your mouse passes through an imaginary vertical line extending from each bar, a popup will show.\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;visualizing-with-bokeh-3.png&quot; caption=&quot;A Bar Chart with Categorical Data and Coloring&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include alert.html text=&quot;If you have a chance, it&#39;s worth exploring Bokeh&#39;s \u003Ca href=\\\"https:\u002F\u002Fbokeh.pydata.org\u002Fen\u002Flatest\u002Fdocs\u002Freference\u002Fpalettes.html\\\"\u003Ecolor palettes\u003C\u002Fa\u003E. In the above example, try rewriting the code to use something other than \u003Ccode\u003ESpectral5\u003C\u002Fcode\u003E, such as \u003Ccode\u003EInferno5\u003C\u002Fcode\u003E or \u003Ccode\u003ERdGy5\u003C\u002Fcode\u003E. To take it one step further, you can try your hand at using built-in palettes in any example that uses color.&quot; %}\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"stacked-bar-charts-and-sub-sampling-data-types-of-munitions-dropped-by-country\\\"\u003EStacked Bar Charts and Sub-sampling Data: Types of Munitions Dropped by Country\u003C\u002Fh1\u003E\\n\u003Cp\u003EBecause the previous plot shows that the USA and Great Britain account for the overwhelming majority of bombings, we now focus on these two countries and learn how to make a stacked bar chart that shows the types of munitions each country used.\u003C\u002Fp\u003E\\n\u003Cp\u003EWe&#39;ll start a new file called \u003Ccode\u003Emunitions_by_country_stacked.py\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E#munitions_by_country_stacked.py\\nimport pandas as pd\\nfrom bokeh.plotting import figure, output_file, show\\nfrom bokeh.models import ColumnDataSource\\nfrom bokeh.palettes import Spectral3\\noutput_file(&#39;types_of_munitions.html&#39;)\\n\\ndf = pd.read_csv(&#39;thor_wwii.csv&#39;)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EIn addition to our standard imports, this time we use a three-color Spectral palette, one color for each type of explosive (High Explosive, Incendiary, and Fragmentation).\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Efilter = df[&#39;COUNTRY_FLYING_MISSION&#39;].isin((&#39;USA&#39;,&#39;GREAT BRITAIN&#39;))\\ndf = df[filter]\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ESince the x-axis is again categorical, we&#39;ll need to group and aggregate our data. This time, though, we need to exclude any records hat don&#39;t have a COUNTRY_FLYING_MISSION with a value of GREAT BRITAIN or USA. To do that, we filter our dataframe.\u003C\u002Fp\u003E\\n\u003Cp\u003EFor each row in \u003Ccode\u003Edf\u003C\u002Fcode\u003E, the \u003Ccode\u003Eisin\u003C\u002Fcode\u003E function checks whether COUNTRY_FLYING_MISSION has a value of USA or GREAT BRITAIN. If it does, the corresponding value in the variable \u003Ccode\u003Efilter\u003C\u002Fcode\u003E is \u003Ccode\u003ETrue\u003C\u002Fcode\u003E and if not the value is \u003Ccode\u003EFalse\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EWhen applied to our dataframe via \u003Ccode\u003Edf[filter]\u003C\u002Fcode\u003E, a new dataframe is created in which rows with a \u003Ccode\u003ETrue\u003C\u002Fcode\u003E  value are kept and rows with a \u003Ccode\u003EFalse\u003C\u002Fcode\u003E value are discarded. After the filter has been applied here, executing \u003Ccode\u003Edf.shape\u003C\u002Fcode\u003E shows that 125,526 rows remain of an original 178,281.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Egrouped = df.groupby(&#39;COUNTRY_FLYING_MISSION&#39;)[&#39;TONS_IC&#39;, &#39;TONS_FRAG&#39;, &#39;TONS_HE&#39;].sum()\\n\\n#convert tons to kilotons again\\ngrouped = grouped \u002F 1000\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ENow that we have reduced the dataframe to show only records for the USA and Great Britain, we group our data with \u003Ccode\u003Egroupby\u003C\u002Fcode\u003E and aggregate the three columns that hold bomb types with \u003Ccode\u003Esum\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Esource = ColumnDataSource(grouped)\\ncountries = source.data[&#39;COUNTRY_FLYING_MISSION&#39;].tolist()\\np = figure(x_range=countries)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EAs in the previous example, we create a source object from our grouped data and make sure our figure uses categorical data for the x-axis by setting the \u003Ccode\u003Ex_range\u003C\u002Fcode\u003E to the list of countries.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Ep.vbar_stack(stackers=[&#39;TONS_HE&#39;, &#39;TONS_FRAG&#39;, &#39;TONS_IC&#39;],\\n             x=&#39;COUNTRY_FLYING_MISSION&#39;, source=source,\\n             legend = [&#39;High Explosive&#39;, &#39;Fragmentation&#39;, &#39;Incendiary&#39;],\\n             width=0.5, color=Spectral3)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ETo create the stacked bar chart, we call the \u003Ccode\u003Evbar_stack\u003C\u002Fcode\u003E glyph method. Rather than passing a single column name to a \u003Ccode\u003Ey\u003C\u002Fcode\u003E parameter, we instead pass a list of column names as \u003Ccode\u003Estackers\u003C\u002Fcode\u003E. The order of this list determines the order that the columns will be stacked from bottom to top (after you&#39;ve worked through this example, try switching the column order to see what happens). The \u003Ccode\u003Elegend\u003C\u002Fcode\u003E argument supplies text for each stacker and the \u003Ccode\u003ESpectral3\u003C\u002Fcode\u003E palette provides colors for each stacker.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Ep.title.text =&#39;Types of Munitions Dropped by Allied Country&#39;\\np.legend.location = &#39;top_left&#39;\\n\\np.xaxis.axis_label = &#39;Country&#39;\\np.xgrid.grid_line_color = None    #remove the x grid lines\\n\\np.yaxis.axis_label = &#39;Kilotons of Munitions&#39;\\n\\nshow(p)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EWe add basic styling and labeling, and then output the plot.\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;visualizing-with-bokeh-4.png&quot; caption=&quot;A Stacked Bar Chart with Categorical Data and Coloring&quot; %}\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"time-series-and-annotations-bombing-operations-over-time\\\"\u003ETime-Series and Annotations: Bombing Operations over Time\u003C\u002Fh1\u003E\\n\u003Cp\u003ELet&#39;s now explore the use of incendiary and fragmentation explosive a little more by seeing if there&#39;s any trend in their use over time versus the total munitions dropped. As you have had some time to get used to Bokeh&#39;s syntax, let&#39;s dive right in with a full code example in a new file named \u003Ccode\u003Emy_first_timeseries.py\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E#my_first_timeseries.py\\nimport pandas as pd\\nfrom bokeh.plotting import figure, output_file, show\\nfrom bokeh.models import ColumnDataSource\\nfrom bokeh.palettes import Spectral3\\noutput_file(&#39;simple_timeseries_plot.html&#39;)\\n\\ndf = pd.read_csv(&#39;thor_wwii.csv&#39;)\\n\\n#make sure MSNDATE is a datetime format\\ndf[&#39;MSNDATE&#39;] = pd.to_datetime(df[&#39;MSNDATE&#39;], format=&#39;%m\u002F%d\u002F%Y&#39;)\\n\\ngrouped = df.groupby(&#39;MSNDATE&#39;)[&#39;TOTAL_TONS&#39;, &#39;TONS_IC&#39;, &#39;TONS_FRAG&#39;].sum()\\ngrouped = grouped\u002F1000\\n\\nsource = ColumnDataSource(grouped)\\n\\np = figure(x_axis_type=&#39;datetime&#39;)\\n\\np.line(x=&#39;MSNDATE&#39;, y=&#39;TOTAL_TONS&#39;, line_width=2, source=source, legend=&#39;All Munitions&#39;)\\np.line(x=&#39;MSNDATE&#39;, y=&#39;TONS_FRAG&#39;, line_width=2, source=source, color=Spectral3[1], legend=&#39;Fragmentation&#39;)\\np.line(x=&#39;MSNDATE&#39;, y=&#39;TONS_IC&#39;, line_width=2, source=source, color=Spectral3[2], legend=&#39;Incendiary&#39;)\\n\\np.yaxis.axis_label = &#39;Kilotons of Munitions Dropped&#39;\\n\\nshow(p)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ETake a minute to seriously look through this code and see what you recognize. Two items should stand out as new.\u003C\u002Fp\u003E\\n\u003Cp\u003EFirst, the statement \u003Ccode\u003Edf[&#39;MSNDATE&#39;] = pd.to_datetime(df[&#39;MSNDATE&#39;], format=&#39;%m\u002F%d\u002F%Y&#39;)\u003C\u002Fcode\u003E makes sure our MSNDATE column is a datetime. This is important because often data loaded from a csv file will not be properly typed as datetime. Supplying the \u003Ccode\u003Eformat\u003C\u002Fcode\u003E argument is not required, but doing so significantly speeds up the process.\u003C\u002Fp\u003E\\n\u003Cp\u003ESecond, we pass the argument \u003Ccode\u003Ex_axis_type=&#39;datetime&#39;\u003C\u002Fcode\u003E to our figure constructor to tell it that our x data will be datetimes. Otherwise, Bokeh works seamlessly with time data just like any other type of numerical data!\u003C\u002Fp\u003E\\n\u003Cp\u003ELooking at the output, though, you might notice a major issue.\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;visualizing-with-bokeh-5.png&quot; caption=&quot;A Basic Time-Series Plot&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EThis data is volatile and hard-to-read because it is too fine-grained for our needs. Having daily data over the course of five years is great, but plotting it as such obscures trends in the data. To successfully plot time-series data and look for long-term trends, we need a way to change the time-scale we&#39;re looking at so that, for example, we can plot data summarized by weeks, months, or years.\u003C\u002Fp\u003E\\n\u003Cp\u003EThankfully, Pandas offers a quick and easy way to do this. By modifying a single line of code in the above example, we can \u003Cem\u003Eresample\u003C\u002Fem\u003E our time-series data to any valid unit of time.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"resampling-time-series-data\\\"\u003EResampling Time-Series Data\u003C\u002Fh2\u003E\\n\u003Cp\u003EResampling time-series data can involve either upsampling (creating more records) or downsampling (creating fewer records). For example, a list of daily temperatures could be upsampled to a list of hourly temperatures or downsampled to a list of weekly temperatures. We&#39;ll only be downsampling in this tutorial, but upsampling is very useful when you&#39;re trying to match a sporadically-measured dataset with one that&#39;s more periodically measured.\u003C\u002Fp\u003E\\n\u003Cp\u003ETo resample our data, we use a Pandas \u003Ccode\u003EGrouper\u003C\u002Fcode\u003E object, to which we pass the column name holding our datetimes and a code representing the desired resampling frequency. In the case of our data, the statement \u003Ccode\u003Epd.Grouper(key=&#39;MSNDATE&#39;, freq=&#39;M&#39;) \u003C\u002Fcode\u003E will be used to resample our MSNDATE column by \u003Cem\u003EM\u003C\u002Fem\u003Eonth. We could equally resample by \u003Cem\u003EW\u003C\u002Fem\u003Eeek, \u003Cem\u003EY\u003C\u002Fem\u003Eear, \u003Cem\u003EH\u003C\u002Fem\u003Eour, and \u003Ca href=\\\"http:\u002F\u002Fpandas.pydata.org\u002Fpandas-docs\u002Fstable\u002Ftimeseries.html#offset-aliases\\\"\u003Eso forth\u003C\u002Fa\u003E. These frequency designations can also be prefaced with numbers so that, for example, \u003Ccode\u003Efreq=&#39;2W&#39;\u003C\u002Fcode\u003E resamples at two week intervals!\u003C\u002Fp\u003E\\n\u003Cp\u003ETo complete the process of resampling and plotting our data, we pass the above \u003Ccode\u003EGrouper\u003C\u002Fcode\u003E object to our \u003Ccode\u003Egroupby\u003C\u002Fcode\u003E function in place of the raw column name. The \u003Ccode\u003Egroupby\u003C\u002Fcode\u003E statement from the previous code example should now look like this:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Egrouped = df.groupby(pd.Grouper(key=&#39;MSNDATE&#39;, freq=&#39;M&#39;))[&#39;TOTAL_TONS&#39;, &#39;TONS_IC&#39;, &#39;TONS_FRAG&#39;].sum()\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ERerunning the above code sample will produce a much cleaner plot with obvious trends. The plot now shows four points of interest:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003EFirst, in both the Spring of 1944 and 1945, the scale of Allied bombing operations reached greater intensity.\u003C\u002Fli\u003E\\n\u003Cli\u003ESecond, there is a smaller spike in the summer of 1945 during the acceleration of bombings against the Japanese after Germany&#39;s surrender.\u003C\u002Fli\u003E\\n\u003Cli\u003EThird, four spikes in the use of incendiary weapons appear that could further explored.\u003C\u002Fli\u003E\\n\u003Cli\u003EFourth and finally, there are a few small spikes in the use of fragmentation bombs, the use of which then effectively stops after the surrender of Germany.\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;visualizing-with-bokeh-6.png&quot; caption=&quot;A Time-Series Plot with Data Resampled to Months&quot; %}\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"annotating-trends-in-plots\\\"\u003EAnnotating Trends in Plots\u003C\u002Fh2\u003E\\n\u003Cp\u003ELet&#39;s look more closely now at the bombings in Europe in 1944 and 1945 to see what trends there are with fragmentation and incendiary munitions. We will also point out some of these trends in our plot with annotations. To do this, we&#39;ll filter our dataset so that we work only with bombings in the European Theater of Operations (ETO), resample the data at one-month intervals (\u003Ccode\u003Efreq=&#39;M&#39;\u003C\u002Fcode\u003E), and then plot the results in the same manner as before.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E#annotating_trends.py\\nimport pandas as pd\\nfrom bokeh.plotting import figure, output_file, show\\nfrom bokeh.models import ColumnDataSource\\nfrom datetime import datetime\\nfrom bokeh.palettes import Spectral3\\noutput_file(&#39;eto_operations.html&#39;)\\n\\ndf = pd.read_csv(&#39;thor_wwii.csv&#39;)\\n\\n#filter for the European Theater of Operations\\nfilter = df[&#39;THEATER&#39;]==&#39;ETO&#39;\\ndf = df[filter]\\n\\ndf[&#39;MSNDATE&#39;] = pd.to_datetime(df[&#39;MSNDATE&#39;], format=&#39;%m\u002F%d\u002F%Y&#39;)\\ngroup = df.groupby(pd.Grouper(key=&#39;MSNDATE&#39;, freq=&#39;M&#39;))[&#39;TOTAL_TONS&#39;, &#39;TONS_IC&#39;, &#39;TONS_FRAG&#39;].sum()\\ngroup = group \u002F 1000\\n\\nsource = ColumnDataSource(group)\\n\\np = figure(x_axis_type=&quot;datetime&quot;)\\n\\np.line(x=&#39;MSNDATE&#39;, y=&#39;TOTAL_TONS&#39;, line_width=2, source=source, legend=&#39;All Munitions&#39;)\\np.line(x=&#39;MSNDATE&#39;, y=&#39;TONS_FRAG&#39;, line_width=2, source=source, color=Spectral3[1], legend=&#39;Fragmentation&#39;)\\np.line(x=&#39;MSNDATE&#39;, y=&#39;TONS_IC&#39;, line_width=2, source=source, color=Spectral3[2], legend=&#39;Incendiary&#39;)\\n\\np.title.text = &#39;European Theater of Operations&#39;\\n\\np.yaxis.axis_label = &#39;Kilotons of Munitions Dropped&#39;\\n\\nshow(p)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;visualizing-with-bokeh-7.png&quot; caption=&quot;A Time-Series Plot of the ETO with Data Resampled to Months&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EA few patterns emerge in the ETO data. First we see a very clear escalation of overall bombings leading up to June 6, 1944 and a notable dip during the winter of 1944\u002F1945. Incendiary munitions show three spikes and confirm that the fourth spike seen in the preceding example was directed at the bombing of Japan after Germany&#39;s surrender. The pattern of fragmentation bombs is harder to read, but it&#39;s now clear that they were only seriously used in the European Theater after D-Day.\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include alert.html text=&quot;Try your hand at resampling this data using any of \u003Ca href=\\\"http:\u002F\u002Fpandas.pydata.org\u002Fpandas-docs\u002Fstable\u002Ftimeseries.html#offset-aliases\\\"\u003EPandas&#39; time frequencies \u003C\u002Fa\u003E to see what other trends might emerge. Remember, you can preface these frequencies with numbers as well (e.g. if you were working with historical stock market data, 2Q would give you bi-quarterly data!)&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003ESince we have established that 6 June 1944 and the winter of 1944\u002F1945 mark changes to the bombing patterns in the ETO, let&#39;s highlight these trends using Bokeh&#39;s annotation features.\u003C\u002Fp\u003E\\n\u003Cp\u003ETo do this, we&#39;ll create a \u003Ccode\u003EBoxAnnotation\u003C\u002Fcode\u003E and then add these to our \u003Ccode\u003Efigure\u003C\u002Fcode\u003E before showing it. First, we need to add an additional import statement to our code.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Efrom bokeh.models import BoxAnnotation\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ETo create the box, we first need to determine its coordinates. Coordinates for Bokeh annotations can be either absolute (i.e. positioned using screen units), meaning they always stay in one place, or they can be positioned in relation to data. Our annotations will all be positioned using data coordinates.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Ebox_left = pd.to_datetime(&#39;6-6-1944&#39;)\\nbox_right = pd.to_datetime(&#39;16-12-1944&#39;)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe left of the box will be 6 June 1944 (D-Day) and for the right of the box we&#39;ll choose the first day of the Battle of the Bulge: 16 December 1944. In this case, the dates follow a month-day-year format, but \u003Ccode\u003Eto_datetime\u003C\u002Fcode\u003E also works with \u003Ca href=\\\"https:\u002F\u002Fpandas.pydata.org\u002Fpandas-docs\u002Fstable\u002Fgenerated\u002Fpandas.to_datetime.html\\\"\u003Eday-first and year-first formats\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EWe pass these coordinates to the \u003Ccode\u003EBoxAnnotation\u003C\u002Fcode\u003E constructor along with some styling arguments. Then, we add it to the our figure using the \u003Ccode\u003Eadd_layout()\u003C\u002Fcode\u003E method.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Ebox = BoxAnnotation(left=box_left, right=box_right,\\n                    line_width=1, line_color=&#39;black&#39;, line_dash=&#39;dashed&#39;,\\n                    fill_alpha=0.2, fill_color=&#39;orange&#39;)\\n\\np.add_layout(box)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;visualizing-with-bokeh-8.png&quot; caption=&quot;A Time-Series Plot of the ETO with Annotations Added&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include alert.html text=&quot;Try to create a similar plot for the Pacific Theater of Operations (PTO). Annotate the invasion of Iwo Jima (February 19, 1945) and Japan&#39;s announcement of surrender (August 15, 1945).&quot; %}\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"spatial-data-mapping-target-locations\\\"\u003ESpatial Data: Mapping Target Locations\u003C\u002Fh1\u003E\\n\u003Cp\u003EIn this final part of the lesson we&#39;ll look at the spatial components of fragmentation bombs.\u003C\u002Fp\u003E\\n\u003Cp\u003EBokeh provides \u003Ca href=\\\"https:\u002F\u002Fbokeh.pydata.org\u002Fen\u002Flatest\u002Fdocs\u002Freference\u002Ftile_providers.html\\\"\u003Ebuilt-in tile providers\u003C\u002Fa\u003E that render base maps of the world. These are contained in the \u003Ccode\u003Ebokeh.tile_providers\u003C\u002Fcode\u003E module. For this example, we&#39;ll use the CartoDB Tile Service (CARTODBPOSITRON).\u003C\u002Fp\u003E\\n\u003Cp\u003EWe&#39;ll also be using functions imported from the \u003Ccode\u003Epyproj\u003C\u002Fcode\u003E library. Since our coordinates are stored as latitude\u002Flongitude, we&#39;ll define a custom function to convert them before mapping. Note that although Bokeh is coordinate-system neutral, it uses the Web Mercator projection for mapping, a standard found across web tile providers. The subject of coordinate systems and projections are outside the scope of this tutorial, but the interested reader will find many useful web resources on these topics.\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include alert.html text=&quot;If your own dataset has place names, but not latitude and longitude, don&#39;t worry! You can find ways to easily get coordinates from place names in Programming Historian&#39;s \u003Ca href=\\\"\u002Flessons\u002Fgeocoding-qgis\\\"\u003EGeocoding Historical Data using QGIS\u003C\u002Fa\u003E or \u003Ca href=\\\"\u002Flessons\u002Fmapping-with-python-leaflet#geocoding-with-python\\\"\u003EWeb Mapping with Python and Leaflet\u003C\u002Fa\u003E.&quot; %}\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E# target_locations.py\\nimport pandas as pd\\nfrom bokeh.plotting import figure, output_file, show\\nfrom bokeh.models import ColumnDataSource, Range1d\\nfrom bokeh.layouts import layout\\nfrom bokeh.palettes import Spectral3\\nfrom bokeh.tile_providers import get_provider\\nfrom pyproj import Transformer\\noutput_file(&#39;mapping_targets.html&#39;)\\n\\n# helper function to convert lat\u002Flong to easting\u002Fnorthing for mapping\\n# this relies on functions from the pyproj library\\n\\n\\ndef LongLat_to_EN(long, lat):\\n    try:\\n        transformer = Transformer.from_crs(&#39;epsg:4326&#39;, &#39;epsg:3857&#39;)\\n        easting, northing = transformer.transform(long, lat)\\n        return easting, northing\\n    except:\\n        return None, None\\n\\n\\ndf = pd.read_csv(&quot;thor_wwii.csv&quot;)\\n\\n\\ndf[&#39;E&#39;], df[&#39;N&#39;] = zip(\\n    *df.apply(lambda x: LongLat_to_EN(x[&#39;TGT_LONGITUDE&#39;], x[&#39;TGT_LATITUDE&#39;]), axis=1)))\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe boilerplate imports and our conversion function are defined. Next, we load our data and apply our conversion function to create new E and N columns that store our Web Mercator easting and northing.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Egrouped = df.groupby([&#39;E&#39;, &#39;N&#39;])[[&#39;TONS_IC&#39;, &#39;TONS_FRAG&#39;]].sum().reset_index()\\n\\nfilter = grouped[&#39;TONS_FRAG&#39;] != 0\\ngrouped = grouped[filter]\\n\\nsource = ColumnDataSource(grouped)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EBecause a single target can appear in multiple records, we need to group the data by E and N to get unique target locations. Otherwise, we would map the same target every time it appears in a record.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe \u003Ccode\u003Ereset_index\u003C\u002Fcode\u003E function applied after aggregating is new here. By default, when Pandas groups these two columns it will make E and N the index for each row in the new dataframe. Since we just want E and N to remain as normal columns for mapping, we call \u003Ccode\u003Ereset_index\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Eleft = -2150000\\nright = 18000000\\nbottom = -5300000\\ntop = 11000000\\n\\np = figure(x_range=Range1d(left, right), y_range=Range1d(bottom, top))\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ETo set bounds for our map, we&#39;ll set a minimum and maximum value for our plot&#39;s \u003Ccode\u003Ex_range\u003C\u002Fcode\u003E and \u003Ccode\u003Ey_range\u003C\u002Fcode\u003E. We use the \u003Ccode\u003ERange1D\u003C\u002Fcode\u003E object, which represents bounded 1-dimensional data in Bokeh.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Eprovider = get_provider(&#39;CARTODBPOSITRON&#39;)\\np.add_tile(provider)\\n\\np.circle(x=&#39;E&#39;, y=&#39;N&#39;, source=source, line_color=&#39;grey&#39;, fill_color=&#39;yellow&#39;)\\n\\np.axis.visible = False\\n\\nshow(p)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EFinally, we call \u003Ccode\u003Eadd_tile\u003C\u002Fcode\u003E and pass the tile provider we imported. Then, we use glyph methods just like in any other plot. Here, we call \u003Ccode\u003Ecircle\u003C\u002Fcode\u003E and pass the easting and northing columns as our x and y data.\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;visualizing-with-bokeh-9.png&quot; caption=&quot;A Map of Target Locations&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EHaving plotted which targets in Europe and Asia were bombed with fragmentation bombs, we can now start to examine patterns of destruction with greater detail. In the above code, we also summed incendiary bombs. Try to alter the code to create a map of these targets.\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"bokeh-as-a-visualization-tool\\\"\u003EBokeh as a Visualization Tool\u003C\u002Fh1\u003E\\n\u003Cp\u003EBokeh&#39;s strength as a visualization tool lies in its ability to show differing types of data in an interactive and web-friendly manner. This tutorial has only scratched the surface of Bokeh&#39;s capabilities and the reader is encourage to delve deeper into the library&#39;s workings. A great place to start is the \u003Ca href=\\\"https:\u002F\u002Fbokeh.pydata.org\u002Fen\u002Flatest\u002Fdocs\u002Fgallery.html\\\"\u003EBokeh gallery\u003C\u002Fa\u003E, where you can see a variety of visualizations and decide how you might apply these techniques to your own data. If you&#39;re more inclined to dive right into further code examples, Bokeh&#39;s \u003Ca href=\\\"https:\u002F\u002Fmybinder.org\u002Fv2\u002Fgh\u002Fbokeh\u002Fbokeh-notebooks\u002Fmaster?filepath=tutorial%2F00%20-%20Introduction%20and%20Setup.ipynb\\\"\u003Eonline notebook\u003C\u002Fa\u003E is an excellent place to start!\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"further-resources\\\"\u003EFurther Resources\u003C\u002Fh1\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Ca href=\\\"https:\u002F\u002Fbokeh.pydata.org\u002Fen\u002Flatest\u002Fdocs\u002Fuser_guide.html\\\"\u003EBokeh User Guide\u003C\u002Fa\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ca href=\\\"https:\u002F\u002Fbokeh.pydata.org\u002Fen\u002Flatest\u002Fdocs\u002Fgallery.html\\\"\u003EBokeh Gallery\u003C\u002Fa\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ca href=\\\"https:\u002F\u002Fpandas.pydata.org\u002Fpandas-docs\u002Fstable\u002Findex.html\\\"\u003EPandas Documentation\u003C\u002Fa\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ca href=\\\"https:\u002F\u002Fwww.kdnuggets.com\u002F2017\u002F01\u002Fpandas-cheat-sheet.html\\\"\u003EPandas Cheat Sheet\u003C\u002Fa\u003E\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Ca href=\\\"https:\u002F\u002Fwww.kdnuggets.com\u002F2017\u002F03\u002Fbokeh-cheat-sheet.html\\\"\u003EBokeh Cheat Sheet\u003C\u002Fa\u003E\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003E[^1]: David Robinson, &#39;Why is Python Growing so Quickly?&#39;, \u003Cem\u003EStack Overflow Blog\u003C\u002Fem\u003E, 14 September 2017 \u003Ca href=\\\"https:\u002F\u002Fstackoverflow.blog\u002F2017\u002F09\u002F14\u002Fpython-growing-quickly\u002F\\\"\u003Ehttps:\u002F\u002Fstackoverflow.blog\u002F2017\u002F09\u002F14\u002Fpython-growing-quickly\u002F\u003C\u002Fa\u003E\u003C\u002Fp\u003E\\n\"}"}</script></div>
	</body>
</html>
