<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="description" content="" />
		<link rel="icon" href="/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		

		

		<link rel="stylesheet" href="/_app/assets/start-61d1577b.css">
		<link rel="modulepreload" href="/_app/start-c09d08cd.js">
		<link rel="modulepreload" href="/_app/chunks/vendor-9b9d6288.js">
		<link rel="modulepreload" href="/_app/pages/__layout.svelte-de46afb2.js">
		<link rel="modulepreload" href="/_app/pages/_lang_/__layout.svelte-e75718c6.js">
		<link rel="modulepreload" href="/_app/chunks/stores-191d1505.js">
		<link rel="modulepreload" href="/_app/pages/_lang_/_lessons_/_slug_/index.svelte-efe77d76.js">

		<script type="module">
			import { start } from "/_app/start-c09d08cd.js";
			start({
				target: document.querySelector("#svelte"),
				paths: {"base":"","assets":""},
				session: {},
				route: true,
				spa: false,
				trailing_slash: "never",
				hydrate: {
					status: 200,
					error: null,
					nodes: [
						import("/_app/pages/__layout.svelte-de46afb2.js"),
						import("/_app/pages/_lang_/__layout.svelte-e75718c6.js"),
						import("/_app/pages/_lang_/_lessons_/_slug_/index.svelte-efe77d76.js")
					],
					url: new URL("sveltekit://prerender/es/lecciones/salida-palabras-clave-contexto-ngrams"),
					params: {lang:"es",lessons:"lecciones",slug:"salida-palabras-clave-contexto-ngrams"}
				}
			});
		</script><script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('/service-worker.js');
			}
		</script>
	</head>
	<body>
		<div id="svelte">


The Programming Historian <a href="/en">English</a> <a href="/es">Spanish</a>
<br>
This is the es edition.

<h1>Salida de palabras clave en contexto en un archivo HTML con Python</h1>

<!-- HTML_TAG_START --><p>{% include toc.html %}</p>
<h2 id="objetivo-de-la-lección">Objetivo de la lección</h2>
<p>Esta lección se basa en <a href="/es/lecciones/palabras-clave-en-contexto-n-grams">Palabras clave en contexto (usando n-grams)</a>, en la que se extrajeron n-gramas de un texto. Aquí aprenderás cómo generar una salidad de todos los n-gramas de una palabra clave dada en un documento descargado de Internet, y visualizarlos claramente en la ventana de tu navegador.</p>
<h2 id="archivos-necesarios-para-esta-lección">Archivos necesarios para esta lección</h2>
<ul>
<li><code>obo.py</code></li>
</ul>
<p>Si no tienes estos archivos de las lecciones anteriores, puedes descargar un <a href="/assets/python-es-lecciones8.zip">archivo zip de las lecciones anteriores</a>.</p>
<h2 id="crear-un-diccionario-de-n-gramas">Crear un diccionario de n-gramas</h2>
<p>Nuestros n-gramas tienen un número impar de palabras por una razón. En este punto, los n-gramas no contienen en realidad una palabra clave; son solamente una lista de palabras. Sin  embargo, si tenemos un n-grama impar, la palabra central siempre tendrá el mismo número de palabras a la izquierda y a la derecha. Entonces, podemos utilizar esa palabra del medio como nuestra palabra clave. Por ejemplo, [&quot;it&quot;, &quot;was&quot;, &quot;the&quot;, &quot;best&quot;, &quot;of&quot;, &quot;times&quot;, &quot;it&quot;] es un 7-grama de la palabra clave &quot;best&quot;.</p>
<p>Ya que tenemos un texto largo, quisieramos ser capaces de generar una salida para todos los n-gramas de nuestra palabra clave. Para ello, vamos a poner cada n-grama en un <em>diccionario</em> utilizando la palabra de en medio como <em>clave</em>. Para averiguar la palabra clave de cada n-grama podemos utilizar la <em>posición de índice</em> de la lista. Si estamos trabajando con 5-gramas, por ejemplo, el contexto izquierdo consistirá en términos indexados en 0, 1; la palabra clave en 2 y los términos del contexto derecho en 3, 4. Dado que los índices en Python comienzan en 0, la palabra clave de un 5-grama siempre estará en la posición de índice 2.</p>
<p>Eso está bien para 5-gramas; pero para hacer el código un poco más robusto queremos asegurarnos de que funcionará para cualquier longitud de n-gramas, asumiendo que su longitud será un número impar. Para ello, vamos a tomar la longitud del n-grama, dividirla entre 2 y dejar aparte el resto. Podemos lograrlo usando un operador de <code>división de piso</code> representado por dos barras, que divide y da como resultado el número entero más cercano, siempre redondeando hacia abajo -de ahí el término <code>piso</code>.</p>
<pre><code class="language-python">print(7 // 2)
print(5 // 2)
print(3 // 2)
</code></pre>
<p>Construyamos una función que pueda identificar la posición de índice de la palabra clave cuando se le de un n-grama con un número impar de palabras. Guarda lo siguiente en <code>obo.py</code></p>
<pre><code class="language-python"># Dada una lista de n-gramas identifica el índice de la palabra clave.

def nGramasAdicKWIC(ngramas):
    indicePClave = len(ngramas[0]) // 2

    return indicePClave
</code></pre>
<p>Para determinar el índice de la palabra clave hemos utilizado la propiedad <code>len</code> para decirnos cuántos elementos hay en el primer n-grama, a continuación hacemos una división de piso para aislar la posición de índice media. Puedes ver si esto funciona mediante la creación de un nuevo programa <code>obten-palabraClave.py</code> y ejecutarlo. Si todo va bien y ya que estamos tratando con un 5-grama, debes obtener 2 como la posición de índice de la palabra clave tal y como se determinó anteriormente.</p>
<pre><code class="language-python">#obten-palabraClave.py

import obo

prueba = &#39;en la frase de prueba hay ocho palabras&#39;
ngramas = obo.obtenNGramas(prueba.split(), 5)

print(obo.nGramasAdicKWIC(ngramas))
</code></pre>
<p>Ahora que sabemos la ubicación de las palabras clave, vamos a añadir todo en un diccionario que pueda utilizarse para generar la salida de todos los n-gramas KWIC para una palabra clave determinada. Estudia este código y luego remplaza tu <code>nGramasAdicKWIC</code> con lo que sigue en tu módulo <code>obo.py</code>.</p>
<pre><code class="language-python"># Dada una lista de n-gramas, regresa un diccionario de KWICs,
# indexado por palabras clave.

def nGramasAdicKWIC(ngramas):
    indicePClave = len(ngramas[0]) // 2

    kwicdicc = {}

    for k in ngramas:
        if k[indicePClave] not in kwicdicc:
            kwicdicc[k[indicePClave]] = [k]
        else:
            kwicdicc[k[indicePClave]].append(k)
    return kwicdicc
</code></pre>
<p>Un bucle <code>for</code>y una declaración <code>if</code> comprueban cada n-grama para ver si su palabra clave está ya almacenada en el diccionario. Si no es así, se añade una nueva entrada. Si lo es, añade a una entrada anterior. Ahora tenemos un diccionario llamado <em>kwicdicc</em> que contiene todos los n-gramas, clasificables por palabra clave y podemos regresar a la tarea de dar salida a la información en un formato más útil como lo hicimos en <a href="/es/lecciones/salida-de-datos-como-archivo-html">Salida de datos como archivo HTML</a>.</p>
<p>Prueba volver a ejecutar el programa <code>obten-palabraClave.py</code> y ahora podrás ver qué es lo que hay en tu diccionario KWIC.</p>
<h2 id="salida-de-datos-a-html">Salida de datos a HTML</h2>
<h3 id="pretty-printing-de-una-kwic"><em>Pretty Printing</em> de una KWIC</h3>
<p>&quot;<em>Pretty Printing</em>&quot; es un proceso de formateo de salida que puede ser leído fácilmente por seres humanos. En el caso de nuestras palabras clave en contexto, las queremos tener alineadas en una columna con los términos del contexto de la izquierda alineados a la derecha y los términos del contexto de la derecha alineados a la izquierda. En otras palabras, queremos que la visualización de nuestro KWIC se vea parecido a esto:</p>
<pre><code>               amongst them a black there was one
                first saw the black i turned to
             had observed the black in the mob
                 say who that black was no seeing
                      i saw a black at first but
                 swear to any black yes there is
                   swear to a black than to a
                              ...
</code></pre>
<p>Esta técnica no es la mejor manera de formatear texto desde la perspectiva de un diseñador de páginas Web. Si tienes experiencia con HTML te animamos a que utilices otro método que permita crear un archivo HTML compatible con los estándares, pero para los nuevos estudiantes, simplemente no podemos resistirnos a la facilidad de la técnica que vamos a describir. Después de todo, el objetivo es integrar los principios de programación rápidamente en nuestra investigación.</p>
<p>Para conseguir este efecto, vamos a tener que hacer un número de manipulaciones de listas y cadenas. Empecemos por averiguar cómo se ve nuestro diccionario de salida en su estado actual. Entonces podremos trabajar en perfeccionarlo para lo que queremos.</p>
<pre><code class="language-python"># html-a-pretty-print.py
import obo

# crea un diccionario de n-gramas
n = 7
url = &#39;http://www.oldbaileyonline.org/browse.jsp?id=t17800628-33&amp;div=t17800628-33&#39;

texto = obo.paginaWebATexto(url)
listaPalabrasCompleta = obo.quitaNoAlfaNum(texto)
ngramas = obo.obtenNGramas(listaPalabrasCompleta, n)
diccionarioPalabras = obo.nGramasAdicKWIC(ngramas)

print(diccionarioPalabras[&quot;black&quot;])
</code></pre>
<p>Como puedes observar al ejecutar el programa anterior, la salida de datos aún no es muy legible. Lo que tenemos que hacer es dividir el n-grama en tres partes: antes de la palabra clave, la palabra clave y después de la palabra clave. Podemos utilizar las técnicas aprendidas en los capítulos anteriores para encerrar todo en HTML para que sea fácil de leer.</p>
<p>Utilizando el mismo método anterior de <code>slice</code>, vamos a crear nuestras tres partes. Abre un intérprete de Python para ensayar los siguiente ejemplos. Pon especial atención a lo que aparece antes y después de los dos puntos en cada caso. Saber cómo manipular el método de <code>slice</code> es una poderosa habilidad para un nuevo historiador programador.</p>
<pre><code class="language-python"># ParseError: Could not check this chunk!
# calcula la longitud del n-grama
kwic = &#39;amongst them a black there was one&#39;.split()
n = len(kwic)
print(n)
-&gt; 7

# calcula la posición de índice de la palabra clave
indicePClave = n // 2
print(indicePClave)
-&gt; 3

# muestra los elementos antes de la palabra clave
print(kwic[:indicePClave])
-&gt; [&#39;amongst&#39;, &#39;them&#39;, &#39;a&#39;]

# muestra solo la palabra clave
print(kwic[indicePClave])
-&gt; black

# muestra los elementos después de la palabra clave
print(kwic[(indicePClave+1):])
-&gt; [&#39;there&#39;, &#39;was&#39;, &#39;one&#39;]
</code></pre>
<p>Ahora que sabemos cómo encontrar cada uno de los tres segmentos, necesitamos dar formato a cada uno en cada una de las columnas de nuestra pantalla.</p>
<p>El contexto de la derecha consistirá simplemente en una cadena de términos separados por espacios en blanco. Utilizaremos el método <code>join</code> para convertir las entradas de la lista en una cadena.</p>
<pre><code class="language-python">
print(&#39; &#39;.join(kwic[(indicePClave+1):]))
-&gt; there was one
</code></pre>
<p>Queremos que las palabras clave tengan un poco de espacio blanco de relleno a su alrededor. Podemos lograr esto mediante el uso de un método de cadena llamado <code>center</code> que servirá para adaptar el texto a la mitad de la pantalla. Podemos agregar relleno al hacer la longitud de la cadena más larga que la palabra clave. La expresión que sige añade tres espacios en blanco (6/2) a cada lado de la palabra clave. Hemos añadido marcas de almohadilla al principio y al final de la expresión para que puedas ver los espacios en blanco inciales y finales.</p>
<pre><code class="language-python">print(&#39;#&#39; + str(kwic[indicePClave]).center(len(kwic[indicePClave])+6) + &#39;#&#39;)
-&gt; #   black   #
</code></pre>
<p>Por último, queremos que el contexto de la izquierda esté alineado a la derecha. Dependiendo de qué tan grande sea <em>n</em>, vamos a necesitar incrementar la longitud total de esta columna. Haremos esto mediante la definición de una variable llamada <em>width</em> (<em>ancho</em>) y luego hacer que la longitud de la columna sea un múltiplo de esa variable (se utilizó un ancho de 10 caracteres, pero se puede hacer más grande o más pequeña según se desee). El método <code>rjust</code> se encarga de alinear a la derecha. Una vez más, hemos añadido marcas de almohadilla para que puedas ver los espacios en blanco.</p>
<pre><code class="language-python">width = 10
print(&#39;#&#39; + &#39; &#39;.join(kwic[:indicePClave]).rjust(width*indicePClave) + &#39;#&#39;)
-&gt; #                 amongst them a#
</code></pre>
<p>Ahora podemos combinar esto en una función que tome una KWIC y nos regrese una cadena &quot;<em>pretty-printed</em>&quot;. Añade esto al módulo <code>obo.py</code>. Estudia el código para asegurarte que lo entiendes antes de seguir adelante.</p>
<pre><code class="language-python"># Dada una KWIC, regresa una cadena que esté formateada para
# pretty printing.

def prettyPrintKWIC(kwic):
    n = len(kwic)
    indicePClave = n // 2
    width = 10

    salidaCadena = &#39; &#39;.join(kwic[:indicePClave]).rjust(width*indicePClave)
    salidaCadena += str(kwic[indicePClave]).center(len(kwic[indicePClave])+6)
    salidaCadena += &#39; &#39;.join(kwic[(indicePClave+1):])

    return salidaCadena
</code></pre>
<h2 id="ensamblando-todo">Ensamblando todo</h2>
<p>Ahora podemos crear un programa que, dado un URL y una palabra clave, envuelve en HTML la visualización de una KWIC y genera su salida en Firefox. Este programa empieza y termina de una manera similar como el programa que calcula la frecuencia de palabras. Escribe o copia el código en tu editor de texto, guárdalo como <code>html-a-kwic.py</code> y ejecútalo. Deberás elegir entre obo.envuelveCadenaenHTMLMac() u obo.envuelveCadenaenHTMLWindows() según corresponda a tu sistema, como hicimos antes.</p>
<pre><code class="language-python"># html-a-kwic.py

import obo

# crea un diccionario de n-gramas
n = 7
url = &#39;http://www.oldbaileyonline.org/browse.jsp?id=t17800628-33&amp;div=t17800628-33&#39;

texto = obo.paginaWebATexto(url)
listaPalabrasCompleta = (&#39;# &#39; * (n//2)).split()
listaPalabrasCompleta = obo.quitaNoAlfaNum(texto)
listaPalabrasCompleta += (&#39;# &#39; * (n//2)).split()
ngramas = obo.obtenNGramas(listaPalabrasCompleta, n)
diccionarioPalabras = obo.nGramasAdicKWIC(ngramas)

# genera salida de KWIC y envuelve con html
objetivo = &#39;black&#39;
outstr = &#39;&lt;pre&gt;&#39;
if objetivo in diccionarioPalabras:
    for k in diccionarioPalabras[objetivo]:
        outstr += obo.prettyPrintKWIC(k)
        outstr += &#39;&lt;br /&gt;&#39;
else:
    outstr += &#39;Keyword not found in source&#39;

outstr += &#39;&lt;/pre&gt;&#39;
obo.envuelveCadenaenHTML(&#39;html-a-kwic&#39;, url, outstr)
</code></pre>
<p>La primera parte del programa es igual que en el caso anterior. En la segunda parte del programa hemos encerrado todo en una etiqueta HTML <em>pre</em> (pre-formateada), lo cual le indica al navegador que no se confunda con los espacios que hemos agregado.</p>
<p>Además, observa que hemos utilizado el método <code>has_key</code> en el diccionario para asegurarnos que la palabra clave realmente se encuentra en nuestro texto. Si no es así, podemos imprimir un mensaje para el usuario antes de enviar la salida a Firefox. Prueba cambiar la variable <em>objetivo</em> a algunas otras palabras clave. Intenta con alguna que tú sepas que no se encuentra en el texto para asegurarte que tu programa no genere salida de datos cuando no deba.</p>
<p>Ahora hemos creado un programa que busca una palabra clave en un diccionario creado a partir de una página HTML de la Web, y luego produce una salida de datos con n-gramas de esa palabra clave en otro archivo HTML para visualizar en la Web. Todas las lecciones hasta este punto han incluido partes del vocabulario de Python y métodos necesarios para crear este programa final. Al referirte a esas lecciones, ahora puedes experimentar con Python para crear programas que realicen tareas específicas que te ayudarán en tu proceso de investigación.</p>
<h2 id="sincronía-de-código">Sincronía de código</h2>
<p>Esta lección marca el final de la serie de lecciones originales sobre Python. El código terminado de la serie puede descargarse como un archivo zip. Si las estás siguiendo con Mac o Linux deberás abrir el archivo <code>obo.py</code> y cambiar &quot;file:///Users/username/Desktop/programming-historian/&quot; a la ruta del archivo en el directorio de tu propia computadora.</p>
<ul>
<li>python-es-lecciones9.zip <a href="/assets/python-es-lecciones9.zip">zip sync</a></li>
</ul>
<p><em>Nota:</em> Ahora puedes ir a la siguiente lección (en inglés) para aprender a <a href="/lessons/downloading-multiple-records-using-query-strings">Descargar registros múltiples</a></p>
<!-- HTML_TAG_END -->

<script type="application/json" data-type="svelte-data" data-url="salida-palabras-clave-contexto-ngrams/raw.json">{"status":200,"statusText":"","headers":{"content-type":"application/json; charset=utf-8"},"body":"{\"metadata\":{\"title\":\"Salida de palabras clave en contexto en un archivo HTML con Python\",\"authors\":[\"William J. Turkel\",\"Adam Crymble\"],\"date\":\"2012-07-17T00:00:00.000Z\",\"translation_date\":\"2017-03-15T00:00:00.000Z\",\"editors\":[\"Miriam Posner\"],\"reviewers\":[\"Jim Clifford\",\"Frederik Elwert\"],\"translator\":[\"Víctor Gayol\"],\"translation-editor\":[\"Adam Crymble\"],\"translation-reviewer\":[\"Jairo A. Melo\",\"Maria José Afanador-Llach\",\"Antonio Rojas Castro\"],\"review-ticket\":\"https:\u002F\u002Fgithub.com\u002Fprogramminghistorian\u002Fph-submissions\u002Fissues\u002F51\",\"layout\":\"lesson\",\"previous\":\"palabras-clave-en-contexto-n-grams\",\"original\":\"output-keywords-in-context-in-html-file\",\"python_warning\":false,\"difficulty\":2,\"activity\":\"presenting\",\"topics\":[\"python\"],\"abstract\":\"Esta lección se basa en 'Palabras clave en contexto (usando n-grams)', en la que se extrajeron n-gramas de un texto. Aquí aprenderás cómo generar una salidad de todos los n-gramas de una palabra clave dada en un documento descargado de Internet, y visualizarlos claramente en la ventana de tu navegador.\",\"avatar_alt\":\"Grabado de un león, un oso y un mono caminando.\",\"doi\":\"10.46430\u002Fphes0026\",\"sequence\":14,\"series_total\":14},\"html_body\":\"\u003Cp\u003E{% include toc.html %}\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"objetivo-de-la-lección\\\"\u003EObjetivo de la lección\u003C\u002Fh2\u003E\\n\u003Cp\u003EEsta lección se basa en \u003Ca href=\\\"\u002Fes\u002Flecciones\u002Fpalabras-clave-en-contexto-n-grams\\\"\u003EPalabras clave en contexto (usando n-grams)\u003C\u002Fa\u003E, en la que se extrajeron n-gramas de un texto. Aquí aprenderás cómo generar una salidad de todos los n-gramas de una palabra clave dada en un documento descargado de Internet, y visualizarlos claramente en la ventana de tu navegador.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"archivos-necesarios-para-esta-lección\\\"\u003EArchivos necesarios para esta lección\u003C\u002Fh2\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Ccode\u003Eobo.py\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003ESi no tienes estos archivos de las lecciones anteriores, puedes descargar un \u003Ca href=\\\"\u002Fassets\u002Fpython-es-lecciones8.zip\\\"\u003Earchivo zip de las lecciones anteriores\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"crear-un-diccionario-de-n-gramas\\\"\u003ECrear un diccionario de n-gramas\u003C\u002Fh2\u003E\\n\u003Cp\u003ENuestros n-gramas tienen un número impar de palabras por una razón. En este punto, los n-gramas no contienen en realidad una palabra clave; son solamente una lista de palabras. Sin  embargo, si tenemos un n-grama impar, la palabra central siempre tendrá el mismo número de palabras a la izquierda y a la derecha. Entonces, podemos utilizar esa palabra del medio como nuestra palabra clave. Por ejemplo, [&quot;it&quot;, &quot;was&quot;, &quot;the&quot;, &quot;best&quot;, &quot;of&quot;, &quot;times&quot;, &quot;it&quot;] es un 7-grama de la palabra clave &quot;best&quot;.\u003C\u002Fp\u003E\\n\u003Cp\u003EYa que tenemos un texto largo, quisieramos ser capaces de generar una salida para todos los n-gramas de nuestra palabra clave. Para ello, vamos a poner cada n-grama en un \u003Cem\u003Ediccionario\u003C\u002Fem\u003E utilizando la palabra de en medio como \u003Cem\u003Eclave\u003C\u002Fem\u003E. Para averiguar la palabra clave de cada n-grama podemos utilizar la \u003Cem\u003Eposición de índice\u003C\u002Fem\u003E de la lista. Si estamos trabajando con 5-gramas, por ejemplo, el contexto izquierdo consistirá en términos indexados en 0, 1; la palabra clave en 2 y los términos del contexto derecho en 3, 4. Dado que los índices en Python comienzan en 0, la palabra clave de un 5-grama siempre estará en la posición de índice 2.\u003C\u002Fp\u003E\\n\u003Cp\u003EEso está bien para 5-gramas; pero para hacer el código un poco más robusto queremos asegurarnos de que funcionará para cualquier longitud de n-gramas, asumiendo que su longitud será un número impar. Para ello, vamos a tomar la longitud del n-grama, dividirla entre 2 y dejar aparte el resto. Podemos lograrlo usando un operador de \u003Ccode\u003Edivisión de piso\u003C\u002Fcode\u003E representado por dos barras, que divide y da como resultado el número entero más cercano, siempre redondeando hacia abajo -de ahí el término \u003Ccode\u003Episo\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Eprint(7 \u002F\u002F 2)\\nprint(5 \u002F\u002F 2)\\nprint(3 \u002F\u002F 2)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EConstruyamos una función que pueda identificar la posición de índice de la palabra clave cuando se le de un n-grama con un número impar de palabras. Guarda lo siguiente en \u003Ccode\u003Eobo.py\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E# Dada una lista de n-gramas identifica el índice de la palabra clave.\\n\\ndef nGramasAdicKWIC(ngramas):\\n    indicePClave = len(ngramas[0]) \u002F\u002F 2\\n\\n    return indicePClave\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EPara determinar el índice de la palabra clave hemos utilizado la propiedad \u003Ccode\u003Elen\u003C\u002Fcode\u003E para decirnos cuántos elementos hay en el primer n-grama, a continuación hacemos una división de piso para aislar la posición de índice media. Puedes ver si esto funciona mediante la creación de un nuevo programa \u003Ccode\u003Eobten-palabraClave.py\u003C\u002Fcode\u003E y ejecutarlo. Si todo va bien y ya que estamos tratando con un 5-grama, debes obtener 2 como la posición de índice de la palabra clave tal y como se determinó anteriormente.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E#obten-palabraClave.py\\n\\nimport obo\\n\\nprueba = &#39;en la frase de prueba hay ocho palabras&#39;\\nngramas = obo.obtenNGramas(prueba.split(), 5)\\n\\nprint(obo.nGramasAdicKWIC(ngramas))\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EAhora que sabemos la ubicación de las palabras clave, vamos a añadir todo en un diccionario que pueda utilizarse para generar la salida de todos los n-gramas KWIC para una palabra clave determinada. Estudia este código y luego remplaza tu \u003Ccode\u003EnGramasAdicKWIC\u003C\u002Fcode\u003E con lo que sigue en tu módulo \u003Ccode\u003Eobo.py\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E# Dada una lista de n-gramas, regresa un diccionario de KWICs,\\n# indexado por palabras clave.\\n\\ndef nGramasAdicKWIC(ngramas):\\n    indicePClave = len(ngramas[0]) \u002F\u002F 2\\n\\n    kwicdicc = {}\\n\\n    for k in ngramas:\\n        if k[indicePClave] not in kwicdicc:\\n            kwicdicc[k[indicePClave]] = [k]\\n        else:\\n            kwicdicc[k[indicePClave]].append(k)\\n    return kwicdicc\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EUn bucle \u003Ccode\u003Efor\u003C\u002Fcode\u003Ey una declaración \u003Ccode\u003Eif\u003C\u002Fcode\u003E comprueban cada n-grama para ver si su palabra clave está ya almacenada en el diccionario. Si no es así, se añade una nueva entrada. Si lo es, añade a una entrada anterior. Ahora tenemos un diccionario llamado \u003Cem\u003Ekwicdicc\u003C\u002Fem\u003E que contiene todos los n-gramas, clasificables por palabra clave y podemos regresar a la tarea de dar salida a la información en un formato más útil como lo hicimos en \u003Ca href=\\\"\u002Fes\u002Flecciones\u002Fsalida-de-datos-como-archivo-html\\\"\u003ESalida de datos como archivo HTML\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EPrueba volver a ejecutar el programa \u003Ccode\u003Eobten-palabraClave.py\u003C\u002Fcode\u003E y ahora podrás ver qué es lo que hay en tu diccionario KWIC.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"salida-de-datos-a-html\\\"\u003ESalida de datos a HTML\u003C\u002Fh2\u003E\\n\u003Ch3 id=\\\"pretty-printing-de-una-kwic\\\"\u003E\u003Cem\u003EPretty Printing\u003C\u002Fem\u003E de una KWIC\u003C\u002Fh3\u003E\\n\u003Cp\u003E&quot;\u003Cem\u003EPretty Printing\u003C\u002Fem\u003E&quot; es un proceso de formateo de salida que puede ser leído fácilmente por seres humanos. En el caso de nuestras palabras clave en contexto, las queremos tener alineadas en una columna con los términos del contexto de la izquierda alineados a la derecha y los términos del contexto de la derecha alineados a la izquierda. En otras palabras, queremos que la visualización de nuestro KWIC se vea parecido a esto:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003E               amongst them a black there was one\\n                first saw the black i turned to\\n             had observed the black in the mob\\n                 say who that black was no seeing\\n                      i saw a black at first but\\n                 swear to any black yes there is\\n                   swear to a black than to a\\n                              ...\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EEsta técnica no es la mejor manera de formatear texto desde la perspectiva de un diseñador de páginas Web. Si tienes experiencia con HTML te animamos a que utilices otro método que permita crear un archivo HTML compatible con los estándares, pero para los nuevos estudiantes, simplemente no podemos resistirnos a la facilidad de la técnica que vamos a describir. Después de todo, el objetivo es integrar los principios de programación rápidamente en nuestra investigación.\u003C\u002Fp\u003E\\n\u003Cp\u003EPara conseguir este efecto, vamos a tener que hacer un número de manipulaciones de listas y cadenas. Empecemos por averiguar cómo se ve nuestro diccionario de salida en su estado actual. Entonces podremos trabajar en perfeccionarlo para lo que queremos.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E# html-a-pretty-print.py\\nimport obo\\n\\n# crea un diccionario de n-gramas\\nn = 7\\nurl = &#39;http:\u002F\u002Fwww.oldbaileyonline.org\u002Fbrowse.jsp?id=t17800628-33&amp;div=t17800628-33&#39;\\n\\ntexto = obo.paginaWebATexto(url)\\nlistaPalabrasCompleta = obo.quitaNoAlfaNum(texto)\\nngramas = obo.obtenNGramas(listaPalabrasCompleta, n)\\ndiccionarioPalabras = obo.nGramasAdicKWIC(ngramas)\\n\\nprint(diccionarioPalabras[&quot;black&quot;])\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EComo puedes observar al ejecutar el programa anterior, la salida de datos aún no es muy legible. Lo que tenemos que hacer es dividir el n-grama en tres partes: antes de la palabra clave, la palabra clave y después de la palabra clave. Podemos utilizar las técnicas aprendidas en los capítulos anteriores para encerrar todo en HTML para que sea fácil de leer.\u003C\u002Fp\u003E\\n\u003Cp\u003EUtilizando el mismo método anterior de \u003Ccode\u003Eslice\u003C\u002Fcode\u003E, vamos a crear nuestras tres partes. Abre un intérprete de Python para ensayar los siguiente ejemplos. Pon especial atención a lo que aparece antes y después de los dos puntos en cada caso. Saber cómo manipular el método de \u003Ccode\u003Eslice\u003C\u002Fcode\u003E es una poderosa habilidad para un nuevo historiador programador.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E# ParseError: Could not check this chunk!\\n# calcula la longitud del n-grama\\nkwic = &#39;amongst them a black there was one&#39;.split()\\nn = len(kwic)\\nprint(n)\\n-&gt; 7\\n\\n# calcula la posición de índice de la palabra clave\\nindicePClave = n \u002F\u002F 2\\nprint(indicePClave)\\n-&gt; 3\\n\\n# muestra los elementos antes de la palabra clave\\nprint(kwic[:indicePClave])\\n-&gt; [&#39;amongst&#39;, &#39;them&#39;, &#39;a&#39;]\\n\\n# muestra solo la palabra clave\\nprint(kwic[indicePClave])\\n-&gt; black\\n\\n# muestra los elementos después de la palabra clave\\nprint(kwic[(indicePClave+1):])\\n-&gt; [&#39;there&#39;, &#39;was&#39;, &#39;one&#39;]\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EAhora que sabemos cómo encontrar cada uno de los tres segmentos, necesitamos dar formato a cada uno en cada una de las columnas de nuestra pantalla.\u003C\u002Fp\u003E\\n\u003Cp\u003EEl contexto de la derecha consistirá simplemente en una cadena de términos separados por espacios en blanco. Utilizaremos el método \u003Ccode\u003Ejoin\u003C\u002Fcode\u003E para convertir las entradas de la lista en una cadena.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E\\nprint(&#39; &#39;.join(kwic[(indicePClave+1):]))\\n-&gt; there was one\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EQueremos que las palabras clave tengan un poco de espacio blanco de relleno a su alrededor. Podemos lograr esto mediante el uso de un método de cadena llamado \u003Ccode\u003Ecenter\u003C\u002Fcode\u003E que servirá para adaptar el texto a la mitad de la pantalla. Podemos agregar relleno al hacer la longitud de la cadena más larga que la palabra clave. La expresión que sige añade tres espacios en blanco (6\u002F2) a cada lado de la palabra clave. Hemos añadido marcas de almohadilla al principio y al final de la expresión para que puedas ver los espacios en blanco inciales y finales.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Eprint(&#39;#&#39; + str(kwic[indicePClave]).center(len(kwic[indicePClave])+6) + &#39;#&#39;)\\n-&gt; #   black   #\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EPor último, queremos que el contexto de la izquierda esté alineado a la derecha. Dependiendo de qué tan grande sea \u003Cem\u003En\u003C\u002Fem\u003E, vamos a necesitar incrementar la longitud total de esta columna. Haremos esto mediante la definición de una variable llamada \u003Cem\u003Ewidth\u003C\u002Fem\u003E (\u003Cem\u003Eancho\u003C\u002Fem\u003E) y luego hacer que la longitud de la columna sea un múltiplo de esa variable (se utilizó un ancho de 10 caracteres, pero se puede hacer más grande o más pequeña según se desee). El método \u003Ccode\u003Erjust\u003C\u002Fcode\u003E se encarga de alinear a la derecha. Una vez más, hemos añadido marcas de almohadilla para que puedas ver los espacios en blanco.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Ewidth = 10\\nprint(&#39;#&#39; + &#39; &#39;.join(kwic[:indicePClave]).rjust(width*indicePClave) + &#39;#&#39;)\\n-&gt; #                 amongst them a#\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EAhora podemos combinar esto en una función que tome una KWIC y nos regrese una cadena &quot;\u003Cem\u003Epretty-printed\u003C\u002Fem\u003E&quot;. Añade esto al módulo \u003Ccode\u003Eobo.py\u003C\u002Fcode\u003E. Estudia el código para asegurarte que lo entiendes antes de seguir adelante.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E# Dada una KWIC, regresa una cadena que esté formateada para\\n# pretty printing.\\n\\ndef prettyPrintKWIC(kwic):\\n    n = len(kwic)\\n    indicePClave = n \u002F\u002F 2\\n    width = 10\\n\\n    salidaCadena = &#39; &#39;.join(kwic[:indicePClave]).rjust(width*indicePClave)\\n    salidaCadena += str(kwic[indicePClave]).center(len(kwic[indicePClave])+6)\\n    salidaCadena += &#39; &#39;.join(kwic[(indicePClave+1):])\\n\\n    return salidaCadena\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Ch2 id=\\\"ensamblando-todo\\\"\u003EEnsamblando todo\u003C\u002Fh2\u003E\\n\u003Cp\u003EAhora podemos crear un programa que, dado un URL y una palabra clave, envuelve en HTML la visualización de una KWIC y genera su salida en Firefox. Este programa empieza y termina de una manera similar como el programa que calcula la frecuencia de palabras. Escribe o copia el código en tu editor de texto, guárdalo como \u003Ccode\u003Ehtml-a-kwic.py\u003C\u002Fcode\u003E y ejecútalo. Deberás elegir entre obo.envuelveCadenaenHTMLMac() u obo.envuelveCadenaenHTMLWindows() según corresponda a tu sistema, como hicimos antes.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E# html-a-kwic.py\\n\\nimport obo\\n\\n# crea un diccionario de n-gramas\\nn = 7\\nurl = &#39;http:\u002F\u002Fwww.oldbaileyonline.org\u002Fbrowse.jsp?id=t17800628-33&amp;div=t17800628-33&#39;\\n\\ntexto = obo.paginaWebATexto(url)\\nlistaPalabrasCompleta = (&#39;# &#39; * (n\u002F\u002F2)).split()\\nlistaPalabrasCompleta = obo.quitaNoAlfaNum(texto)\\nlistaPalabrasCompleta += (&#39;# &#39; * (n\u002F\u002F2)).split()\\nngramas = obo.obtenNGramas(listaPalabrasCompleta, n)\\ndiccionarioPalabras = obo.nGramasAdicKWIC(ngramas)\\n\\n# genera salida de KWIC y envuelve con html\\nobjetivo = &#39;black&#39;\\noutstr = &#39;&lt;pre&gt;&#39;\\nif objetivo in diccionarioPalabras:\\n    for k in diccionarioPalabras[objetivo]:\\n        outstr += obo.prettyPrintKWIC(k)\\n        outstr += &#39;&lt;br \u002F&gt;&#39;\\nelse:\\n    outstr += &#39;Keyword not found in source&#39;\\n\\noutstr += &#39;&lt;\u002Fpre&gt;&#39;\\nobo.envuelveCadenaenHTML(&#39;html-a-kwic&#39;, url, outstr)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ELa primera parte del programa es igual que en el caso anterior. En la segunda parte del programa hemos encerrado todo en una etiqueta HTML \u003Cem\u003Epre\u003C\u002Fem\u003E (pre-formateada), lo cual le indica al navegador que no se confunda con los espacios que hemos agregado.\u003C\u002Fp\u003E\\n\u003Cp\u003EAdemás, observa que hemos utilizado el método \u003Ccode\u003Ehas_key\u003C\u002Fcode\u003E en el diccionario para asegurarnos que la palabra clave realmente se encuentra en nuestro texto. Si no es así, podemos imprimir un mensaje para el usuario antes de enviar la salida a Firefox. Prueba cambiar la variable \u003Cem\u003Eobjetivo\u003C\u002Fem\u003E a algunas otras palabras clave. Intenta con alguna que tú sepas que no se encuentra en el texto para asegurarte que tu programa no genere salida de datos cuando no deba.\u003C\u002Fp\u003E\\n\u003Cp\u003EAhora hemos creado un programa que busca una palabra clave en un diccionario creado a partir de una página HTML de la Web, y luego produce una salida de datos con n-gramas de esa palabra clave en otro archivo HTML para visualizar en la Web. Todas las lecciones hasta este punto han incluido partes del vocabulario de Python y métodos necesarios para crear este programa final. Al referirte a esas lecciones, ahora puedes experimentar con Python para crear programas que realicen tareas específicas que te ayudarán en tu proceso de investigación.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"sincronía-de-código\\\"\u003ESincronía de código\u003C\u002Fh2\u003E\\n\u003Cp\u003EEsta lección marca el final de la serie de lecciones originales sobre Python. El código terminado de la serie puede descargarse como un archivo zip. Si las estás siguiendo con Mac o Linux deberás abrir el archivo \u003Ccode\u003Eobo.py\u003C\u002Fcode\u003E y cambiar &quot;file:\u002F\u002F\u002FUsers\u002Fusername\u002FDesktop\u002Fprogramming-historian\u002F&quot; a la ruta del archivo en el directorio de tu propia computadora.\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003Epython-es-lecciones9.zip \u003Ca href=\\\"\u002Fassets\u002Fpython-es-lecciones9.zip\\\"\u003Ezip sync\u003C\u002Fa\u003E\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003E\u003Cem\u003ENota:\u003C\u002Fem\u003E Ahora puedes ir a la siguiente lección (en inglés) para aprender a \u003Ca href=\\\"\u002Flessons\u002Fdownloading-multiple-records-using-query-strings\\\"\u003EDescargar registros múltiples\u003C\u002Fa\u003E\u003C\u002Fp\u003E\\n\"}"}</script></div>
	</body>
</html>
